<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta charset="utf-8"/>
<meta name="description" content="Structured data exchange for C/C++"/>
<meta name="keywords" content="structured data, JSON, C, C++, C99, software library, open source"/>
<meta name="author" content="Attila Kovacs"/>
<meta name="copyright" content="(C)2024 Attila Kovacs" />
<meta name="robots" content="index,follow"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-D69CXTY2CJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-D69CXTY2CJ');
</script>
<link rel="shortcut icon" type="image/x-icon" href="/xchange/resources/favicon.ico" />
<link rel="icon" type="image/png" sizes="192x192" href="/xchange/resources/android-chrome-192x192.png" />
<link rel="icon" type="image/png" sizes="512x512" href="/xchange/resources/android-chrome-512x512.png" />
<link rel="apple-touch-icon" type="image/png" href="/xchange/resources/apple-touch-icon.png" />
<title>xchange: xchange</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="smithsonian-logo-55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">xchange<span id="projectnumber">&#160;v1.0</span>
   </div>
   <div id="projectbrief">Structured data exchange for C/C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">xchange </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README-xchange"></a> <a href="https://doi.org/10.5281/zenodo.14634824"><img src="resources/796202092.svg" alt="DOI" style="pointer-events: none;" class="inline"/></a></p>
<p>Structured data representation and JSON support for C/C++.</p>
<ul>
<li><a href="https://smithsonian.github.io/xchange/apidoc/html/files.html">API documentation</a></li>
<li><a href="https://smithsonian.github.io/xchange">Project page</a> on github.io</li>
</ul>
<p>Author: Attila Kovacs</p>
<p>Updated for 1.0 and later releases.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Table of Contents</h2>
<ul>
<li><a class="el" href="index.html#xchange-introduction">Introduction</a></li>
<li><a class="el" href="index.html#building-xchange">Building</a></li>
<li><a class="el" href="index.html#xchange-linking">Linking your application against `xchange`</a></li>
<li><a class="el" href="index.html#structured-data">Structured data</a></li>
<li><a class="el" href="index.html#json-interchange">JSON parser and emitter</a></li>
<li><a class="el" href="index.html#xchange-error-handling">Error handling</a></li>
<li><a class="el" href="index.html#xchange-debugging-support">Debugging support</a></li>
<li><a class="el" href="index.html#xchange-future-plans">Future plans</a></li>
<li><a class="el" href="index.html#xchange-release-schedule">Release schedule</a></li>
</ul>
<hr  />
<p><a class="anchor" id="xchange-introduction"></a> </p>
<h2><a class="anchor" id="autotoc_md12"></a>
Introduction</h2>
<p>The <b>xchange</b> library provides structured data representation and exchange in C/C++, and includes support for JSON parsing and generation. It is free to use, in any way you like, without licensing restrictions.</p>
<p>For JSON parsing end emitting, <b>xchange</b> provides a higher-level data model than <b>cjson</b>, with high-level functions for accessing and manipulating data both with less code and with cleaner code.</p>
<p>The <b>xchange</b> library was created, and is maintained, by Attila Kov√°cs at the Center for Astrophysics | Harvard &amp; Smithsonian, and it is available through the <a href="https://github.com/Smithsonian/xchange">Smithsonian/xchange</a> repository on GitHub.</p>
<hr  />
<p><a class="anchor" id="building-xchange"></a> </p>
<h2><a class="anchor" id="autotoc_md14"></a>
Building</h2>
<p>The <b>xchange</b> library can be built either as a shared (<code>libxchange.so[.1]</code>) and as a static (<code>libxchange.a</code>) library, depending on what suits your needs best.</p>
<p>You can configure the build, either by editing <code>config.mk</code> or else by defining the relevant environment variables prior to invoking <code>make</code>. The following build variables can be configured:</p>
<ul>
<li><code>CC</code>: The C compiler to use (default: <code>gcc</code>).</li>
<li><code>CPPFLAGS</code>: C preprocessor flags, such as externally defined compiler constants.</li>
<li><code>CFLAGS</code>: Flags to pass onto the C compiler (default: <code>-g -Os -Wall</code>). Note, <code>-Iinclude</code> will be added automatically.</li>
<li><code>CSTANDARD</code>: Optionally, specify the C standard to compile for, e.g. <code>c99</code> to compile for the C99 standard. If defined then <code>-std=$(CSTANDARD)</code> is added to <code>CFLAGS</code> automatically.</li>
<li><code>WEXTRA</code>: If set to 1, <code>-Wextra</code> is added to <code>CFLAGS</code> automatically.</li>
<li><code>FORTIFY</code>: If set it will set the <code>_FORTIFY_SOURCE</code> macro to the specified value (<code>gcc</code> supports values 1 through 3). It affords varying levels of extra compile time / runtime checks.</li>
<li><code>LDFLAGS</code>: Extra linker flags (default: <em>not set</em>). Note, <code>-lm -lpthread</code> will be added automatically.</li>
<li><code>CHECKEXTRA</code>: Extra options to pass to <code>cppcheck</code> for the <code>make check</code> target</li>
<li><code>DOXYGEN</code>: Specify the <code>doxygen</code> executable to use for generating documentation. If not set (default), <code>make</code> will use <code>doxygen</code> in your <code>PATH</code> (if any). You can also set it to <code>none</code> to disable document generation and the checking for a usable <code>doxygen</code> version entirely.</li>
</ul>
<p>After configuring, you can simply run <code>make</code>, which will build the <code>shared</code> (<code>lib/libxchange.so[.1]</code>) and <code>static</code> (<code>lib/libxchange.a</code>) libraries, local HTML documentation (provided <code>doxygen</code> is available), and performs static analysis via the <code>check</code> target. Or, you may build just the components you are interested in, by specifying the desired <code>make</code> target(s). (You can use <code>make help</code> to get a summary of the available <code>make</code> targets).</p>
<p>After building the library you can install the above components to the desired locations on your system. For a system-wide install you may simply run:</p>
<div class="fragment"><div class="line">$ sudo make install</div>
</div><!-- fragment --><p>Or, to install in some other locations, you may set a prefix and/or <code>DESTDIR</code>. For example, to install under <code>/opt</code> instead, you can:</p>
<div class="fragment"><div class="line">$ sudo make prefix=&quot;/opt&quot; install</div>
</div><!-- fragment --><p>Or, to stage the installation (to <code>/usr</code>) under a 'build root':</p>
<div class="fragment"><div class="line">$ make DESTDIR=&quot;/tmp/stage&quot; install</div>
</div><!-- fragment --><hr  />
<p><a class="anchor" id="xchange-linking"></a> </p>
<h2><a class="anchor" id="autotoc_md16"></a>
Linking your application against &lt;tt&gt;xchange&lt;/tt&gt;</h2>
<p>Provided you have installed the shared (<code>libxchange.so</code>) or static (<code>libxchange.a</code>) library in a location that is in your <code>LD_LIBRARY_PATH</code> (e.g. in <code>/usr/lib</code> or <code>/usr/local/lib</code>) you can simply link your program using the <code>-lxchange</code> flag. Your <code>Makefile</code> may look like:</p>
<div class="fragment"><div class="line">myprog: ...</div>
<div class="line">    $(CC) -o $@ $^ $(LDFLAGS) -lxchange </div>
</div><!-- fragment --><p>(Or, you might simply add <code>-lxchange</code> to <code>LDFLAGS</code> and use a more standard recipe.) And, in if you installed the <b>xchange</b> library elsewhere, you can simply add the location to <code>LD_LIBRARY_PATH</code> prior to linking.</p>
<hr  />
<p><a class="anchor" id="structured-data"></a> </p>
<h2><a class="anchor" id="autotoc_md18"></a>
Structured data</h2>
<ul>
<li><a class="el" href="index.html#xchange-data-types">Basic data types</a></li>
<li><a class="el" href="index.html#xchange-scalars">Scalars</a></li>
<li><a class="el" href="index.html#xchange-arrays">Arrays</a></li>
<li><a class="el" href="index.html#xchange-creating-structure">Creating structure</a></li>
<li><a class="el" href="index.html#xchange-aggregate-ids">Aggregate IDs</a></li>
<li><a class="el" href="index.html#accessing-data">Accessing substructures and elements</a></li>
<li><a class="el" href="index.html#sorting-fields">Sorting fields</a></li>
</ul>
<p>The <b>xchange</b> library defines the <code><a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a></code> type to represent structured data. It is defined in <code><a class="el" href="xchange_8h.html">xchange.h</a></code>, but as a user you really do not need to know much about its layout, as you probably want to avoid low-level direct access to its elements. Rather, you should be using the functions of the <b>xchange</b> API to create, modify, or access data within.</p>
<p>Under the hood, the <code><a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a></code> contains a linked list of fields, each an <code><a class="el" href="structXField.html" title="An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...">XField</a></code> data type to represent a single element, or an array of elements, of the above mentioned types, including embedded <code>Xstructure</code>s. In this way, an <code>Xstructure</code> can easily represent a multi-level hierarchy of a composite data object. Each <code><a class="el" href="structXField.html" title="An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...">XField</a></code> has a name/ID, an associated data type, a dimensionality, a shape (for multidimensional arrays).</p>
<p><a class="anchor" id="xchange-data-types"></a> </p>
<h3><a class="anchor" id="autotoc_md19"></a>
Basic data types</h3>
<p>The <b>xchange</b> library supports most basic (primitive) data types used across programming languages. The table below shows the unique <b>xchange</b> types recognized by the library and the corresponding pointer/array type values:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"><code>XType</code>   </th><th class="markdownTableHeadCenter">element type   </th><th class="markdownTableHeadLeft">Comment / example    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>X_BOOLEAN</code>   </td><td class="markdownTableBodyCenter"><code>boolean</code>   </td><td class="markdownTableBodyLeft"><code>TRUE</code> (1 or non-zero) or <code>FALSE</code> (0)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>X_BYTE</code>   </td><td class="markdownTableBodyCenter"><code>char</code>   </td><td class="markdownTableBodyLeft">'<code>-128</code>' to '<code>127</code>'    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>X_INT16</code>   </td><td class="markdownTableBodyCenter"><code>int16_t</code>   </td><td class="markdownTableBodyLeft">'<code>-32768</code>' to '<code>32767</code>'    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>X_INT32</code>   </td><td class="markdownTableBodyCenter"><code>int32_t</code>   </td><td class="markdownTableBodyLeft">'<code>-2,147,483,648</code>' to '<code>2,147,483,647</code>'    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>X_INT64</code>   </td><td class="markdownTableBodyCenter"><code>int64_t</code>   </td><td class="markdownTableBodyLeft">'<code>-9,223,372,036,854,775,808</code>' to '<code>9,223,372,036,854,775,807</code>'    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>X_FLOAT</code>   </td><td class="markdownTableBodyCenter"><code>float</code>   </td><td class="markdownTableBodyLeft"><code>1</code>, <code>1.0</code>, <code>-1.234567e-28</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>X_DOUBLE</code>   </td><td class="markdownTableBodyCenter"><code>double</code>   </td><td class="markdownTableBodyLeft"><code>1</code>, <code>1.0</code>, <code>-1.2345678901234567e-111</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>X_STRING</code>   </td><td class="markdownTableBodyCenter"><code>char *</code>   </td><td class="markdownTableBodyLeft"><code>Hello world!</code>, <code>line1\nline2\n</code> (0-terminated)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code><a class="el" href="xchange_8h.html#a76d723969626d4e25235eb24533e3e3a" title="A fixed-size sequence of &#39;length&#39; bytes.">X_CHARS(n)</a></code>   </td><td class="markdownTableBodyCenter"><code>char[n]</code>   </td><td class="markdownTableBodyLeft">Fixed-length character arrays (also w/o termination)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>X_FIELD</code>   </td><td class="markdownTableBodyCenter"><code><a class="el" href="structXField.html" title="An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...">XField</a></code>   </td><td class="markdownTableBodyLeft">For irregular and/or heterogeneous arrays    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>X_STRUCT</code>   </td><td class="markdownTableBodyCenter"><code><a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a></code>   </td><td class="markdownTableBodyLeft">substructure   </td></tr>
</table>
<p>The <code>boolean</code> type is defined in <code><a class="el" href="xchange_8h.html">xchange.h</a></code>. The <code><a class="el" href="structXField.html#a0f61d63b009d0880a89c843bd50d8d76">XField.value</a></code> is a pointer / array of the given element type. So, an <code><a class="el" href="structXField.html" title="An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...">XField</a></code> of type <code>X_DOUBLE</code> will have a <code>value</code> field that should be cast a <code>(double *)</code>, while for type <code>X_STRING</code> the value field shall be cast as <code>(char **)</code>.</p>
<p>Additionally, the <b>xchange</b> also defines derivative <code>XType</code> values for native integer storage types, whose widths depend on the particular CPU architecture. Hence, these are aliased to matching unique types (above) by the C preprocessor during compilation:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"><code>XType</code>   </th><th class="markdownTableHeadCenter">element type   </th><th class="markdownTableHeadCenter">width   </th><th class="markdownTableHeadLeft">alias of    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>X_SHORT</code>   </td><td class="markdownTableBodyCenter"><code>short</code>   </td><td class="markdownTableBodyCenter">&gt;= 16-bits   </td><td class="markdownTableBodyLeft">typically <code>X_INT16</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>X_INT</code>   </td><td class="markdownTableBodyCenter"><code>int</code>   </td><td class="markdownTableBodyCenter">&gt;= 16-bits   </td><td class="markdownTableBodyLeft">often <code>X_INT32</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>X_LONG</code>   </td><td class="markdownTableBodyCenter"><code>long</code>   </td><td class="markdownTableBodyCenter">&gt;= 32-bits   </td><td class="markdownTableBodyLeft">typically <code>X_INT32</code> or <code>X_INT64</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>X_LLONG</code>   </td><td class="markdownTableBodyCenter"><code>long long</code>   </td><td class="markdownTableBodyCenter">&gt;= 64-bits   </td><td class="markdownTableBodyLeft">typically <code>X_INT64</code>   </td></tr>
</table>
<p><a class="anchor" id="xchange-strings"></a> </p>
<h4><a class="anchor" id="autotoc_md20"></a>
Strings</h4>
<p>Strings can be either fixed-width or else a 0-terminated sequence of ASCII characters. At its basic level the library does not impose any restriction of what ASCII characters may be used. However, we recommend that users stick to the JSON convention, and represent special characters in escaped form. E.g. carriage return (<code>0xd</code>) as <code>\</code> followed by <code>n</code>, tabs as <code>\</code> followed by <code>t</code>, etc. As a result a single backslash should also be escaped as two consecutive <code>\</code> characters. You might use <code>xjsonEscapeString()</code> or <code>xjsonUnescapeString()</code> to perform the conversion to/from standard JSON representation.</p>
<p>Fixed-width strings of up to <em>n</em> characters are represented internally as the <code>XCHAR(n)</code> type. They may be 0-terminated as appropriate, or else represent exactly <em>n</em> ASCII characters without explicit termination. Alternatively, the <code>X_STRING</code> type represents ASCII strings of arbitrary length, up to the 0-termination character.</p>
<p><a class="anchor" id="xchange-scalars"></a> </p>
<h3><a class="anchor" id="autotoc_md21"></a>
Scalars</h3>
<p>You can create scalar fields easily, e.g.:</p>
<div class="fragment"><div class="line"><span class="comment">// Create &quot;is_ok&quot; as a boolean field with TRUE</span></div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *fb = <a class="code hl_function" href="xstruct_8c.html#ad2fa86a7d296f1efa6b41079bc2a6b65">xCreateBooleanField</a>(<span class="stringliteral">&quot;is_ok&quot;</span>, <a class="code hl_define" href="xjson_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create &quot;serial-number&quot; field with an integer value</span></div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *fi = <a class="code hl_function" href="xstruct_8c.html#aa4405d56659397e044b6d4fdda394dfa">xCreateIntField</a>(<span class="stringliteral">&quot;serial-number&quot;</span>, 1001);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create &quot;my measurement&quot; as a double-precision value 1.04</span></div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *fd = <a class="code hl_function" href="xstruct_8c.html#ab7ac206d0ec3608a0872f09c7f7bc189">xCreateDoubleField</a>(<span class="stringliteral">&quot;my-measurement&quot;</span>, 1.04);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create &quot;description&quot; as a string</span></div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *fs = <a class="code hl_function" href="xstruct_8c.html#a9dc77bed0d8b738ba615019721a6a2b6">xCreateStringField</a>(<span class="stringliteral">&quot;description&quot;</span>, <span class="stringliteral">&quot;blah-blah-blah&quot;</span>);</div>
<div class="ttc" id="astructXField_html"><div class="ttname"><a href="structXField.html">XField</a></div><div class="ttdoc">An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...</div><div class="ttdef"><b>Definition</b> xchange.h:169</div></div>
<div class="ttc" id="axjson_8c_html_aa8cecfc5c5c054d2875c03e77b7be15d"><div class="ttname"><a href="xjson_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a></div><div class="ttdeci">#define TRUE</div><div class="ttdoc">Boolean 'true' in case it isn't already defined.</div><div class="ttdef"><b>Definition</b> xjson.c:23</div></div>
<div class="ttc" id="axstruct_8c_html_a9dc77bed0d8b738ba615019721a6a2b6"><div class="ttname"><a href="xstruct_8c.html#a9dc77bed0d8b738ba615019721a6a2b6">xCreateStringField</a></div><div class="ttdeci">XField * xCreateStringField(const char *name, const char *value)</div><div class="ttdef"><b>Definition</b> xstruct.c:853</div></div>
<div class="ttc" id="axstruct_8c_html_aa4405d56659397e044b6d4fdda394dfa"><div class="ttname"><a href="xstruct_8c.html#aa4405d56659397e044b6d4fdda394dfa">xCreateIntField</a></div><div class="ttdeci">XField * xCreateIntField(const char *name, int value)</div><div class="ttdef"><b>Definition</b> xstruct.c:806</div></div>
<div class="ttc" id="axstruct_8c_html_ab7ac206d0ec3608a0872f09c7f7bc189"><div class="ttname"><a href="xstruct_8c.html#ab7ac206d0ec3608a0872f09c7f7bc189">xCreateDoubleField</a></div><div class="ttdeci">XField * xCreateDoubleField(const char *name, double value)</div><div class="ttdef"><b>Definition</b> xstruct.c:790</div></div>
<div class="ttc" id="axstruct_8c_html_ad2fa86a7d296f1efa6b41079bc2a6b65"><div class="ttname"><a href="xstruct_8c.html#ad2fa86a7d296f1efa6b41079bc2a6b65">xCreateBooleanField</a></div><div class="ttdeci">XField * xCreateBooleanField(const char *name, boolean value)</div><div class="ttdef"><b>Definition</b> xstruct.c:837</div></div>
</div><!-- fragment --><p>Under the hood, scalar values are a special case of arrays containing a single element. Scalars have dimension zero i.e., a shape defined by an empty integer array, e.g. <code>int shape[0]</code> in a corresponding <code><a class="el" href="structXField.html" title="An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...">XField</a></code> element.</p>
<p>In this way scalars are distinguished from true arrays containing just a single elements, which have dimensionality &lt;=1 and shapes e.g., <code>int shape[1] = {1}</code> or <code>int shape[2] = {1, 1}</code>. The difference, while subtle, becomes more obvious when serializing the array, e.g. to JSON. A scalar floating point value of 1.04, for example, will appear as <code>1.04</code> in JSON, whereas the 1D and 2D single-element arrays will be serialized as <code>{ 1.04 }</code> or <code>{{ 1.04 }}</code>, respectively.</p>
<p><a class="anchor" id="xchange-arrays"></a> </p>
<h3><a class="anchor" id="autotoc_md22"></a>
Arrays</h3>
<p>The <b>xchange</b> library supports array data types in one or more dimensions (up to 20 dimensions). For example, to create a field for 2&times;3&times;4 array of <code>double</code>s, you may have something along:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> data[2][3][4] = ...;           <span class="comment">// The native array in C</span></div>
<div class="line"><span class="keywordtype">int</span> sizes[] = { 2, 3, 4 };            <span class="comment">// An array containing the dimensions for xchange</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a field for the 3-dimensional array with the specified shape.</span></div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *f = <a class="code hl_function" href="xstruct_8c.html#a42e4e75cbf8f721ef4b251c692dcd7cb">xCreateField</a>(<span class="stringliteral">&quot;my-array&quot;</span>, <a class="code hl_define" href="xchange_8h.html#a849c7ccb02f63d8554323a889a3d8b4d">X_DOUBLE</a>, 3, sizes, data);</div>
<div class="ttc" id="axchange_8h_html_a849c7ccb02f63d8554323a889a3d8b4d"><div class="ttname"><a href="xchange_8h.html#a849c7ccb02f63d8554323a889a3d8b4d">X_DOUBLE</a></div><div class="ttdeci">#define X_DOUBLE</div><div class="ttdoc">double-precision (64) bit floating point XType</div><div class="ttdef"><b>Definition</b> xchange.h:95</div></div>
<div class="ttc" id="axstruct_8c_html_a42e4e75cbf8f721ef4b251c692dcd7cb"><div class="ttname"><a href="xstruct_8c.html#a42e4e75cbf8f721ef4b251c692dcd7cb">xCreateField</a></div><div class="ttdeci">XField * xCreateField(const char *name, XType type, int ndim, const int *sizes, const void *value)</div><div class="ttdef"><b>Definition</b> xstruct.c:663</div></div>
</div><!-- fragment --><p>Note, that there is no requirement that the native array has the same dimensionality as it's nominal format in the field. We could have declared <code>data</code> as a 1D array <code>double data[2 * 3 * 4] = ...</code>, or really any array (pointer) containing doubles with storage for at least 24 elements. It is the <code>sizes</code> array, along with the dimensionality, which together define the number of elements used from it, and the shape of the array for <b>xchange</b>.</p>
<p>Arrays of irregular shape or mixed element types can be represented by fields containing an array of <code><a class="el" href="structXField.html" title="An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...">XField</a></code> entries:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *row1, *row2, ...                 <span class="comment">// Heterogeneous entries, each wrapped in an `XField`</span></div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> data[N] = { *row1, *row2, ... };  <span class="comment">// The irregular / mixed-type array. </span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *f = <a class="code hl_function" href="xstruct_8c.html#a0b37b00634177189d5e717e3c84820e3">xCreateMixed1DField</a>(<span class="stringliteral">&quot;my_array&quot;</span>, N);</div>
<div class="ttc" id="axstruct_8c_html_a0b37b00634177189d5e717e3c84820e3"><div class="ttname"><a href="xstruct_8c.html#a0b37b00634177189d5e717e3c84820e3">xCreateMixed1DField</a></div><div class="ttdeci">XField * xCreateMixed1DField(const char *name, int size, XField *array)</div><div class="ttdef"><b>Definition</b> xstruct.c:77</div></div>
</div><!-- fragment --><p>Or, use <code><a class="el" href="xstruct_8c.html#a7bb186343d1ff6dab01cc39e233b9069">xCreateMixedArrayField()</a></code> to create a multi-dimensional array of heterogeneous elements the same way.</p>
<p><a class="anchor" id="xchange-creating-structure"></a> </p>
<h3><a class="anchor" id="autotoc_md23"></a>
Creating structure</h3>
<p>Structures should always be created by calling <code><a class="el" href="xstruct_8c.html#a12112584a34e07f9ef7b08f6ef1bc865">xCreateStruct()</a></code> (or else by an appropriate de-serialization function such as <code>xjsonParseAt()</code>, or as a copy via <code>xCopyStruct()</code>). Once the structure is no longer used it should be explicitly destroyed (freed) by calling <code><a class="el" href="xstruct_8c.html#afe3fda2f392bae11e136e8c0c90f086d">xDestroyStruct()</a></code>. Named substructures can be added to any structure with <code><a class="el" href="xstruct_8c.html#ad84cbb4639f2fbfb604b698a86caf944">xSetSubstruct()</a></code>, and named fields via <code><a class="el" href="xstruct_8c.html#ab1cb91bd6aa14c0dae9d24bfbe7b76f4">xSetField()</a></code>. That is the gist of it. So for example, the skeleton structure from the example above can be created programatically as:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structXStructure.html">XStructure</a> *s, *sys, *sub;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the top-level structure</span></div>
<div class="line">s = <a class="code hl_function" href="xstruct_8c.html#a12112584a34e07f9ef7b08f6ef1bc865">xCreateStruct</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create and add the &quot;system&quot; sub-structure</span></div>
<div class="line">sys = <a class="code hl_function" href="xstruct_8c.html#a12112584a34e07f9ef7b08f6ef1bc865">xCreateStruct</a>();</div>
<div class="line"><a class="code hl_function" href="xstruct_8c.html#ad84cbb4639f2fbfb604b698a86caf944">xSetSubstruct</a>(s, <span class="stringliteral">&quot;system&quot;</span>, sys);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create and add the &quot;subsystem&quot; sub-structure</span></div>
<div class="line">sub = <a class="code hl_function" href="xstruct_8c.html#a12112584a34e07f9ef7b08f6ef1bc865">xCreateStruct</a>();</div>
<div class="line"><a class="code hl_function" href="xstruct_8c.html#ad84cbb4639f2fbfb604b698a86caf944">xSetSubstruct</a>(sys, <span class="stringliteral">&quot;subsystem&quot;</span>, sub);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the &quot;property&quot; field in &quot;subsystem&quot;.</span></div>
<div class="line"><a class="code hl_function" href="xstruct_8c.html#ab1cb91bd6aa14c0dae9d24bfbe7b76f4">xSetField</a>(sub, <span class="stringliteral">&quot;property&quot;</span>, <a class="code hl_function" href="xstruct_8c.html#a9dc77bed0d8b738ba615019721a6a2b6">xCreateStringField</a>(<span class="stringliteral">&quot;some value here&quot;</span>));</div>
<div class="ttc" id="astructXStructure_html"><div class="ttname"><a href="structXStructure.html">XStructure</a></div><div class="ttdoc">SMA-X structure object, containing a linked-list of XField elements.</div><div class="ttdef"><b>Definition</b> xchange.h:196</div></div>
<div class="ttc" id="axstruct_8c_html_a12112584a34e07f9ef7b08f6ef1bc865"><div class="ttname"><a href="xstruct_8c.html#a12112584a34e07f9ef7b08f6ef1bc865">xCreateStruct</a></div><div class="ttdeci">XStructure * xCreateStruct()</div><div class="ttdef"><b>Definition</b> xstruct.c:28</div></div>
<div class="ttc" id="axstruct_8c_html_ab1cb91bd6aa14c0dae9d24bfbe7b76f4"><div class="ttname"><a href="xstruct_8c.html#ab1cb91bd6aa14c0dae9d24bfbe7b76f4">xSetField</a></div><div class="ttdeci">XField * xSetField(XStructure *s, XField *f)</div><div class="ttdef"><b>Definition</b> xstruct.c:1110</div></div>
<div class="ttc" id="axstruct_8c_html_ad84cbb4639f2fbfb604b698a86caf944"><div class="ttname"><a href="xstruct_8c.html#ad84cbb4639f2fbfb604b698a86caf944">xSetSubstruct</a></div><div class="ttdeci">XField * xSetSubstruct(XStructure *s, const char *name, XStructure *substruct)</div><div class="ttdef"><b>Definition</b> xstruct.c:965</div></div>
</div><!-- fragment --><p>and then eventually destroyed after use as:</p>
<div class="fragment"><div class="line"><span class="comment">// Free up all resources used by the structure &#39;s&#39;</span></div>
<div class="line"><a class="code hl_function" href="xstruct_8c.html#afe3fda2f392bae11e136e8c0c90f086d">xDestroyStruct</a>(s);</div>
<div class="ttc" id="axstruct_8c_html_afe3fda2f392bae11e136e8c0c90f086d"><div class="ttname"><a href="xstruct_8c.html#afe3fda2f392bae11e136e8c0c90f086d">xDestroyStruct</a></div><div class="ttdeci">void xDestroyStruct(XStructure *s)</div><div class="ttdef"><b>Definition</b> xstruct.c:1184</div></div>
</div><!-- fragment --><p><a class="anchor" id="xchange-aggregate-ids"></a> </p>
<h3><a class="anchor" id="autotoc_md24"></a>
Aggregate IDs</h3>
<p>Since the <code><a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a></code> data type can represent hierarchies of arbitrary depth, and named at every level of the hierarchy, we can uniquely identify any particular field, at any level, with an aggregate ID, which concatenates the field names each every level, top-down, with a separator. The convention of <b>xchange</b> is to use colon (':') as the separator. Consider an example structure (in JSON notation):</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;system&quot;: {</div>
<div class="line">    &quot;subsystem&quot;: {</div>
<div class="line">      &quot;property&quot;: &quot;some value here&quot;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Then, the leaf "property" entry can be 'addressed' with the aggregate ID of <code>system:subsystem:property</code> from the top level. The <code><a class="el" href="xstruct_8c.html#a2cbbd824406d862b2018e28a466ff318">xGetAggregateID()</a></code> function is provided to construct such aggregate IDs by gluing together a leading and trailing component.</p>
<p><a class="anchor" id="accessing-data"></a> </p>
<h3><a class="anchor" id="autotoc_md25"></a>
Accessing substructures and elements</h3>
<p>Once a structure is populated &ndash; either by having constructed it programatically, or e.g. by parsing a JSON definition of it from a string or file &ndash; you can access its content and/or modify it.</p>
<p>E.g., to retrieve the "property" field from the above example structure:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *f = <a class="code hl_function" href="xstruct_8c.html#a442f155b0c6549549737510ce42bb66d">xGetField</a>(s, <span class="stringliteral">&quot;system:subsystem:property&quot;</span>); </div>
<div class="ttc" id="axstruct_8c_html_a442f155b0c6549549737510ce42bb66d"><div class="ttname"><a href="xstruct_8c.html#a442f155b0c6549549737510ce42bb66d">xGetField</a></div><div class="ttdeci">XField * xGetField(const XStructure *s, const char *id)</div><div class="ttdef"><b>Definition</b> xstruct.c:284</div></div>
</div><!-- fragment --><p>or to retrieve the "subsystem" structure from within:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structXStructure.html">XStructure</a> *sub = <a class="code hl_function" href="xstruct_8c.html#a97a58e33c4730e272af459dfb7f016f9">xGetSubstruct</a>(s, <span class="stringliteral">&quot;system:subsystem&quot;</span>);</div>
<div class="ttc" id="axstruct_8c_html_a97a58e33c4730e272af459dfb7f016f9"><div class="ttname"><a href="xstruct_8c.html#a97a58e33c4730e272af459dfb7f016f9">xGetSubstruct</a></div><div class="ttdeci">XStructure * xGetSubstruct(const XStructure *s, const char *id)</div><div class="ttdef"><b>Definition</b> xstruct.c:625</div></div>
</div><!-- fragment --><p>Conversely you can set / update fields in a structure using <code><a class="el" href="xstruct_8c.html#ab1cb91bd6aa14c0dae9d24bfbe7b76f4">xSetField()</a></code> / <code><a class="el" href="xstruct_8c.html#ad84cbb4639f2fbfb604b698a86caf944">xSetSubstruct()</a></code>, e.g.:</p>
<div class="fragment"><div class="line">XStructrure *newsub = ...     <span class="comment">// The new substructure</span></div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *newfield = ...        <span class="comment">// A new field to set</span></div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *oldfield, *oldsub;    <span class="comment">// prior entries by the same field name/location (if any)</span></div>
<div class="line"> </div>
<div class="line">oldfield = <a class="code hl_function" href="xstruct_8c.html#ab1cb91bd6aa14c0dae9d24bfbe7b76f4">xSetField</a>(s, newfield);        <span class="comment">// Sets the a field in &#39;s&#39;</span></div>
<div class="line">oldsub = <a class="code hl_function" href="xstruct_8c.html#ad84cbb4639f2fbfb604b698a86caf944">xSetSubstruct</a>(s, <span class="stringliteral">&quot;field&quot;</span>, sub);  <span class="comment">// Set a substructure named &quot;bar&quot; in &#39;s&#39;</span></div>
</div><!-- fragment --><p>The above calls return the old values (if any) for the "foo" and "bar" field in the structure, e.g. so we may dispose of them if appropriate:</p>
<div class="fragment"><div class="line"><span class="comment">// Destroy the replaced fields if they are no longer needed.</span></div>
<div class="line"><a class="code hl_function" href="xstruct_8c.html#ae0ce99c867b11bd14971031eec8ba4ad">xDestroyField</a>(oldfield);</div>
<div class="line"><a class="code hl_function" href="xstruct_8c.html#ae0ce99c867b11bd14971031eec8ba4ad">xDestroyField</a>(oldsub);</div>
<div class="ttc" id="axstruct_8c_html_ae0ce99c867b11bd14971031eec8ba4ad"><div class="ttname"><a href="xstruct_8c.html#ae0ce99c867b11bd14971031eec8ba4ad">xDestroyField</a></div><div class="ttdeci">void xDestroyField(XField *f)</div><div class="ttdef"><b>Definition</b> xstruct.c:1251</div></div>
</div><!-- fragment --><p>You can also remove existing fields from structures using <code><a class="el" href="xstruct_8c.html#aec9f913cdb79d8653668a5d9bdda6ab1">xRemoveField()</a></code>, e.g.</p>
<div class="fragment"><div class="line"><span class="comment">// Remove and then destroy the field named &quot;blah&quot; in structure &#39;s&#39;.</span></div>
<div class="line"><a class="code hl_function" href="xstruct_8c.html#ae0ce99c867b11bd14971031eec8ba4ad">xDestroyField</a>(<a class="code hl_function" href="xstruct_8c.html#aec9f913cdb79d8653668a5d9bdda6ab1">xRemoveField</a>(s, <span class="stringliteral">&quot;blah&quot;</span>));</div>
<div class="ttc" id="axstruct_8c_html_aec9f913cdb79d8653668a5d9bdda6ab1"><div class="ttname"><a href="xstruct_8c.html#aec9f913cdb79d8653668a5d9bdda6ab1">xRemoveField</a></div><div class="ttdeci">XField * xRemoveField(XStructure *s, const char *name)</div><div class="ttdef"><b>Definition</b> xstruct.c:1012</div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md26"></a>
Large structures</h4>
<p>The normal <code><a class="el" href="xstruct_8c.html#a442f155b0c6549549737510ce42bb66d">xGetField()</a></code> and <code><a class="el" href="xstruct_8c.html#a97a58e33c4730e272af459dfb7f016f9">xGetSubstruct()</a></code> functions have computational costs that scale linearly with the number of direct fields in the structure. It is not much of an issue for structures that contain dozens of, or even a couple hundred, fields (per layer). For much larger structures, which have a fixed layout, there is an option for a potentially much more efficient hash-based lookup also. E.g. instead of <code><a class="el" href="xstruct_8c.html#a442f155b0c6549549737510ce42bb66d">xGetField()</a></code> you may use <code><a class="el" href="xlookup_8c.html#a5e3a316b7d0c5c40ed079f3df2d9fcc9">xLookupField()</a></code>:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structXStructure.html">XStructure</a> *s = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a lookup table for all fields of &#39;s&#39; and all its substructures.</span></div>
<div class="line">XLookupTable *l = xCreateLookupTable(s, <a class="code hl_define" href="xjson_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now use a hash-based lookup to locate the field by name</span></div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *f = <a class="code hl_function" href="xlookup_8c.html#a5e3a316b7d0c5c40ed079f3df2d9fcc9">xLookupField</a>(l, <span class="stringliteral">&quot;subsystem:property&quot;</span>);</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Once done with the lookup, destroy it.</span></div>
<div class="line">xDestroyLookup(l);</div>
<div class="ttc" id="axlookup_8c_html_a5e3a316b7d0c5c40ed079f3df2d9fcc9"><div class="ttname"><a href="xlookup_8c.html#a5e3a316b7d0c5c40ed079f3df2d9fcc9">xLookupField</a></div><div class="ttdeci">XField * xLookupField(const XLookupTable *tab, const char *id)</div><div class="ttdef"><b>Definition</b> xlookup.c:441</div></div>
</div><!-- fragment --><p>Note however, that preparing the lookup table has significant <em>O(N)</em> computational cost also. Therefore, a lookup table is practical only if you are going to use it repeatedly, many times over. As a rule of thumb, lookups may have the advantage if accessing fields in a structure by name hundreds of times, or more.</p>
<p>The same performance limitation also applies to building large structures, since the <code><a class="el" href="xstruct_8c.html#ab1cb91bd6aa14c0dae9d24bfbe7b76f4">xSetField()</a></code> and <code><a class="el" href="xstruct_8c.html#ad84cbb4639f2fbfb604b698a86caf944">xSetSubstruct()</a></code> functions iterate over the existing fields to check if a prior field by the same name was already present, and which should be removed before the new field is set (hence the time to build up a structure with <em>N</em> fields will scale as _O(N<sup>2</sup>)_ in general). The user may consider using <code><a class="el" href="xstruct_8c.html#ad6249db6da0a1294d5621cd9fd829f7a">xInsertField()</a></code> instead, which is much more scalable for building large structures, since it does not check for duplicates (hence scales as <em>O(N)</em> overall). However, <code><a class="el" href="xstruct_8c.html#ad6249db6da0a1294d5621cd9fd829f7a">xInsertField()</a></code> also makes the ordering of fields less intuitive, and it is left up to the caller to ensure that field names added this way are never duplicated. (Tip: if you used <code>InsertField()</code> consistently, you may call <code><a class="el" href="xstruct_8c.html#ad32d8a3f211a3b101142879ae31146ec">xReverseFieldOrder()</a></code> at the end, so the fields will appear in the same order in which they were inserted.)</p>
<h4><a class="anchor" id="autotoc_md27"></a>
Iterating over elements</h4>
<p>You can easily iterate over the elements also. This is one application where you may want to know the internal layout of <code><a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a></code>, namely that it contains a simple linked-list of <code><a class="el" href="structXField.html" title="An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...">XField</a></code> fields. One way to iterate over a structures elements is with a <code>for</code> loop, e.g.:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structXStructure.html">XStructure</a> *s = ...</div>
<div class="line">XField *f;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (f = s-&gt;<a class="code hl_variable" href="structXStructure.html#a501ae8af2201d9cfaa60e3af21ff58fc">firstField</a>; f != NULL; f = f-&gt;<a class="code hl_variable" href="structXField.html#ae1ebaf87eb62e6266b14908eee28e565">next</a>) {</div>
<div class="line">  <span class="comment">// Process each field &#39;f&#39; here...</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="astructXField_html_ae1ebaf87eb62e6266b14908eee28e565"><div class="ttname"><a href="structXField.html#ae1ebaf87eb62e6266b14908eee28e565">XField::next</a></div><div class="ttdeci">struct XField * next</div><div class="ttdoc">Pointer to the next linked element (if inside an XStructure).</div><div class="ttdef"><b>Definition</b> xchange.h:181</div></div>
<div class="ttc" id="astructXStructure_html_a501ae8af2201d9cfaa60e3af21ff58fc"><div class="ttname"><a href="structXStructure.html#a501ae8af2201d9cfaa60e3af21ff58fc">XStructure::firstField</a></div><div class="ttdeci">XField * firstField</div><div class="ttdoc">Pointer to the first field in this structure or NULL if the structure is empty.</div><div class="ttdef"><b>Definition</b> xchange.h:197</div></div>
</div><!-- fragment --><p><a class="anchor" id="sorting-fields"></a> </p>
<h3><a class="anchor" id="autotoc_md28"></a>
Sorting fields</h3>
<p>You can easily sort fields by name using <code><a class="el" href="xstruct_8c.html#a74d1f6b9b92ebe82353e75a3d7e9daae">xSortFieldsByName()</a></code>, or with using a custom comparator function with <code><a class="el" href="xstruct_8c.html#aa1d006a2788adeb0fc9b4799297a69ff">xSortFields()</a></code>. You can also reverse the order with <code><a class="el" href="xstruct_8c.html#ad32d8a3f211a3b101142879ae31146ec">xReverseFieldOrder()</a></code>. For example to sort fields in a structure (and its substructures) in descending alphabetical order:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structXStructure.html">XStructure</a> *s = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sort in by names in ascending order, recursively</span></div>
<div class="line">xSortFieldsByName(s, <a class="code hl_define" href="xjson_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reverse the order, recursively</span></div>
<div class="line"><a class="code hl_function" href="xstruct_8c.html#ad32d8a3f211a3b101142879ae31146ec">xReverseFieldOrder</a>(s, <a class="code hl_define" href="xjson_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);</div>
<div class="ttc" id="axstruct_8c_html_ad32d8a3f211a3b101142879ae31146ec"><div class="ttname"><a href="xstruct_8c.html#ad32d8a3f211a3b101142879ae31146ec">xReverseFieldOrder</a></div><div class="ttdeci">int xReverseFieldOrder(XStructure *s, boolean recursive)</div><div class="ttdef"><b>Definition</b> xstruct.c:1709</div></div>
</div><!-- fragment --><hr  />
<p><a class="anchor" id="json-interchange"></a> </p>
<h2><a class="anchor" id="autotoc_md30"></a>
JSON parser and emitter</h2>
<p>Once you have an <code><a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a></code> data object, you can easily convert it to JSON string representation, as:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="xjson_8h.html">xjson.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structXStructure.html">XStructure</a> *s = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Obtain a JSON string representation of the structure &#39;s&#39;.</span></div>
<div class="line">char *json = <a class="code hl_function" href="xjson_8c.html#a53128045970e973134867c96a6465abc">xjsonToString</a>(s);</div>
<div class="ttc" id="axjson_8c_html_a53128045970e973134867c96a6465abc"><div class="ttname"><a href="xjson_8c.html#a53128045970e973134867c96a6465abc">xjsonToString</a></div><div class="ttdeci">char * xjsonToString(const XStructure *s)</div><div class="ttdef"><b>Definition</b> xjson.c:134</div></div>
<div class="ttc" id="axjson_8h_html"><div class="ttname"><a href="xjson_8h.html">xjson.h</a></div></div>
</div><!-- fragment --><p>The above produces a proper JSON document. Or, you can do the reverse and create an <code><a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a></code> from its JSON representation, either from a string (a 0-terminated <code>char</code> array):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="xjson_8h.html">xjson.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> *tail;    <span class="comment">// for return parse position</span></div>
<div class="line"><a class="code hl_struct" href="structXStructure.html">XStructure</a> *s = <a class="code hl_function" href="xjson_8c.html#a5101534a5573eefbdbc584cb6bedfd8e">xjsonParseString</a>(json, &amp;tail);</div>
<div class="line"><span class="keywordflow">if</span> (s == NULL) {</div>
<div class="line">   <span class="comment">// Oops, there was some problem...</span></div>
<div class="line">}</div>
<div class="ttc" id="axjson_8c_html_a5101534a5573eefbdbc584cb6bedfd8e"><div class="ttname"><a href="xjson_8c.html#a5101534a5573eefbdbc584cb6bedfd8e">xjsonParseString</a></div><div class="ttdeci">XStructure * xjsonParseString(const char *str, char **tail)</div><div class="ttdef"><b>Definition</b> xjson.c:254</div></div>
</div><!-- fragment --><p>or parse it from a file, which contains a JSON definition of the structured data:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="xjson_8h.html">xjson.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structXStructure.html">XStructure</a> *s = <a class="code hl_function" href="xjson_8c.html#a9a9cad9405eeff3a088e5f809fa50529">xjsonParsePath</a>(<span class="stringliteral">&quot;my-data.json&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (s == NULL) {</div>
<div class="line">   <span class="comment">// Oops, there was some problem...</span></div>
<div class="line">}</div>
<div class="ttc" id="axjson_8c_html_a9a9cad9405eeff3a088e5f809fa50529"><div class="ttname"><a href="xjson_8c.html#a9a9cad9405eeff3a088e5f809fa50529">xjsonParsePath</a></div><div class="ttdeci">XStructure * xjsonParsePath(const char *path)</div><div class="ttdef"><b>Definition</b> xjson.c:320</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31"></a>
JSON fragments</h3>
<p>Alternatively, you can also create partial JSON fragments for individual fields, e.g.:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *f = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Obtain a JSON fragment for the field &#39;f&#39;.</span></div>
<div class="line">char *json = <a class="code hl_function" href="xjson_8c.html#a42101fa63cb1c6e265f317e9b8719d5f">xjsonFieldToString</a>(f);</div>
<div class="ttc" id="axjson_8c_html_a42101fa63cb1c6e265f317e9b8719d5f"><div class="ttname"><a href="xjson_8c.html#a42101fa63cb1c6e265f317e9b8719d5f">xjsonFieldToString</a></div><div class="ttdeci">char * xjsonFieldToString(const XField *f)</div><div class="ttdef"><b>Definition</b> xjson.c:232</div></div>
</div><!-- fragment --><p>For example, for a numerical array field with 4 elements the above might generate something like:</p>
<div class="fragment"><div class="line">&quot;my-numbers&quot;: [ 1, 2, 3, 4 ]</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md32"></a>
Escaped string representations</h3>
<p>You might just want to use JSON-style escaping for strings, and <code><a class="el" href="xjson_8c.html#a92336f3031a90784e8667aaa7ad07ca2">xjsonEscape()</a></code> / <code><a class="el" href="xjson_8c.html#aa94ae687d4c1775d35b03614ae2fcf62">xjsonUnescape()</a></code> can help with that too. Suppose you have a C string that you want to escape...</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *<span class="keywordtype">string</span> = <span class="stringliteral">&quot;\&quot;This has some\n\t special characters\&quot;&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Escape the special character, e.g. replace `\n` with `\` + `n` etc...</span></div>
<div class="line"><span class="keywordtype">char</span> *escaped = <a class="code hl_function" href="xjson_8c.html#a92336f3031a90784e8667aaa7ad07ca2">xjsonEscape</a>(<span class="keywordtype">string</span>);</div>
<div class="ttc" id="axjson_8c_html_a92336f3031a90784e8667aaa7ad07ca2"><div class="ttname"><a href="xjson_8c.html#a92336f3031a90784e8667aaa7ad07ca2">xjsonEscape</a></div><div class="ttdeci">char * xjsonEscape(const char *src, int maxLength)</div><div class="ttdef"><b>Definition</b> xjson.c:1393</div></div>
</div><!-- fragment --><p>If you print <code>string</code> to a file or the standard output, it will show up as 2 lines:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;This has some</span></div>
<div class="line"><span class="stringliteral">        special characters&quot;</span></div>
</div><!-- fragment --><p>But if you now print <code>escaped</code> instead, that will show up as:</p>
<div class="fragment"><div class="line">\<span class="stringliteral">&quot;This has some\n\t special characters\&quot;</span></div>
</div><!-- fragment --><p>And the reverse, suppose you read back the above line from an input, containing the escaped form, and want to reconstruct from it the original C string with the special characters in it:</p>
<div class="fragment"><div class="line"><span class="comment">// And reverse, from escaped form to ASCII (e.g. `\` + `n` --&gt; `\n`)</span></div>
<div class="line"><span class="keywordtype">char</span> *<span class="keywordtype">string</span> = <a class="code hl_function" href="xjson_8c.html#aa94ae687d4c1775d35b03614ae2fcf62">xjsonUnescape</a>(escaped);</div>
<div class="ttc" id="axjson_8c_html_aa94ae687d4c1775d35b03614ae2fcf62"><div class="ttname"><a href="xjson_8c.html#aa94ae687d4c1775d35b03614ae2fcf62">xjsonUnescape</a></div><div class="ttdeci">char * xjsonUnescape(const char *str)</div><div class="ttdef"><b>Definition</b> xjson.c:1428</div></div>
</div><!-- fragment --><hr  />
<p><a class="anchor" id="xchange-error-handling"></a> </p>
<h2><a class="anchor" id="autotoc_md34"></a>
Error handling</h2>
<p>The functions that can encounter an error will return either one of the error codes defined in <code><a class="el" href="xchange_8h.html">xchange.h</a></code>, or <code>NULL</code> pointers. String descriptions for the error codes can be produced by <code><a class="el" href="xchange_8c.html#acc701c734a3b95d356660ca5ee16a96a">xErrorDescription(int)</a></code>. For example,</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *text = ...</div>
<div class="line">int status = <a class="code hl_function" href="xchange_8c.html#a7e2e177c11fe7f44ca5ce11f316c0ad9">xParseDouble</a>(text, NULL);</div>
<div class="line"><span class="keywordflow">if</span> (status != <a class="code hl_define" href="xchange_8h.html#a7b2679c964ea5f2160380ed55654b873">X_SUCCESS</a>) {</div>
<div class="line">  <span class="comment">// Ooops, something went wrong...</span></div>
<div class="line">  fprintf(stderr, <span class="stringliteral">&quot;WARNING! %s&quot;</span>, <a class="code hl_function" href="xchange_8c.html#acc701c734a3b95d356660ca5ee16a96a">xErrorDescription</a>(status));</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="axchange_8c_html_a7e2e177c11fe7f44ca5ce11f316c0ad9"><div class="ttname"><a href="xchange_8c.html#a7e2e177c11fe7f44ca5ce11f316c0ad9">xParseDouble</a></div><div class="ttdeci">double xParseDouble(const char *str, char **tail)</div><div class="ttdef"><b>Definition</b> xchange.c:566</div></div>
<div class="ttc" id="axchange_8c_html_acc701c734a3b95d356660ca5ee16a96a"><div class="ttname"><a href="xchange_8c.html#acc701c734a3b95d356660ca5ee16a96a">xErrorDescription</a></div><div class="ttdeci">const char * xErrorDescription(int code)</div><div class="ttdef"><b>Definition</b> xchange.c:756</div></div>
<div class="ttc" id="axchange_8h_html_a7b2679c964ea5f2160380ed55654b873"><div class="ttname"><a href="xchange_8h.html#a7b2679c964ea5f2160380ed55654b873">X_SUCCESS</a></div><div class="ttdeci">#define X_SUCCESS</div><div class="ttdoc">hooray!</div><div class="ttdef"><b>Definition</b> xchange.h:61</div></div>
</div><!-- fragment --><p>The JSON parser can also sink its error messages to a designated file or stream, which can be set by <code><a class="el" href="xjson_8c.html#a23a7bd364a80bc2bab9ce917ed5f22ea">xjsonSetErrorStream(FILE *)</a></code>.</p>
<hr  />
<p><a class="anchor" id="xchange-debugging-support"></a> </p>
<h2><a class="anchor" id="autotoc_md36"></a>
Debugging support</h2>
<p>You can enable verbose output of the <b>xchange</b> library with <code><a class="el" href="xchange_8c.html#afbe85067ddbc92577cd00ac8f6e3026f">xSetVerbose(boolean)</a></code>. When enabled, it will produce status messages to <code>stderr</code>so you can follow what's going on. In addition (or alternatively), you can enable debug messages with <code><a class="el" href="xchange_8c.html#a6c1304b59a5882b2286e86c6837faead">xSetDebug(boolean)</a></code>. When enabled, all errors encountered by the library (such as invalid arguments passed) will be printed to <code>stderr</code>, including call traces, so you can walk back to see where the error may have originated from. (You can also enable debug messages by default by defining the <code>DEBUG</code> constant for the compiler, e.g. by adding <code>-DDEBUG</code> to <code>CFLAGS</code> prior to calling <code>make</code>).</p>
<p>For helping to debug your application, the <b>xchange</b> library provides two macros: <code><a class="el" href="xchange_8h.html#a1f038bf7ddb58819805cfc44162cb403" title="Use for generating verbose output.">xvprintf()</a></code> and <code><a class="el" href="xchange_8h.html#a2b0edfea798e9e08122f09dba5f189f8" title="Use for generating debug output.">xdprintf()</a></code>, for printing verbose and debug messages to <code>stderr</code>. Both work just like <code>printf()</code>, but they are conditional on verbosity being enabled via <code><a class="el" href="xchange_8c.html#afbe85067ddbc92577cd00ac8f6e3026f">xSetVerbose(boolean)</a></code> and <code><a class="el" href="xchange_8c.html#a6c1304b59a5882b2286e86c6837faead">xSetDebug(boolean)</a></code>, respectively. Applications using <b>xchange</b> may use these macros to produce their own verbose and/or debugging outputs conditional on the same global settings.</p>
<hr  />
<p><a class="anchor" id="xchange-future-plans"></a> </p>
<h2><a class="anchor" id="autotoc_md38"></a>
Future plans</h2>
<p>There are a number of ways this little library can evolve and grow in the not too distant future. Some of the obvious paths forward are:</p>
<ul>
<li>Add regression testing and code coverage tracking (high priority)</li>
<li>Add support for <a href="https://bsonspec.org/spec.html">BSON</a> &ndash; MongoDB's binary exchange format.</li>
<li>Add support for 128-bit floating point types (<code>X_FLOAT128</code>).</li>
</ul>
<p>If you have an idea for a must have feature, please let me (Attila) know. Pull requests, for new features or fixes to existing ones are especially welcome!</p>
<hr  />
<p><a class="anchor" id="xchange-release-schedule"></a> </p>
<h2><a class="anchor" id="autotoc_md40"></a>
Release schedule</h2>
<p>A predictable release schedule and process can help manage expectations and reduce stress on adopters and developers alike.</p>
<p>The <b>xchange</b> library will try to follow a quarterly release schedule. You may expect upcoming releases to be published around <b>February 1</b>, <b>May 1</b>, <b>August 1</b>, and/or <b>November 1</b> each year, on an as-needed basis. That means that if there are outstanding bugs, or new pull requests (PRs), you may expect a release that addresses these in the upcoming quarter. The dates are placeholders only, with no guarantee that a new release will actually be available every quarter. If nothing of note comes up, a potential release date may pass without a release being published.</p>
<p>New features are generally reserved for the feature releases (e.g. <b>1.x.0</b> version bumps), although they may also be rolled out in bug-fix releases as long as they do not affect the existing API &ndash; in line with the desire to keep bug-fix releases fully backwards compatible with their parent versions.</p>
<p>In the weeks and month(s) preceding releases one or more <em>release candidates</em> (e.g. <code>1.0.1-rc3</code>) will be published temporarily on GitHub, under <a href="https://github.com/Smithsonian/xchange/releases">Releases</a>, so that changes can be tested by adopters before the releases are finalized. Please use due diligence to test such release candidates with your code when they become available to avoid unexpected surprises when the finalized release is published. Release candidates are typically available for one week only before they are superseded either by another, or by the finalized release.</p>
<hr  />
<p> Copyright (C) 2025 Attila Kov√°cs </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
