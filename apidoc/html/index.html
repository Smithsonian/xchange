<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta charset="utf-8"/>
<meta name="description" content="Structured data exchange for C/C++"/>
<meta name="keywords" content="structured data, JSON, C, C++, C90, software library, open source"/>
<meta name="author" content="Attila Kovacs"/>
<meta name="copyright" content="(C)2024 Attila Kovacs" />
<meta name="robots" content="index,follow"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-D69CXTY2CJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-D69CXTY2CJ');
</script>
<link rel="shortcut icon" type="image/x-icon" href="/xchange/resources/favicon.ico" />
<link rel="icon" type="image/png" sizes="192x192" href="/xchange/resources/android-chrome-192x192.png" />
<link rel="icon" type="image/png" sizes="512x512" href="/xchange/resources/android-chrome-512x512.png" />
<link rel="apple-touch-icon" type="image/png" href="/xchange/resources/apple-touch-icon.png" />
<title>xchange: xchange</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="smithsonian-logo-55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">xchange<span id="projectnumber">&#160;v0.9</span>
   </div>
   <div id="projectbrief">Structured data exchange for C/C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">xchange </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README-orig"></a> Platform-agnostic data exchange framework for C/C++ with built-in JSON parser/emitter support.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Table of Contents</h2>
<ul>
<li><a class="el" href="index.html#introduction">Introduction</a></li>
<li><a class="el" href="index.html#building">Building</a></li>
<li><a class="el" href="index.html#structured-data">Structured data</a></li>
<li><a class="el" href="index.html#json-interchange">JSON parser and emitter</a></li>
<li><a class="el" href="index.html#error-handling">Error handling</a></li>
<li><a class="el" href="index.html#debugging-support">Debugging support</a></li>
<li><a class="el" href="index.html#future-plans">Future plans</a></li>
</ul>
<hr  />
<p><a class="anchor" id="introduction"></a> </p>
<h2><a class="anchor" id="autotoc_md5"></a>
Introduction</h2>
<p>The <b>xchange</b> library provides a framework for platform independent data exchange for structured data in C/C++, and includes a JSON parser and emitter.</p>
<p>While there are many excellent libraries out there that offer such capabilities for C++ and/or other object-oriented languages, support for structured data exchange is notably rare for standard C. The <b>xchange</b> library aims to fill that niche, by providing a data exchange framework with a C90-compatible API that supports the interchange of arbitrary structured data between different platforms and different serialization formats with ease. The <b>xchange</b> library also provides support for JSON formatting and parsing using the C90 standard out of the box. All that in a light-weight and fast package.</p>
<p>The <b>xchange</b> library was created, and is maintained, by Attila Kov√°cs at the Center for Astrophysics | Harvard &amp; Smithsonian, and it is available through the <a href="https://github.com/Smithsonian/xchange">Smithsonian/xchange</a> repository on GitHub.</p>
<p>There are no official releases of <b>xchange</b> yet. An initial 1.0.0 release is expected in late 2024. Before then the API may undergo slight changes and tweaks. Use the repository as is at your own risk for now.</p>
<p>Some related links:</p>
<ul>
<li><a href="https://smithsonian.github.io/xchange/apidoc/html/files.html">API documentation</a></li>
<li><a href="https://smithsonian.github.io/xchange">Project page</a> on github.io</li>
</ul>
<hr  />
<p><a class="anchor" id="building"></a> </p>
<h2><a class="anchor" id="autotoc_md7"></a>
Building</h2>
<p>The <b>xchange</b> library can be built either as a shared (<code>libxchange.so[.1]</code>) and as a static (<code>libxchange.a</code>) library, depending on what suits your needs best.</p>
<p>You can configure the build, either by editing <code>config.mk</code> or else by defining the relevant environment variables prior to invoking <code>make</code>. The following build variables can be configured:</p>
<ul>
<li><code>CC</code>: The C compiler to use (default: <code>gcc</code>).</li>
<li><code>CPPFLAGS</code>: C pre-processor flags, such as externally defined compiler constants.</li>
<li><code>CFLAGS</code>: Flags to pass onto the C compiler (default: <code>-Os -Wall</code>). Note, <code>-Iinclude</code> will be added automatically.</li>
<li><code>LDFLAGS</code>: Linker flags (default is <code>-lm</code>).</li>
<li><code>BUILD_MODE</code>: You can set it to <code>debug</code> to enable debugging features: it will initialize the global <code>xDebug</code> variable to <code>TRUE</code>) and add <code>-g</code> to <code>CFLAGS</code>.</li>
<li><code>CHECKEXTRA</code>: Extra options to pass to <code>cppcheck</code> for the <code>make check</code> target</li>
</ul>
<p>After configuring, you can simply run <code>make</code>, which will build the <code>shared</code> (<code>lib/libxchange.so[.1]</code>) and <code>static</code> (<code>lib/libxchange.a</code>) libraries, local HTML documentation (provided <code>doxygen</code> is available), and performs static analysis via the <code>check</code> target. Or, you may build just the components you are interested in, by specifying the desired <code>make</code> target(s). (You can use <code>make help</code> to get a summary of the available <code>make</code> targets).</p>
<hr  />
<p><a class="anchor" id="structured-data"></a> </p>
<h2><a class="anchor" id="autotoc_md9"></a>
Structured data</h2>
<ul>
<li><a class="el" href="index.html#data-types">Basic data types</a></li>
<li><a class="el" href="index.html#scalars">Scalars</a></li>
<li><a class="el" href="index.html#arrays">Arrays</a></li>
<li><a class="el" href="index.html#creating-structure">Creating structure</a></li>
<li><a class="el" href="index.html#aggregate-ids">Aggregate IDs</a></li>
<li><a class="el" href="index.html#accessing-data">Accessing substructures and elements</a></li>
<li><a class="el" href="index.html#sorting-fields">Sorting fields</a></li>
</ul>
<p>The <b>xchange</b> library defines the <code><a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a></code> type to represent structured data. It is defined in <code><a class="el" href="xchange_8h.html">xchange.h</a></code>, but as a user you really do not need to know much about its layout, as you probably want to avoid low-level direct access to its elements. Rather, you should be using the functions of the <b>xchange</b> API to create, modify, or access data within.</p>
<p>Under the hood, the <code><a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a></code> contains a linked list of fields, each an <code><a class="el" href="structXField.html" title="An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...">XField</a></code> data type to represent a single element, or an array of elements, of the above mentioned types, including embedded <code>Xstructure</code>s. In this way, an <code>Xstructure</code> can easily represent a multi-level hierarchy of a composite data object. Each <code><a class="el" href="structXField.html" title="An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...">XField</a></code> has a name/ID, an associated data type, a dimensionality, a shape (for multidimensional arrays).</p>
<p><a class="anchor" id="data-types"></a> </p>
<h3><a class="anchor" id="autotoc_md10"></a>
Basic data types</h3>
<ul>
<li><a class="el" href="index.html#strings">Strings</a></li>
</ul>
<p>The <b>xchange</b> library supports most basic (primitive) data types used across programming languages. The table below shows the (<code>XType</code>) types recognised by the library and their C equivalents etc.:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>xchange</b> type   </th><th class="markdownTableHeadNone">C type   </th><th class="markdownTableHeadNone">Comment / example    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>X_BOOLEAN</code>   </td><td class="markdownTableBodyNone"><code>boolean</code><sup>*</sup>   </td><td class="markdownTableBodyNone">'<code>true</code>' or '<code>false</code>'    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>X_BYTE</code>   </td><td class="markdownTableBodyNone"><code>char</code> or <code>int8_t</code>   </td><td class="markdownTableBodyNone">'<code>-128</code>' to '<code>127</code>'    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>X_BYTE_HEX</code>   </td><td class="markdownTableBodyNone"><code>char</code> or <code>[u]int8_t</code>   </td><td class="markdownTableBodyNone">'<code>0x0</code>' to '<code>0xff</code>' (hexadeximal representation)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>X_SHORT</code>   </td><td class="markdownTableBodyNone"><code>short</code> or <code>int16_t</code>   </td><td class="markdownTableBodyNone">'<code>-32768</code>' to '<code>32767</code>'    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>X_SHORT_HEX</code>   </td><td class="markdownTableBodyNone"><code>short</code> or <code>[u]int16_t</code>   </td><td class="markdownTableBodyNone">'<code>0x0</code>' to '<code>0xffff</code>' (hexadeximal representation)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>X_INT</code>   </td><td class="markdownTableBodyNone"><code>int32_t</code>   </td><td class="markdownTableBodyNone">'<code>-2,147,483,648</code>' to '<code>2,147,483,647</code>'    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>X_INT_HEX</code>   </td><td class="markdownTableBodyNone"><code>[u]int32_t</code>   </td><td class="markdownTableBodyNone">'<code>0x0</code>' to '<code>0xffffffff</code>' (hexadeximal representation)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>X_LONG</code>   </td><td class="markdownTableBodyNone"><code>long long</code> or <code>int64_t</code>   </td><td class="markdownTableBodyNone">'<code>-9,223,372,036,854,775,808</code>' to '<code>9,223,372,036,854,775,807</code>'    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>X_LONG_HEX</code>   </td><td class="markdownTableBodyNone"><code>[u]int64_t</code>   </td><td class="markdownTableBodyNone">'<code>0x0</code>' to '<code>0xffffffffffffffff</code>' (hex. representation)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>X_FLOAT</code>   </td><td class="markdownTableBodyNone"><code>float</code>   </td><td class="markdownTableBodyNone"><code>1</code>, <code>1.0</code>, <code>-1.234567e-33</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>X_DOUBLE</code>   </td><td class="markdownTableBodyNone"><code>double</code>   </td><td class="markdownTableBodyNone"><code>1</code>, <code>1.0</code>, <code>-1.2345678901234567e-111</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>X_STRING</code>   </td><td class="markdownTableBodyNone"><code>char *</code>   </td><td class="markdownTableBodyNone"><code>Hello world!</code>, <code>line1\nline2\n</code> (0-terminated)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="xchange_8h.html#a76d723969626d4e25235eb24533e3e3a" title="A fixed-size sequence of &#39;length&#39; bytes.">X_CHARS(n)</a></code>   </td><td class="markdownTableBodyNone"><code>char[n]</code>   </td><td class="markdownTableBodyNone">Fixed-length character arrays (also w/o termination)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>X_STRUCT</code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a></code>   </td><td class="markdownTableBodyNone">substructure   </td></tr>
</table>
<p><sup>*</sup> The <code>boolean</code> type is defined in <code><a class="el" href="xchange_8h.html">xchange.h</a></code>.</p>
<p>The <code>[...]_HEX</code> types are meaningful only for ASCII representations, and are otherwise equivalent to the corresponding regular integer-types of the same width. They are meant only as a way to explicitly define whether or not an integer value is to be represented in hexadecimal format rather than the default decimal format.</p>
<p><a class="anchor" id="strings"></a> </p>
<h4><a class="anchor" id="autotoc_md11"></a>
Strings</h4>
<p>Strings can be either fixed-length or else a 0-terminated sequence of ASCII characters. At its basic level the library does not impose any restriction of what ASCII characters may be used. However, we recommend that users stick to the JSON convention, and represent special characters in escaped form. E.g. carriagle return (<code>0xd</code>) as <code>\</code> followed by <code>n</code>, tabs as <code>\</code> followed by <code>t</code>, etc. As a result a single backslash should also be escaped as two consecutive <code>\</code> characters. You might use <code><a class="el" href="xjson_8c.html#aad83ebcc397046a875040dfc2297d892">xjsonEscapeString()</a></code> or <code><a class="el" href="xjson_8c.html#ae11aed18561818c2e39a5709a8e3374d">xjsonUnescapeString()</a></code> to perform the conversion to/from standard JSON representation.</p>
<p>Fixed-length strings of up to <em>n</em> characters are represented internally as the <code>XCHAR(n)</code> type. They may be 0-terminated as appropriate, or else represent exactly <em>n</em> ASCII characters without explicit termination. Alternatively, the <code>X_STRING</code> type represents ASCII strings of arbitrary length, up to the 0-termination character.</p>
<p><a class="anchor" id="scalars"></a> </p>
<h3><a class="anchor" id="autotoc_md12"></a>
Scalar values</h3>
<p>You can create scalar fields easily, e.g.:</p>
<div class="fragment"><div class="line"><span class="comment">// Create &quot;is_ok&quot; as a boolean field with TRUE</span></div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *fb = <a class="code hl_function" href="xstruct_8c.html#ad2fa86a7d296f1efa6b41079bc2a6b65">xCreateBooleanField</a>(<span class="stringliteral">&quot;is_ok&quot;</span>, <a class="code hl_define" href="xjson_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create &quot;serial-number&quot; field with an integer value</span></div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *fi = <a class="code hl_function" href="xstruct_8c.html#aa4405d56659397e044b6d4fdda394dfa">xCreateIntField</a>(<span class="stringliteral">&quot;serial-number&quot;</span>, 1001);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create &quot;my measurement&quot; as a double-precision value 1.04</span></div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *fd = <a class="code hl_function" href="xstruct_8c.html#ab7ac206d0ec3608a0872f09c7f7bc189">xCreateDoubleField</a>(<span class="stringliteral">&quot;my-measurement&quot;</span>, 1.04);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create &quot;description&quot; as a string</span></div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *fs = <a class="code hl_function" href="xstruct_8c.html#a9dc77bed0d8b738ba615019721a6a2b6">xCreateStringField</a>(<span class="stringliteral">&quot;description&quot;</span>, <span class="stringliteral">&quot;blah-blah-blah&quot;</span>);</div>
<div class="ttc" id="astructXField_html"><div class="ttname"><a href="structXField.html">XField</a></div><div class="ttdoc">An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...</div><div class="ttdef"><b>Definition</b> xchange.h:133</div></div>
<div class="ttc" id="axjson_8c_html_aa8cecfc5c5c054d2875c03e77b7be15d"><div class="ttname"><a href="xjson_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a></div><div class="ttdeci">#define TRUE</div><div class="ttdoc">Boolean 'true' in case it isn't already defined.</div><div class="ttdef"><b>Definition</b> xjson.c:22</div></div>
<div class="ttc" id="axstruct_8c_html_a9dc77bed0d8b738ba615019721a6a2b6"><div class="ttname"><a href="xstruct_8c.html#a9dc77bed0d8b738ba615019721a6a2b6">xCreateStringField</a></div><div class="ttdeci">XField * xCreateStringField(const char *name, const char *value)</div><div class="ttdef"><b>Definition</b> xstruct.c:382</div></div>
<div class="ttc" id="axstruct_8c_html_aa4405d56659397e044b6d4fdda394dfa"><div class="ttname"><a href="xstruct_8c.html#aa4405d56659397e044b6d4fdda394dfa">xCreateIntField</a></div><div class="ttdeci">XField * xCreateIntField(const char *name, int value)</div><div class="ttdef"><b>Definition</b> xstruct.c:342</div></div>
<div class="ttc" id="axstruct_8c_html_ab7ac206d0ec3608a0872f09c7f7bc189"><div class="ttname"><a href="xstruct_8c.html#ab7ac206d0ec3608a0872f09c7f7bc189">xCreateDoubleField</a></div><div class="ttdeci">XField * xCreateDoubleField(const char *name, double value)</div><div class="ttdef"><b>Definition</b> xstruct.c:328</div></div>
<div class="ttc" id="axstruct_8c_html_ad2fa86a7d296f1efa6b41079bc2a6b65"><div class="ttname"><a href="xstruct_8c.html#ad2fa86a7d296f1efa6b41079bc2a6b65">xCreateBooleanField</a></div><div class="ttdeci">XField * xCreateBooleanField(const char *name, boolean value)</div><div class="ttdef"><b>Definition</b> xstruct.c:369</div></div>
</div><!-- fragment --><p>Under the hood, scalar values are a special case of arrays containing a single element. Scalars have dimension zero i.e., a shape defined by an empty integer array, e.g. <code>int shape[0]</code> in a corresponding <code><a class="el" href="structXField.html" title="An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...">XField</a></code> element.</p>
<p>In this way scalars are distinsguished from true arrays containing just a single elements, which have dimensionality &lt;=1 and shapes e.g., <code>int shape[1] = {1}</code> or <code>shape[2] = {1, 1}</code>. The difference, while subtle, becomes more obvious when serializing the array, e.g. to JSON. A scalar floating point value of 1.04, for example, will appear as <code>1.04</code> in JSON, whereas the 1D and 2D single-element arrays will be serialized as <code>{ 1.04 }</code> or <code>{{ 1.04 }}</code>, respectively.</p>
<p><a class="anchor" id="arrays"></a> </p>
<h3><a class="anchor" id="autotoc_md13"></a>
Arrays</h3>
<p>The <b>xchange</b> library supports array data types in one or more dimensions (up to 20 dimensions). For example, to create a field for 2&times;3&times;4 array of <code>double</code>s, you may have something along:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> data[2][3][4] = ...;       <span class="comment">// The native array in C</span></div>
<div class="line"><span class="keywordtype">int</span> sizes[] = { 2, 3, 4 };        <span class="comment">// An array containing the dimensions for xchange</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a field for the 3-dimensional array with the specified shape.</span></div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *f = <a class="code hl_function" href="xstruct_8c.html#a42e4e75cbf8f721ef4b251c692dcd7cb">xCreateField</a>(<span class="stringliteral">&quot;my-array&quot;</span>, <a class="code hl_define" href="xchange_8h.html#a849c7ccb02f63d8554323a889a3d8b4d">X_DOUBLE</a>, 3, sizes, data);</div>
<div class="ttc" id="axchange_8h_html_a849c7ccb02f63d8554323a889a3d8b4d"><div class="ttname"><a href="xchange_8h.html#a849c7ccb02f63d8554323a889a3d8b4d">X_DOUBLE</a></div><div class="ttdeci">#define X_DOUBLE</div><div class="ttdoc">double-precision (64) bit floating point XType</div><div class="ttdef"><b>Definition</b> xchange.h:96</div></div>
<div class="ttc" id="axstruct_8c_html_a42e4e75cbf8f721ef4b251c692dcd7cb"><div class="ttname"><a href="xstruct_8c.html#a42e4e75cbf8f721ef4b251c692dcd7cb">xCreateField</a></div><div class="ttdeci">XField * xCreateField(const char *name, XType type, int ndim, const int *sizes, const void *value)</div><div class="ttdef"><b>Definition</b> xstruct.c:229</div></div>
</div><!-- fragment --><p>Note, that there is no requirement that the native array has the same dimensionality as it's nominal format in the field. We could have declared <code>data</code> as a 1D array <code>double data[2 * 3 * 4] = ...</code>, or really any array (pointer) containing doubles with storage for at least 24 elements. It is the <code>sizes</code> array, along with the dimensionality, which together define the number of elements used from it, and the shape of the array for <b>xchange</b>.</p>
<p><a class="anchor" id="creating-structure"></a> </p>
<h3><a class="anchor" id="autotoc_md14"></a>
Creating structure</h3>
<p>Structures should always be created by calling <code><a class="el" href="xstruct_8c.html#ab551d2db420303b4408064a66bbe3f1c">xCreateStruct()</a></code> (or else by an appropriate de-serialization function such as <code><a class="el" href="xjson_8c.html#af180900a4afeef713a3fdaeb77a9cba3">xjsonParseAt()</a></code>, or as a copy via <code>xCopyStruct()</code>). Once the structure is no longer used it should be explicitly destroyed (freed) by calling <code><a class="el" href="xstruct_8c.html#a2e12d0147219f85a6ec012d7f475fe21">xDestroyStruct()</a></code>. Named substructures can be added to any structure with <code><a class="el" href="xstruct_8c.html#ad84cbb4639f2fbfb604b698a86caf944">xSetSubstruct()</a></code>, and named fields via <code><a class="el" href="xstruct_8c.html#ab1cb91bd6aa14c0dae9d24bfbe7b76f4">xSetField()</a></code>. That is the gist of it. So for example, the skeleton structure from the example above can be created programatically as:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structXStructure.html">XStructure</a> *s, *sys, *sub;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the top-level structure</span></div>
<div class="line">s = <a class="code hl_function" href="xstruct_8c.html#ab551d2db420303b4408064a66bbe3f1c">xCreateStruct</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create and add the &quot;system&quot; sub-structure</span></div>
<div class="line">sys = <a class="code hl_function" href="xstruct_8c.html#ab551d2db420303b4408064a66bbe3f1c">xCreateStruct</a>();</div>
<div class="line"><a class="code hl_function" href="xstruct_8c.html#ad84cbb4639f2fbfb604b698a86caf944">xSetSubstruct</a>(s, <span class="stringliteral">&quot;system&quot;</span>, sys);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create and add the &quot;subsystem&quot; sub-structure</span></div>
<div class="line">sub = <a class="code hl_function" href="xstruct_8c.html#ab551d2db420303b4408064a66bbe3f1c">xCreateStruct</a>();</div>
<div class="line"><a class="code hl_function" href="xstruct_8c.html#ad84cbb4639f2fbfb604b698a86caf944">xSetSubstruct</a>(sys, <span class="stringliteral">&quot;subsystem&quot;</span>, sub);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the &quot;property&quot; field in &quot;subsystem&quot;.</span></div>
<div class="line"><a class="code hl_function" href="xstruct_8c.html#ab1cb91bd6aa14c0dae9d24bfbe7b76f4">xSetField</a>(sub, <span class="stringliteral">&quot;property&quot;</span>, <a class="code hl_function" href="xstruct_8c.html#a9dc77bed0d8b738ba615019721a6a2b6">xCreateStringField</a>(<span class="stringliteral">&quot;some value here&quot;</span>));</div>
<div class="ttc" id="astructXStructure_html"><div class="ttname"><a href="structXStructure.html">XStructure</a></div><div class="ttdoc">SMA-X structure object, containing a linked-list of XField elements.</div><div class="ttdef"><b>Definition</b> xchange.h:156</div></div>
<div class="ttc" id="axstruct_8c_html_ab1cb91bd6aa14c0dae9d24bfbe7b76f4"><div class="ttname"><a href="xstruct_8c.html#ab1cb91bd6aa14c0dae9d24bfbe7b76f4">xSetField</a></div><div class="ttdeci">XField * xSetField(XStructure *s, XField *f)</div><div class="ttdef"><b>Definition</b> xstruct.c:579</div></div>
<div class="ttc" id="axstruct_8c_html_ab551d2db420303b4408064a66bbe3f1c"><div class="ttname"><a href="xstruct_8c.html#ab551d2db420303b4408064a66bbe3f1c">xCreateStruct</a></div><div class="ttdeci">__inline__ XStructure * xCreateStruct()</div><div class="ttdef"><b>Definition</b> xstruct.c:27</div></div>
<div class="ttc" id="axstruct_8c_html_ad84cbb4639f2fbfb604b698a86caf944"><div class="ttname"><a href="xstruct_8c.html#ad84cbb4639f2fbfb604b698a86caf944">xSetSubstruct</a></div><div class="ttdeci">XField * xSetSubstruct(XStructure *s, const char *name, XStructure *substruct)</div><div class="ttdef"><b>Definition</b> xstruct.c:435</div></div>
</div><!-- fragment --><p>and then eventually destroyed after use as:</p>
<div class="fragment"><div class="line"><span class="comment">// Free up all resources used by the structure &#39;s&#39;</span></div>
<div class="line"><a class="code hl_function" href="xstruct_8c.html#a2e12d0147219f85a6ec012d7f475fe21">xDestroyStruct</a>(s);</div>
<div class="ttc" id="axstruct_8c_html_a2e12d0147219f85a6ec012d7f475fe21"><div class="ttname"><a href="xstruct_8c.html#a2e12d0147219f85a6ec012d7f475fe21">xDestroyStruct</a></div><div class="ttdeci">__inline__ void xDestroyStruct(XStructure *s)</div><div class="ttdef"><b>Definition</b> xstruct.c:651</div></div>
</div><!-- fragment --><p><a class="anchor" id="aggregate-ids"></a> </p>
<h3><a class="anchor" id="autotoc_md15"></a>
Aggregate IDs</h3>
<p>Since the <code><a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a></code> data type can represent hierarchies of arbitrary depth, and named at every level of the hieratchy, we can uniquely identify any particular field, at any level, with an aggregate ID, which concatenates the field names eatch every level, top-down, with a separator. The convention of <b>xchange</b> is to use colon (':') as the separator. Consider an example structure (in JSON notation):</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  ...</div>
<div class="line">  system = {</div>
<div class="line">    ...</div>
<div class="line">    subsystem = {</div>
<div class="line">      ...</div>
<div class="line">      property = &quot;some value here&quot;;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Then, the leaf "properly" entry can be 'addressed' with the aggregate ID of <code>system:subsystem:property</code> from the top level. The <code><a class="el" href="xstruct_8c.html#a2cbbd824406d862b2018e28a466ff318">xGetAggregateID()</a></code> function is provided to construct such aggregate IDs by gluing together a leading and trailing component.</p>
<p><a class="anchor" id="accessing-data"></a> </p>
<h3><a class="anchor" id="autotoc_md16"></a>
Accessing substructures and elements</h3>
<p>Once a structure is populated &ndash; either by having constructed it programatically, or e.g. by parsing a JSON definition of it from a string or file &ndash; you can access its content and/or modify it.</p>
<p>E.g., to retrieve the "property" field from the above example structure:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *f = <a class="code hl_function" href="xstruct_8c.html#a442f155b0c6549549737510ce42bb66d">xGetField</a>(s, <span class="stringliteral">&quot;system:subsystem:property&quot;</span>); </div>
<div class="ttc" id="axstruct_8c_html_a442f155b0c6549549737510ce42bb66d"><div class="ttname"><a href="xstruct_8c.html#a442f155b0c6549549737510ce42bb66d">xGetField</a></div><div class="ttdeci">XField * xGetField(const XStructure *s, const char *id)</div><div class="ttdef"><b>Definition</b> xstruct.c:178</div></div>
</div><!-- fragment --><p>or to retrieve the "subsystem" structure from within:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structXStructure.html">XStructure</a> *sub = <a class="code hl_function" href="xstruct_8c.html#a97a58e33c4730e272af459dfb7f016f9">xGetSubstruct</a>(s, <span class="stringliteral">&quot;system:subsystem&quot;</span>);</div>
<div class="ttc" id="axstruct_8c_html_a97a58e33c4730e272af459dfb7f016f9"><div class="ttname"><a href="xstruct_8c.html#a97a58e33c4730e272af459dfb7f016f9">xGetSubstruct</a></div><div class="ttdeci">XStructure * xGetSubstruct(const XStructure *s, const char *id)</div><div class="ttdef"><b>Definition</b> xstruct.c:206</div></div>
</div><!-- fragment --><p>Conversely you can set / update fields in a structure using <code><a class="el" href="xstruct_8c.html#ab1cb91bd6aa14c0dae9d24bfbe7b76f4">xSetField()</a></code> / <code><a class="el" href="xstruct_8c.html#ad84cbb4639f2fbfb604b698a86caf944">xSetSubstruct()</a></code>, e.g.:</p>
<div class="fragment"><div class="line">XStructrure *newsub = ...     <span class="comment">// The new substructure</span></div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *newfield = ...        <span class="comment">// A new field to set</span></div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *oldfield, *oldsub;    <span class="comment">// prior entries by the same field name/location (if any)</span></div>
<div class="line"> </div>
<div class="line">oldfield = <a class="code hl_function" href="xstruct_8c.html#ab1cb91bd6aa14c0dae9d24bfbe7b76f4">xSetField</a>(s, newfield);        <span class="comment">// Sets the a field in &#39;s&#39;</span></div>
<div class="line">oldsub = <a class="code hl_function" href="xstruct_8c.html#ad84cbb4639f2fbfb604b698a86caf944">xSetSubstruct</a>(s, <span class="stringliteral">&quot;field&quot;</span>, sub);  <span class="comment">// Set a substructure named &quot;bar&quot; in &#39;s&#39;</span></div>
</div><!-- fragment --><p>The above calls return the old values (if any) for the "foo" and "bar" field in the structure, e.g. so we may dispose of them if appropriate:</p>
<div class="fragment"><div class="line"><span class="comment">// Destroy the replaced fields if they are no longer needed.</span></div>
<div class="line"><a class="code hl_function" href="xstruct_8c.html#ae0ce99c867b11bd14971031eec8ba4ad">xDestroyField</a>(oldfield);</div>
<div class="line"><a class="code hl_function" href="xstruct_8c.html#ae0ce99c867b11bd14971031eec8ba4ad">xDestroyField</a>(oldsub);</div>
<div class="ttc" id="axstruct_8c_html_ae0ce99c867b11bd14971031eec8ba4ad"><div class="ttname"><a href="xstruct_8c.html#ae0ce99c867b11bd14971031eec8ba4ad">xDestroyField</a></div><div class="ttdeci">void xDestroyField(XField *f)</div><div class="ttdef"><b>Definition</b> xstruct.c:663</div></div>
</div><!-- fragment --><p>You can also remove existing fields from structures using <code><a class="el" href="xstruct_8c.html#aec9f913cdb79d8653668a5d9bdda6ab1">xRemoveField()</a></code>, e.g.</p>
<div class="fragment"><div class="line"><span class="comment">// Remove and then destroy the field named &quot;blah&quot; in structure &#39;s&#39;.</span></div>
<div class="line"><a class="code hl_function" href="xstruct_8c.html#ae0ce99c867b11bd14971031eec8ba4ad">xDestroyField</a>(<a class="code hl_function" href="xstruct_8c.html#aec9f913cdb79d8653668a5d9bdda6ab1">xRemoveField</a>(s, <span class="stringliteral">&quot;blah&quot;</span>));</div>
<div class="ttc" id="axstruct_8c_html_aec9f913cdb79d8653668a5d9bdda6ab1"><div class="ttname"><a href="xstruct_8c.html#aec9f913cdb79d8653668a5d9bdda6ab1">xRemoveField</a></div><div class="ttdeci">XField * xRemoveField(XStructure *s, const char *name)</div><div class="ttdef"><b>Definition</b> xstruct.c:482</div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md17"></a>
Large structures</h4>
<p>The normal <code><a class="el" href="xstruct_8c.html#a442f155b0c6549549737510ce42bb66d">xGetField()</a></code> and <code><a class="el" href="xstruct_8c.html#a97a58e33c4730e272af459dfb7f016f9">xGetSubstruct()</a></code> functions have computational costs that scale linearly with the number of direct fields in the structure. It is not much of an issue for structures that contain dozens of, or even a couple hundred, fields (per layer). For much larger structures, which have a fixed layout, there is an option for a potentially much more efficient hash-based lookup also. E.g. instead of <code><a class="el" href="xstruct_8c.html#a442f155b0c6549549737510ce42bb66d">xGetField()</a></code> you may use <code><a class="el" href="xlookup_8c.html#a5e3a316b7d0c5c40ed079f3df2d9fcc9">xLookupField()</a></code>:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structXStructure.html">XStructure</a> *s = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a lookup table for all fields of &#39;s&#39; and all its substructures.</span></div>
<div class="line">XLookupTable *l = xCreateLookupTable(s, <a class="code hl_define" href="xjson_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now use a hash-based lookup to locate the field by name</span></div>
<div class="line"><a class="code hl_struct" href="structXField.html">XField</a> *f = <a class="code hl_function" href="xlookup_8c.html#a5e3a316b7d0c5c40ed079f3df2d9fcc9">xLookupField</a>(l, <span class="stringliteral">&quot;subsystem:property&quot;</span>);</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Once done with the lookup, destroy it.</span></div>
<div class="line">xDestroyLookup(l);</div>
<div class="ttc" id="axlookup_8c_html_a5e3a316b7d0c5c40ed079f3df2d9fcc9"><div class="ttname"><a href="xlookup_8c.html#a5e3a316b7d0c5c40ed079f3df2d9fcc9">xLookupField</a></div><div class="ttdeci">XField * xLookupField(const XLookupTable *tab, const char *id)</div><div class="ttdef"><b>Definition</b> xlookup.c:388</div></div>
</div><!-- fragment --><p>Note however, that preparing the lookup table has significant <em>O(N)</em> computational cost also. Therefore, a lookup table is practical only if you are going to use it repeatedly, many times over. As a rule of thumb, lookups may have the advantage if accessing fields in a structure by name hundreds of times, or more.</p>
<p>The same performance limitation also applies to building large structures, since the <code><a class="el" href="xstruct_8c.html#ab1cb91bd6aa14c0dae9d24bfbe7b76f4">xSetField()</a></code> and <code><a class="el" href="xstruct_8c.html#ad84cbb4639f2fbfb604b698a86caf944">xSetSubstruct()</a></code> functions iterate over the existing fields to check if a prior field by the same name was already present, and which should be removed before the new field is set (hence the time to build up a structure with <em>N</em> fields will scale as _O(N<sup>2</sup>)_ in general). The user may consider using <code><a class="el" href="xstruct_8c.html#ad6249db6da0a1294d5621cd9fd829f7a">xInsertField()</a></code> instead, which is much more scalable for building large structures, since it does not check for duplicates (hence scales as <em>O(N)</em> overall). However, <code><a class="el" href="xstruct_8c.html#ad6249db6da0a1294d5621cd9fd829f7a">xInsertField()</a></code> also makes the ordering of fields less intuitive, and it is left up to the caller to ensure that field names added this way are never duplicated. (Tip: if you used <code>InsertField()</code> consistently, you may call <code><a class="el" href="xstruct_8c.html#ad32d8a3f211a3b101142879ae31146ec">xReverseFieldOrder()</a></code> at the end, so the fields will appear in the same order in which they were inserted.)</p>
<h4><a class="anchor" id="autotoc_md18"></a>
Iterating over elements</h4>
<p>You can easily iterate over the elements also. This is one application where you may want to know the internal layout of <code><a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a></code>, namely that it contains a simple linked-list of <code><a class="el" href="structXField.html" title="An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...">XField</a></code> fields. One way to iterate over a strucures elements is with a <code>for</code> loop, e.g.:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structXStructure.html">XStructure</a> *s = ...</div>
<div class="line">XField *f;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (f = s-&gt;<a class="code hl_variable" href="structXStructure.html#a501ae8af2201d9cfaa60e3af21ff58fc">firstField</a>; f != NULL; f = f-&gt;<a class="code hl_variable" href="structXField.html#ae1ebaf87eb62e6266b14908eee28e565">next</a>) {</div>
<div class="line">  <span class="comment">// Process each field &#39;f&#39; here...</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="astructXField_html_ae1ebaf87eb62e6266b14908eee28e565"><div class="ttname"><a href="structXField.html#ae1ebaf87eb62e6266b14908eee28e565">XField::next</a></div><div class="ttdeci">struct XField * next</div><div class="ttdoc">Pointer to the next linked element (if inside an XStructure).</div><div class="ttdef"><b>Definition</b> xchange.h:141</div></div>
<div class="ttc" id="astructXStructure_html_a501ae8af2201d9cfaa60e3af21ff58fc"><div class="ttname"><a href="structXStructure.html#a501ae8af2201d9cfaa60e3af21ff58fc">XStructure::firstField</a></div><div class="ttdeci">XField * firstField</div><div class="ttdoc">Pointer to the first field in this structure or NULL if the structure is empty.</div><div class="ttdef"><b>Definition</b> xchange.h:157</div></div>
</div><!-- fragment --><p><a class="anchor" id="sorting-fields"></a> </p>
<h3><a class="anchor" id="autotoc_md19"></a>
Sorting fields</h3>
<p>You can easily sort fields by name using <code><a class="el" href="xstruct_8c.html#a74d1f6b9b92ebe82353e75a3d7e9daae">xSortFieldsByName()</a></code>, or with using a custom comparator function with <code><a class="el" href="xstruct_8c.html#aa1d006a2788adeb0fc9b4799297a69ff">xSortFields()</a></code>. You can also reverse the order with <code><a class="el" href="xstruct_8c.html#ad32d8a3f211a3b101142879ae31146ec">xReverseFieldOrder()</a></code>. For example to sort fields in a structure (and its substructures) in descending alphabetical order:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structXStructure.html">XStructure</a> *s = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sort in by names in ascending order, recursively</span></div>
<div class="line">xSortFieldsByName(s, <a class="code hl_define" href="xjson_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reverse the order, recursively</span></div>
<div class="line"><a class="code hl_function" href="xstruct_8c.html#ad32d8a3f211a3b101142879ae31146ec">xReverseFieldOrder</a>(s, <a class="code hl_define" href="xjson_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);</div>
<div class="ttc" id="axstruct_8c_html_ad32d8a3f211a3b101142879ae31146ec"><div class="ttname"><a href="xstruct_8c.html#ad32d8a3f211a3b101142879ae31146ec">xReverseFieldOrder</a></div><div class="ttdeci">int xReverseFieldOrder(XStructure *s, boolean recursive)</div><div class="ttdef"><b>Definition</b> xstruct.c:1055</div></div>
</div><!-- fragment --><hr  />
<p><a class="anchor" id="json-interchange"></a> </p>
<h2><a class="anchor" id="autotoc_md21"></a>
JSON parser and emitter</h2>
<p>Once you have an <code><a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a></code> data object, you can easily convert it to a JSON string representation, as:</p>
<div class="fragment"><div class="line"><span class="comment">// Obtain a JSON string representation of the structure &#39;s&#39;.</span></div>
<div class="line"><span class="keywordtype">char</span> *json = <a class="code hl_function" href="xjson_8c.html#a53128045970e973134867c96a6465abc">xjsonToString</a>(s);</div>
<div class="ttc" id="axjson_8c_html_a53128045970e973134867c96a6465abc"><div class="ttname"><a href="xjson_8c.html#a53128045970e973134867c96a6465abc">xjsonToString</a></div><div class="ttdeci">char * xjsonToString(const XStructure *s)</div><div class="ttdef"><b>Definition</b> xjson.c:114</div></div>
</div><!-- fragment --><p>Or, you can do the reverse and create an <code><a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a></code> from its JSON representation, either from a string (a 0-terminated <code>char</code> array):</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> lineNumber = 0;</div>
<div class="line"><a class="code hl_struct" href="structXStructure.html">XStructure</a> *s1 = <a class="code hl_function" href="xjson_8c.html#af180900a4afeef713a3fdaeb77a9cba3">xjsonParseAt</a>(json, &amp;lineNumber);</div>
<div class="line"><span class="keywordflow">if</span> (s1 == NULL) {</div>
<div class="line">   <span class="comment">// Oops, there was some problem...</span></div>
<div class="line">}</div>
<div class="ttc" id="axjson_8c_html_af180900a4afeef713a3fdaeb77a9cba3"><div class="ttname"><a href="xjson_8c.html#af180900a4afeef713a3fdaeb77a9cba3">xjsonParseAt</a></div><div class="ttdeci">XStructure * xjsonParseAt(char **pos, int *lineNumber)</div><div class="ttdef"><b>Definition</b> xjson.c:170</div></div>
</div><!-- fragment --><p>or parse it from a file, which contains a JSON definition of the structured data:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structXStructure.html">XStructure</a> *s1 = <a class="code hl_function" href="xjson_8c.html#afff9ee9473a0c939d18dba977cfac075">xjsonParseFilename</a>(<span class="stringliteral">&quot;my-data.json&quot;</span>, &amp;lineNumber);</div>
<div class="line"><span class="keywordflow">if</span> (s1 == NULL) {</div>
<div class="line">   <span class="comment">// Oops, there was some problem...</span></div>
<div class="line">}</div>
<div class="ttc" id="axjson_8c_html_afff9ee9473a0c939d18dba977cfac075"><div class="ttname"><a href="xjson_8c.html#afff9ee9473a0c939d18dba977cfac075">xjsonParseFilename</a></div><div class="ttdeci">XStructure * xjsonParseFilename(const char *fileName, int *lineNumber)</div><div class="ttdef"><b>Definition</b> xjson.c:203</div></div>
</div><!-- fragment --><hr  />
<p><a class="anchor" id="error-handling"></a> </p>
<h2><a class="anchor" id="autotoc_md23"></a>
Error handling</h2>
<p>The functions that can encounter an error will return either one of the error codes defined in <code><a class="el" href="xchange_8h.html">xchange.h</a></code>, or <code>NULL</code> pointers. String descriptions for the error codes can be produced by <code><a class="el" href="xchange_8c.html#acc701c734a3b95d356660ca5ee16a96a">xErrorDescription(int)</a></code>. For example,</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *text = ...</div>
<div class="line">int status = <a class="code hl_function" href="xchange_8c.html#a7e2e177c11fe7f44ca5ce11f316c0ad9">xParseDouble</a>(text, NULL);</div>
<div class="line"><span class="keywordflow">if</span> (status != <a class="code hl_define" href="xchange_8h.html#a7b2679c964ea5f2160380ed55654b873">X_SUCCESS</a>) {</div>
<div class="line">  <span class="comment">// Ooops, something went wrong...</span></div>
<div class="line">  fprintf(stderr, <span class="stringliteral">&quot;WARNING! %s&quot;</span>, <a class="code hl_function" href="xchange_8c.html#acc701c734a3b95d356660ca5ee16a96a">xErrorDescription</a>(status));</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="axchange_8c_html_a7e2e177c11fe7f44ca5ce11f316c0ad9"><div class="ttname"><a href="xchange_8c.html#a7e2e177c11fe7f44ca5ce11f316c0ad9">xParseDouble</a></div><div class="ttdeci">double xParseDouble(const char *str, char **tail)</div><div class="ttdef"><b>Definition</b> xchange.c:366</div></div>
<div class="ttc" id="axchange_8c_html_acc701c734a3b95d356660ca5ee16a96a"><div class="ttname"><a href="xchange_8c.html#acc701c734a3b95d356660ca5ee16a96a">xErrorDescription</a></div><div class="ttdeci">const char * xErrorDescription(int code)</div><div class="ttdef"><b>Definition</b> xchange.c:459</div></div>
<div class="ttc" id="axchange_8h_html_a7b2679c964ea5f2160380ed55654b873"><div class="ttname"><a href="xchange_8h.html#a7b2679c964ea5f2160380ed55654b873">X_SUCCESS</a></div><div class="ttdeci">#define X_SUCCESS</div><div class="ttdoc">hooray!</div><div class="ttdef"><b>Definition</b> xchange.h:58</div></div>
</div><!-- fragment --><p>The JSON parser &amp; emitter can also sink its error messages to a designated file or stream, which can be set by <code><a class="el" href="xjson_8c.html#a23a7bd364a80bc2bab9ce917ed5f22ea">xjsonSetErrorStream(FILE *)</a></code>.</p>
<hr  />
<p><a class="anchor" id="debugging-support"></a> </p>
<h2><a class="anchor" id="autotoc_md25"></a>
Debugging support</h2>
<p>The <b>xchange</b> library provides two macros: <code><a class="el" href="xchange_8h.html#a1f038bf7ddb58819805cfc44162cb403" title="Use for generating verbose output.">xvprintf()</a></code> and <code><a class="el" href="xchange_8h.html#a2b0edfea798e9e08122f09dba5f189f8" title="Use for generating debug output.">xdprintf()</a></code>, for printing verbose and debug messages to <code>stderr</code>. Both work just like <code>printf()</code>, but they are conditional on verbosity being enabled via <code><a class="el" href="xchange_8c.html#afbe85067ddbc92577cd00ac8f6e3026f">xSetVerbose(boolean)</a></code> and the global variable <code>xDebug</code> being <code>TRUE</code> (non-zero), respectively. Applications using <b>xchange</b> may use these macros to produce their own verbose and/or debugging outputs conditional on the same global settings.</p>
<p>You can also turn debug messages by defining the <code>DEBUG</code> constant for the compiler, e.g. by adding <code>-DDEBUG</code> to <code>CFLAGS</code> prior to calling <code>make</code>.</p>
<p><a class="anchor" id="future-plans"></a> </p>
<h2><a class="anchor" id="autotoc_md26"></a>
Future plans</h2>
<p>There are a number of ways this little library can evolve and grow in the not too distant future. Some of the obvious paths forward are:</p>
<ul>
<li>Add regression testing and code coverage tracking (high priority)</li>
<li>Add support for <a href="https://bsonspec.org/spec.html">BSON</a> &ndash; MongoDB's binary exchange format. (It may require expanding the <code>XType</code> struct for binary subtype.)</li>
<li>Add support for complex-valued data types (<code>X_COMPLEX</code>).</li>
<li>Add support for 128-bit floating point types (<code>X_FLOAT128</code>).</li>
<li>Improved debug support, e.g. with built-in error tracing.</li>
<li>Improved error handling, e.g. by consistently setting <code>errno</code> beyond just the <b>xchange</b> error status.</li>
</ul>
<p>If you have an idea for a must have feature, please let me (Attila) know. Pull requests, for new features or fixes to existing ones are especially welcome!</p>
<hr  />
<p> Copyright (C) 2024 Attila Kov√°cs </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
