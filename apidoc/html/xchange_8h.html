<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta charset="utf-8"/>
<meta name="description" content="Structured data exchange for C/C++"/>
<meta name="keywords" content="structured data, JSON, C, C++, C99, software library, open source"/>
<meta name="author" content="Attila Kovacs"/>
<meta name="copyright" content="(C)2024 Attila Kovacs" />
<meta name="robots" content="index,follow"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-D69CXTY2CJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-D69CXTY2CJ');
</script>
<link rel="shortcut icon" type="image/x-icon" href="/xchange/resources/favicon.ico" />
<link rel="icon" type="image/png" sizes="192x192" href="/xchange/resources/android-chrome-192x192.png" />
<link rel="icon" type="image/png" sizes="512x512" href="/xchange/resources/android-chrome-512x512.png" />
<link rel="apple-touch-icon" type="image/png" href="/xchange/resources/apple-touch-icon.png" />
<title>xchange: include/xchange.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="smithsonian-logo-55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">xchange<span id="projectnumber">&#160;v0.9</span>
   </div>
   <div id="projectbrief">Structured data exchange for C/C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('xchange_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">xchange.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structXField.html">XField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An SMA-X field, typically as part of an <a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a>. A field may be a reference to a nested <a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a> itself.  <a href="structXField.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structXLookupTable.html">XLookupTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structXStructure.html">XStructure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMA-X structure object, containing a linked-list of <a class="el" href="structXField.html" title="An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...">XField</a> elements.  <a href="structXStructure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:adbb2c6827fb22c643243e54992da6c70" id="r_adbb2c6827fb22c643243e54992da6c70"><td class="memItemLeft" align="right" valign="top"><a id="adbb2c6827fb22c643243e54992da6c70" name="adbb2c6827fb22c643243e54992da6c70"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_TYPEDEF_BOOLEAN</b></td></tr>
<tr class="memdesc:adbb2c6827fb22c643243e54992da6c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precompiler constant to indicate if boolean was defined. <br /></td></tr>
<tr class="separator:adbb2c6827fb22c643243e54992da6c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93f0eb578d23995850d61f7d61c55c1" id="r_aa93f0eb578d23995850d61f7d61c55c1"><td class="memItemLeft" align="right" valign="top"><a id="aa93f0eb578d23995850d61f7d61c55c1" name="aa93f0eb578d23995850d61f7d61c55c1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FALSE</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:aa93f0eb578d23995850d61f7d61c55c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean 'false' value, if not already defined. <br /></td></tr>
<tr class="separator:aa93f0eb578d23995850d61f7d61c55c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956e2723d559858d08644ac99146e910" id="r_a956e2723d559858d08644ac99146e910"><td class="memItemLeft" align="right" valign="top"><a id="a956e2723d559858d08644ac99146e910" name="a956e2723d559858d08644ac99146e910"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>INFINITY</b>&#160;&#160;&#160;(1.0/0.0)</td></tr>
<tr class="memdesc:a956e2723d559858d08644ac99146e910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infinity in case it's not already defined in math.h. <br /></td></tr>
<tr class="separator:a956e2723d559858d08644ac99146e910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73012d5991cc49ef05bf1d621a1cde55" id="r_a73012d5991cc49ef05bf1d621a1cde55"><td class="memItemLeft" align="right" valign="top"><a id="a73012d5991cc49ef05bf1d621a1cde55" name="a73012d5991cc49ef05bf1d621a1cde55"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_DEBUG_ERROR_COUNT</b>&#160;&#160;&#160;100</td></tr>
<tr class="memdesc:a73012d5991cc49ef05bf1d621a1cde55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop reporting errors if the number of them exceeds this count. <br /></td></tr>
<tr class="separator:a73012d5991cc49ef05bf1d621a1cde55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abfcc76130f3f991d124dd22d7e69bc" id="r_a8abfcc76130f3f991d124dd22d7e69bc"><td class="memItemLeft" align="right" valign="top"><a id="a8abfcc76130f3f991d124dd22d7e69bc" name="a8abfcc76130f3f991d124dd22d7e69bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NAN</b>&#160;&#160;&#160;(0.0/0.0)</td></tr>
<tr class="memdesc:a8abfcc76130f3f991d124dd22d7e69bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not-a-number in case it's not already defined in math.h. <br /></td></tr>
<tr class="separator:a8abfcc76130f3f991d124dd22d7e69bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f298f5039a547cea57a36c2ef616522" id="r_a1f298f5039a547cea57a36c2ef616522"><td class="memItemLeft" align="right" valign="top"><a id="a1f298f5039a547cea57a36c2ef616522" name="a1f298f5039a547cea57a36c2ef616522"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>str_1</b>(s)&#160;&#160;&#160;#s</td></tr>
<tr class="memdesc:a1f298f5039a547cea57a36c2ef616522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stringify level 1 macro. <br /></td></tr>
<tr class="separator:a1f298f5039a547cea57a36c2ef616522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b3076533e6967aaa48dcccf9ded4a0" id="r_a03b3076533e6967aaa48dcccf9ded4a0"><td class="memItemLeft" align="right" valign="top"><a id="a03b3076533e6967aaa48dcccf9ded4a0" name="a03b3076533e6967aaa48dcccf9ded4a0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>str_2</b>(s)&#160;&#160;&#160;<a class="el" href="xchange_8h.html#a1f298f5039a547cea57a36c2ef616522">str_1</a>(s)</td></tr>
<tr class="memdesc:a03b3076533e6967aaa48dcccf9ded4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stringify level 2 macro. <br /></td></tr>
<tr class="separator:a03b3076533e6967aaa48dcccf9ded4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cecfc5c5c054d2875c03e77b7be15d" id="r_aa8cecfc5c5c054d2875c03e77b7be15d"><td class="memItemLeft" align="right" valign="top"><a id="aa8cecfc5c5c054d2875c03e77b7be15d" name="aa8cecfc5c5c054d2875c03e77b7be15d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TRUE</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:aa8cecfc5c5c054d2875c03e77b7be15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean 'true' value, if not already defined. <br /></td></tr>
<tr class="separator:aa8cecfc5c5c054d2875c03e77b7be15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e947ab368178c7e248b3cf8b26defa1" id="r_a9e947ab368178c7e248b3cf8b26defa1"><td class="memItemLeft" align="right" valign="top"><a id="a9e947ab368178c7e248b3cf8b26defa1" name="a9e947ab368178c7e248b3cf8b26defa1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_ALREADY_OPEN</b>&#160;&#160;&#160;(-2)</td></tr>
<tr class="memdesc:a9e947ab368178c7e248b3cf8b26defa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">can't open the device twice <br /></td></tr>
<tr class="separator:a9e947ab368178c7e248b3cf8b26defa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0465f7669775b6129551a7ef3300bc" id="r_abe0465f7669775b6129551a7ef3300bc"><td class="memItemLeft" align="right" valign="top"><a id="abe0465f7669775b6129551a7ef3300bc" name="abe0465f7669775b6129551a7ef3300bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_BOOLEAN</b></td></tr>
<tr class="memdesc:abe0465f7669775b6129551a7ef3300bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">boolean XType <br /></td></tr>
<tr class="separator:abe0465f7669775b6129551a7ef3300bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb01219635d162589ae5aadb90702bb0" id="r_afb01219635d162589ae5aadb90702bb0"><td class="memItemLeft" align="right" valign="top"><a id="afb01219635d162589ae5aadb90702bb0" name="afb01219635d162589ae5aadb90702bb0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_BYTE</b></td></tr>
<tr class="memdesc:afb01219635d162589ae5aadb90702bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">single byte XType <br /></td></tr>
<tr class="separator:afb01219635d162589ae5aadb90702bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d723969626d4e25235eb24533e3e3a" id="r_a76d723969626d4e25235eb24533e3e3a"><td class="memItemLeft" align="right" valign="top"><a id="a76d723969626d4e25235eb24533e3e3a" name="a76d723969626d4e25235eb24533e3e3a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_CHARS</b>(length)</td></tr>
<tr class="memdesc:a76d723969626d4e25235eb24533e3e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-size sequence of 'length' bytes. <br /></td></tr>
<tr class="separator:a76d723969626d4e25235eb24533e3e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849c7ccb02f63d8554323a889a3d8b4d" id="r_a849c7ccb02f63d8554323a889a3d8b4d"><td class="memItemLeft" align="right" valign="top"><a id="a849c7ccb02f63d8554323a889a3d8b4d" name="a849c7ccb02f63d8554323a889a3d8b4d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_DOUBLE</b></td></tr>
<tr class="memdesc:a849c7ccb02f63d8554323a889a3d8b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">double-precision (64) bit floating point XType <br /></td></tr>
<tr class="separator:a849c7ccb02f63d8554323a889a3d8b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4a0c99f979fd0ecf0e9dcb7191a8d7" id="r_a1d4a0c99f979fd0ecf0e9dcb7191a8d7"><td class="memItemLeft" align="right" valign="top"><a id="a1d4a0c99f979fd0ecf0e9dcb7191a8d7" name="a1d4a0c99f979fd0ecf0e9dcb7191a8d7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_FAILURE</b>&#160;&#160;&#160;(-1)</td></tr>
<tr class="memdesc:a1d4a0c99f979fd0ecf0e9dcb7191a8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">didn't quite work <br /></td></tr>
<tr class="separator:a1d4a0c99f979fd0ecf0e9dcb7191a8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4c8b651428f090a441804bd8b7673e" id="r_a7e4c8b651428f090a441804bd8b7673e"><td class="memItemLeft" align="right" valign="top"><a id="a7e4c8b651428f090a441804bd8b7673e" name="a7e4c8b651428f090a441804bd8b7673e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_FIELD</b></td></tr>
<tr class="memdesc:a7e4c8b651428f090a441804bd8b7673e"><td class="mdescLeft">&#160;</td><td class="mdescRight">XType for an <a class="el" href="structXField.html" title="An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...">XField</a> or array thereof. <br /></td></tr>
<tr class="separator:a7e4c8b651428f090a441804bd8b7673e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5d02e3f3ec45ae6fe1e6afd09690a5" id="r_abf5d02e3f3ec45ae6fe1e6afd09690a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#abf5d02e3f3ec45ae6fe1e6afd09690a5">X_FIELD_INIT</a>&#160;&#160;&#160;{NULL, NULL, <a class="el" href="xchange_8h.html#a1f2359ea36bfcb29d936b1eef60a53a3">X_UNKNOWN</a>, NULL, 0, {0}, <a class="el" href="xjson_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, NULL}</td></tr>
<tr class="separator:abf5d02e3f3ec45ae6fe1e6afd09690a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99605e05158426b1b44e924e42a1162c" id="r_a99605e05158426b1b44e924e42a1162c"><td class="memItemLeft" align="right" valign="top"><a id="a99605e05158426b1b44e924e42a1162c" name="a99605e05158426b1b44e924e42a1162c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_FLOAT</b></td></tr>
<tr class="memdesc:a99605e05158426b1b44e924e42a1162c"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit floating point XType <br /></td></tr>
<tr class="separator:a99605e05158426b1b44e924e42a1162c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c78a0e8290b2fd3701031ebce3fa15" id="r_a48c78a0e8290b2fd3701031ebce3fa15"><td class="memItemLeft" align="right" valign="top"><a id="a48c78a0e8290b2fd3701031ebce3fa15" name="a48c78a0e8290b2fd3701031ebce3fa15"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_GROUP_INVALID</b>&#160;&#160;&#160;(-20)</td></tr>
<tr class="memdesc:a48c78a0e8290b2fd3701031ebce3fa15"><td class="mdescLeft">&#160;</td><td class="mdescRight">there's no such variable group or hash table <br /></td></tr>
<tr class="separator:a48c78a0e8290b2fd3701031ebce3fa15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888dbfa464548f0b65794e172713160b" id="r_a888dbfa464548f0b65794e172713160b"><td class="memItemLeft" align="right" valign="top"><a id="a888dbfa464548f0b65794e172713160b" name="a888dbfa464548f0b65794e172713160b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_INCOMPLETE</b>&#160;&#160;&#160;(-9)</td></tr>
<tr class="memdesc:a888dbfa464548f0b65794e172713160b"><td class="mdescLeft">&#160;</td><td class="mdescRight">incomplete data transfer <br /></td></tr>
<tr class="separator:a888dbfa464548f0b65794e172713160b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4003d7fe06200f77805c52cc7db56784" id="r_a4003d7fe06200f77805c52cc7db56784"><td class="memItemLeft" align="right" valign="top"><a id="a4003d7fe06200f77805c52cc7db56784" name="a4003d7fe06200f77805c52cc7db56784"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_INT</b></td></tr>
<tr class="memdesc:a4003d7fe06200f77805c52cc7db56784"><td class="mdescLeft">&#160;</td><td class="mdescRight">native int XType (usually 16-bits) <br /></td></tr>
<tr class="separator:a4003d7fe06200f77805c52cc7db56784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3942401de37f774e72393ffa73c9fb9f" id="r_a3942401de37f774e72393ffa73c9fb9f"><td class="memItemLeft" align="right" valign="top"><a id="a3942401de37f774e72393ffa73c9fb9f" name="a3942401de37f774e72393ffa73c9fb9f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_INTERRUPTED</b>&#160;&#160;&#160;(-8)</td></tr>
<tr class="memdesc:a3942401de37f774e72393ffa73c9fb9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">a waiting call interrupted by user <br /></td></tr>
<tr class="separator:a3942401de37f774e72393ffa73c9fb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36405f1834eb7cd51a17f103b2942e21" id="r_a36405f1834eb7cd51a17f103b2942e21"><td class="memItemLeft" align="right" valign="top"><a id="a36405f1834eb7cd51a17f103b2942e21" name="a36405f1834eb7cd51a17f103b2942e21"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_LONG</b></td></tr>
<tr class="memdesc:a36405f1834eb7cd51a17f103b2942e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit int XType <br /></td></tr>
<tr class="separator:a36405f1834eb7cd51a17f103b2942e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910ee1c8cd983bf127f7ca2c705d7894" id="r_a910ee1c8cd983bf127f7ca2c705d7894"><td class="memItemLeft" align="right" valign="top"><a id="a910ee1c8cd983bf127f7ca2c705d7894" name="a910ee1c8cd983bf127f7ca2c705d7894"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_MAX_DIMS</b>&#160;&#160;&#160;20</td></tr>
<tr class="memdesc:a910ee1c8cd983bf127f7ca2c705d7894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of dimensionas (2^20 -&gt; 1 million points). <br /></td></tr>
<tr class="separator:a910ee1c8cd983bf127f7ca2c705d7894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5743ece908b043528077f499c42d57" id="r_a7a5743ece908b043528077f499c42d57"><td class="memItemLeft" align="right" valign="top"><a id="a7a5743ece908b043528077f499c42d57" name="a7a5743ece908b043528077f499c42d57"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_MAX_ELEMENTS</b></td></tr>
<tr class="memdesc:a7a5743ece908b043528077f499c42d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of array elements (~1 million). <br /></td></tr>
<tr class="separator:a7a5743ece908b043528077f499c42d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319ecdfb71bd7ccda1c7049965a64d6d" id="r_a319ecdfb71bd7ccda1c7049965a64d6d"><td class="memItemLeft" align="right" valign="top"><a id="a319ecdfb71bd7ccda1c7049965a64d6d" name="a319ecdfb71bd7ccda1c7049965a64d6d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_MAX_STRING_DIMS</b></td></tr>
<tr class="memdesc:a319ecdfb71bd7ccda1c7049965a64d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of string representation of dimensions. <br /></td></tr>
<tr class="separator:a319ecdfb71bd7ccda1c7049965a64d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5426366367d169401f779c4764ba7736" id="r_a5426366367d169401f779c4764ba7736"><td class="memItemLeft" align="right" valign="top"><a id="a5426366367d169401f779c4764ba7736" name="a5426366367d169401f779c4764ba7736"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_NAME_INVALID</b>&#160;&#160;&#160;(-21)</td></tr>
<tr class="memdesc:a5426366367d169401f779c4764ba7736"><td class="mdescLeft">&#160;</td><td class="mdescRight">invalid field/key name <br /></td></tr>
<tr class="separator:a5426366367d169401f779c4764ba7736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0783aebbbcc863bf212273131709ad3c" id="r_a0783aebbbcc863bf212273131709ad3c"><td class="memItemLeft" align="right" valign="top"><a id="a0783aebbbcc863bf212273131709ad3c" name="a0783aebbbcc863bf212273131709ad3c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_NO_BLOCKED_READ</b>&#160;&#160;&#160;(-5)</td></tr>
<tr class="memdesc:a0783aebbbcc863bf212273131709ad3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">there are no blocked read calls <br /></td></tr>
<tr class="separator:a0783aebbbcc863bf212273131709ad3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1324cef45d5b26097bf488ad3b7f9e7b" id="r_a1324cef45d5b26097bf488ad3b7f9e7b"><td class="memItemLeft" align="right" valign="top"><a id="a1324cef45d5b26097bf488ad3b7f9e7b" name="a1324cef45d5b26097bf488ad3b7f9e7b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_NO_INIT</b>&#160;&#160;&#160;(-3)</td></tr>
<tr class="memdesc:a1324cef45d5b26097bf488ad3b7f9e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">must initialize first <br /></td></tr>
<tr class="separator:a1324cef45d5b26097bf488ad3b7f9e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385df18f40a243b7c3d3d0b4ffbdb336" id="r_a385df18f40a243b7c3d3d0b4ffbdb336"><td class="memItemLeft" align="right" valign="top"><a id="a385df18f40a243b7c3d3d0b4ffbdb336" name="a385df18f40a243b7c3d3d0b4ffbdb336"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_NO_PIPELINE</b>&#160;&#160;&#160;(-6)</td></tr>
<tr class="memdesc:a385df18f40a243b7c3d3d0b4ffbdb336"><td class="mdescLeft">&#160;</td><td class="mdescRight">pipelining is not configured or supported <br /></td></tr>
<tr class="separator:a385df18f40a243b7c3d3d0b4ffbdb336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aeb707470a6d1a45626c123e84abe86" id="r_a7aeb707470a6d1a45626c123e84abe86"><td class="memItemLeft" align="right" valign="top"><a id="a7aeb707470a6d1a45626c123e84abe86" name="a7aeb707470a6d1a45626c123e84abe86"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_NO_SERVICE</b>&#160;&#160;&#160;(-4)</td></tr>
<tr class="memdesc:a7aeb707470a6d1a45626c123e84abe86"><td class="mdescLeft">&#160;</td><td class="mdescRight">no connection to server <br /></td></tr>
<tr class="separator:a7aeb707470a6d1a45626c123e84abe86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8ccb371c640d2b79a16bb6bdd13cc4" id="r_a2e8ccb371c640d2b79a16bb6bdd13cc4"><td class="memItemLeft" align="right" valign="top"><a id="a2e8ccb371c640d2b79a16bb6bdd13cc4" name="a2e8ccb371c640d2b79a16bb6bdd13cc4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_NOT_ENOUGH_TOKENS</b>&#160;&#160;&#160;(-12)</td></tr>
<tr class="memdesc:a2e8ccb371c640d2b79a16bb6bdd13cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of components fewer than expected <br /></td></tr>
<tr class="separator:a2e8ccb371c640d2b79a16bb6bdd13cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbbe3ae01369cbddf4d57d430b33133" id="r_aadbbe3ae01369cbddf4d57d430b33133"><td class="memItemLeft" align="right" valign="top"><a id="aadbbe3ae01369cbddf4d57d430b33133" name="aadbbe3ae01369cbddf4d57d430b33133"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_NULL</b>&#160;&#160;&#160;(-10)</td></tr>
<tr class="memdesc:aadbbe3ae01369cbddf4d57d430b33133"><td class="mdescLeft">&#160;</td><td class="mdescRight">something essential is NULL <br /></td></tr>
<tr class="separator:aadbbe3ae01369cbddf4d57d430b33133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d83cc351dfae22fe7346559f5a440e" id="r_a86d83cc351dfae22fe7346559f5a440e"><td class="memItemLeft" align="right" valign="top"><a id="a86d83cc351dfae22fe7346559f5a440e" name="a86d83cc351dfae22fe7346559f5a440e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_PARSE_ERROR</b>&#160;&#160;&#160;(-11)</td></tr>
<tr class="memdesc:a86d83cc351dfae22fe7346559f5a440e"><td class="mdescLeft">&#160;</td><td class="mdescRight">parsing failure <br /></td></tr>
<tr class="separator:a86d83cc351dfae22fe7346559f5a440e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb72c72467963a6ace1632638a8a6a7b" id="r_adb72c72467963a6ace1632638a8a6a7b"><td class="memItemLeft" align="right" valign="top"><a id="adb72c72467963a6ace1632638a8a6a7b" name="adb72c72467963a6ace1632638a8a6a7b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_RAW</b></td></tr>
<tr class="memdesc:adb72c72467963a6ace1632638a8a6a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">raw Redis (string) value XType, as stored in database <br /></td></tr>
<tr class="separator:adb72c72467963a6ace1632638a8a6a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923cd66e2074f32817a3468c5617a440" id="r_a923cd66e2074f32817a3468c5617a440"><td class="memItemLeft" align="right" valign="top"><a id="a923cd66e2074f32817a3468c5617a440" name="a923cd66e2074f32817a3468c5617a440"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_SEP</b>&#160;&#160;&#160;&quot;:&quot;</td></tr>
<tr class="memdesc:a923cd66e2074f32817a3468c5617a440"><td class="mdescLeft">&#160;</td><td class="mdescRight">sepatator for patterning of notification channels, e.g. "changed:&lt;table&gt;:&lt;key&gt;" <br /></td></tr>
<tr class="separator:a923cd66e2074f32817a3468c5617a440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28120364666ec6054159012a58ba27af" id="r_a28120364666ec6054159012a58ba27af"><td class="memItemLeft" align="right" valign="top"><a id="a28120364666ec6054159012a58ba27af" name="a28120364666ec6054159012a58ba27af"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_SEP_LENGTH</b>&#160;&#160;&#160;(sizeof(<a class="el" href="xchange_8h.html#a923cd66e2074f32817a3468c5617a440">X_SEP</a>) - 1)</td></tr>
<tr class="memdesc:a28120364666ec6054159012a58ba27af"><td class="mdescLeft">&#160;</td><td class="mdescRight">String length of hierarchical separator. <br /></td></tr>
<tr class="separator:a28120364666ec6054159012a58ba27af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdc22097b12d42c040dcce8700d64b8" id="r_adfdc22097b12d42c040dcce8700d64b8"><td class="memItemLeft" align="right" valign="top"><a id="adfdc22097b12d42c040dcce8700d64b8" name="adfdc22097b12d42c040dcce8700d64b8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_SHORT</b></td></tr>
<tr class="memdesc:adfdc22097b12d42c040dcce8700d64b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">native short XType (usually 16-bits) <br /></td></tr>
<tr class="separator:adfdc22097b12d42c040dcce8700d64b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816c5dad11d9bfd91a795ed1af30e732" id="r_a816c5dad11d9bfd91a795ed1af30e732"><td class="memItemLeft" align="right" valign="top"><a id="a816c5dad11d9bfd91a795ed1af30e732" name="a816c5dad11d9bfd91a795ed1af30e732"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_SIZE_INVALID</b>&#160;&#160;&#160;(-23)</td></tr>
<tr class="memdesc:a816c5dad11d9bfd91a795ed1af30e732"><td class="mdescLeft">&#160;</td><td class="mdescRight">invalid data size <br /></td></tr>
<tr class="separator:a816c5dad11d9bfd91a795ed1af30e732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2443dd783d2728a3559361fba845e533" id="r_a2443dd783d2728a3559361fba845e533"><td class="memItemLeft" align="right" valign="top"><a id="a2443dd783d2728a3559361fba845e533" name="a2443dd783d2728a3559361fba845e533"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_STRING</b></td></tr>
<tr class="memdesc:a2443dd783d2728a3559361fba845e533"><td class="mdescLeft">&#160;</td><td class="mdescRight">a terminated string XType <br /></td></tr>
<tr class="separator:a2443dd783d2728a3559361fba845e533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63de1f3edab36b1a53ee312ac0711cbb" id="r_a63de1f3edab36b1a53ee312ac0711cbb"><td class="memItemLeft" align="right" valign="top"><a id="a63de1f3edab36b1a53ee312ac0711cbb" name="a63de1f3edab36b1a53ee312ac0711cbb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_STRUCT</b></td></tr>
<tr class="memdesc:a63de1f3edab36b1a53ee312ac0711cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">XType for an <a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a> or array thereof. <br /></td></tr>
<tr class="separator:a63de1f3edab36b1a53ee312ac0711cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374255b53a06fcd02222b435d59e220f" id="r_a374255b53a06fcd02222b435d59e220f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a374255b53a06fcd02222b435d59e220f">X_STRUCT_INIT</a>&#160;&#160;&#160;{NULL}</td></tr>
<tr class="separator:a374255b53a06fcd02222b435d59e220f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b6e6d9baf3e6767041faa3e356af7a" id="r_af4b6e6d9baf3e6767041faa3e356af7a"><td class="memItemLeft" align="right" valign="top"><a id="af4b6e6d9baf3e6767041faa3e356af7a" name="af4b6e6d9baf3e6767041faa3e356af7a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_STRUCT_INVALID</b>&#160;&#160;&#160;(-24)</td></tr>
<tr class="memdesc:af4b6e6d9baf3e6767041faa3e356af7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">invalid data structure <br /></td></tr>
<tr class="separator:af4b6e6d9baf3e6767041faa3e356af7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2679c964ea5f2160380ed55654b873" id="r_a7b2679c964ea5f2160380ed55654b873"><td class="memItemLeft" align="right" valign="top"><a id="a7b2679c964ea5f2160380ed55654b873" name="a7b2679c964ea5f2160380ed55654b873"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_SUCCESS</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a7b2679c964ea5f2160380ed55654b873"><td class="mdescLeft">&#160;</td><td class="mdescRight">hooray! <br /></td></tr>
<tr class="separator:a7b2679c964ea5f2160380ed55654b873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad525869626b4f755aa27d6ef37a15c3d" id="r_ad525869626b4f755aa27d6ef37a15c3d"><td class="memItemLeft" align="right" valign="top"><a id="ad525869626b4f755aa27d6ef37a15c3d" name="ad525869626b4f755aa27d6ef37a15c3d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_TIMEDOUT</b>&#160;&#160;&#160;(-7)</td></tr>
<tr class="memdesc:ad525869626b4f755aa27d6ef37a15c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the operation timed out. <br /></td></tr>
<tr class="separator:ad525869626b4f755aa27d6ef37a15c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867ae02d3e93665fa1b7c3c39534d692" id="r_a867ae02d3e93665fa1b7c3c39534d692"><td class="memItemLeft" align="right" valign="top"><a id="a867ae02d3e93665fa1b7c3c39534d692" name="a867ae02d3e93665fa1b7c3c39534d692"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_TIMESTAMP_LENGTH</b>&#160;&#160;&#160;18</td></tr>
<tr class="memdesc:a867ae02d3e93665fa1b7c3c39534d692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Characters in timestamp, 10 + 6 + 2 = 18 including termination. <br /></td></tr>
<tr class="separator:a867ae02d3e93665fa1b7c3c39534d692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc19edf892709b39a9c0d3d944f8f9a" id="r_aecc19edf892709b39a9c0d3d944f8f9a"><td class="memItemLeft" align="right" valign="top"><a id="aecc19edf892709b39a9c0d3d944f8f9a" name="aecc19edf892709b39a9c0d3d944f8f9a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_TYPE_INVALID</b>&#160;&#160;&#160;(-22)</td></tr>
<tr class="memdesc:aecc19edf892709b39a9c0d3d944f8f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">invalid data type <br /></td></tr>
<tr class="separator:aecc19edf892709b39a9c0d3d944f8f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2359ea36bfcb29d936b1eef60a53a3" id="r_a1f2359ea36bfcb29d936b1eef60a53a3"><td class="memItemLeft" align="right" valign="top"><a id="a1f2359ea36bfcb29d936b1eef60a53a3" name="a1f2359ea36bfcb29d936b1eef60a53a3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_UNKNOWN</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a1f2359ea36bfcb29d936b1eef60a53a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unknown XType (default) <br /></td></tr>
<tr class="separator:a1f2359ea36bfcb29d936b1eef60a53a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ea68e798d0cd9cab06667707737055" id="r_a13ea68e798d0cd9cab06667707737055"><td class="memItemLeft" align="right" valign="top"><a id="a13ea68e798d0cd9cab06667707737055" name="a13ea68e798d0cd9cab06667707737055"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XCHANGE_MAJOR_VERSION</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a13ea68e798d0cd9cab06667707737055"><td class="mdescLeft">&#160;</td><td class="mdescRight">API major version. <br /></td></tr>
<tr class="separator:a13ea68e798d0cd9cab06667707737055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52519844e66bcff3ed17e4feaab76b2f" id="r_a52519844e66bcff3ed17e4feaab76b2f"><td class="memItemLeft" align="right" valign="top"><a id="a52519844e66bcff3ed17e4feaab76b2f" name="a52519844e66bcff3ed17e4feaab76b2f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XCHANGE_MINOR_VERSION</b>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:a52519844e66bcff3ed17e4feaab76b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">API minor version. <br /></td></tr>
<tr class="separator:a52519844e66bcff3ed17e4feaab76b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef108c611a8388c435502dfd89c41a5f" id="r_aef108c611a8388c435502dfd89c41a5f"><td class="memItemLeft" align="right" valign="top"><a id="aef108c611a8388c435502dfd89c41a5f" name="aef108c611a8388c435502dfd89c41a5f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XCHANGE_PATCHLEVEL</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:aef108c611a8388c435502dfd89c41a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer sub version of the release. <br /></td></tr>
<tr class="separator:aef108c611a8388c435502dfd89c41a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cda2967190e2d61c5560bf6b43d930d" id="r_a1cda2967190e2d61c5560bf6b43d930d"><td class="memItemLeft" align="right" valign="top"><a id="a1cda2967190e2d61c5560bf6b43d930d" name="a1cda2967190e2d61c5560bf6b43d930d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XCHANGE_RELEASE_STRING</b>&#160;&#160;&#160;&quot;-devel&quot;</td></tr>
<tr class="memdesc:a1cda2967190e2d61c5560bf6b43d930d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional release information in version, e.g. "-1", or "-rc1". <br /></td></tr>
<tr class="separator:a1cda2967190e2d61c5560bf6b43d930d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8ac004db0f6cb82e1b7a13b79380c5" id="r_a2e8ac004db0f6cb82e1b7a13b79380c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a2e8ac004db0f6cb82e1b7a13b79380c5">XCHANGE_VERSION_STRING</a></td></tr>
<tr class="memdesc:a2e8ac004db0f6cb82e1b7a13b79380c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The version string for this library.  <br /></td></tr>
<tr class="separator:a2e8ac004db0f6cb82e1b7a13b79380c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0edfea798e9e08122f09dba5f189f8" id="r_a2b0edfea798e9e08122f09dba5f189f8"><td class="memItemLeft" align="right" valign="top"><a id="a2b0edfea798e9e08122f09dba5f189f8" name="a2b0edfea798e9e08122f09dba5f189f8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>xdprintf</b>&#160;&#160;&#160;if(<a class="el" href="xchange_8c.html#ace21b1dd3eab2ce044a2fea31e393e7b">xDebug</a>) printf</td></tr>
<tr class="memdesc:a2b0edfea798e9e08122f09dba5f189f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use for generating debug output. <br /></td></tr>
<tr class="separator:a2b0edfea798e9e08122f09dba5f189f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f038bf7ddb58819805cfc44162cb403" id="r_a1f038bf7ddb58819805cfc44162cb403"><td class="memItemLeft" align="right" valign="top"><a id="a1f038bf7ddb58819805cfc44162cb403" name="a1f038bf7ddb58819805cfc44162cb403"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>xvprintf</b>&#160;&#160;&#160;if(<a class="el" href="xchange_8c.html#a363b67b316973290c30c11bea7931c64">xVerbose</a>) printf</td></tr>
<tr class="memdesc:a1f038bf7ddb58819805cfc44162cb403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use for generating verbose output. <br /></td></tr>
<tr class="separator:a1f038bf7ddb58819805cfc44162cb403"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a621c38f1f10a1c565d897e3178b16d6e" id="r_a621c38f1f10a1c565d897e3178b16d6e"><td class="memItemLeft" align="right" valign="top"><a id="a621c38f1f10a1c565d897e3178b16d6e" name="a621c38f1f10a1c565d897e3178b16d6e"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>boolean</b></td></tr>
<tr class="memdesc:a621c38f1f10a1c565d897e3178b16d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">boolean TRUE/FALSE data type. <br /></td></tr>
<tr class="separator:a621c38f1f10a1c565d897e3178b16d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7e02eda23566a7891310fd09307a70" id="r_a1c7e02eda23566a7891310fd09307a70"><td class="memItemLeft" align="right" valign="top"><a id="a1c7e02eda23566a7891310fd09307a70" name="a1c7e02eda23566a7891310fd09307a70"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>XType</b></td></tr>
<tr class="memdesc:a1c7e02eda23566a7891310fd09307a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMA-X data type. <br /></td></tr>
<tr class="separator:a1c7e02eda23566a7891310fd09307a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3525be19588c2b740fc0dbd54a936dcb" id="r_a3525be19588c2b740fc0dbd54a936dcb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a3525be19588c2b740fc0dbd54a936dcb">xAlloc</a> (<a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a> type, int count)</td></tr>
<tr class="separator:a3525be19588c2b740fc0dbd54a936dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a94b3210aed984dbee956fbb26fcfd" id="r_a01a94b3210aed984dbee956fbb26fcfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXLookupTable.html">XLookupTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a01a94b3210aed984dbee956fbb26fcfd">xAllocLookup</a> (unsigned int size)</td></tr>
<tr class="separator:a01a94b3210aed984dbee956fbb26fcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b81d2bbe48788a9741e815cdaa336eb" id="r_a2b81d2bbe48788a9741e815cdaa336eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a2b81d2bbe48788a9741e815cdaa336eb">xClearField</a> (<a class="el" href="structXField.html">XField</a> *f)</td></tr>
<tr class="separator:a2b81d2bbe48788a9741e815cdaa336eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45c0a047c30a17aba84d2fc8c08a2dc" id="r_ae45c0a047c30a17aba84d2fc8c08a2dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#ae45c0a047c30a17aba84d2fc8c08a2dc">xClearStruct</a> (<a class="el" href="structXStructure.html">XStructure</a> *s)</td></tr>
<tr class="separator:ae45c0a047c30a17aba84d2fc8c08a2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20a0213369a947a7e48ff45aabee3c0" id="r_ab20a0213369a947a7e48ff45aabee3c0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#ab20a0213369a947a7e48ff45aabee3c0">xCopyIDToken</a> (const char *id)</td></tr>
<tr class="separator:ab20a0213369a947a7e48ff45aabee3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb31906269568772fdf63adb6685fbc" id="r_afdb31906269568772fdf63adb6685fbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXField.html">XField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#afdb31906269568772fdf63adb6685fbc">xCopyOfField</a> (const <a class="el" href="structXField.html">XField</a> *f)</td></tr>
<tr class="separator:afdb31906269568772fdf63adb6685fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78b2fb3d6d1474c8a44c57575a6e13b" id="r_ad78b2fb3d6d1474c8a44c57575a6e13b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXStructure.html">XStructure</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#ad78b2fb3d6d1474c8a44c57575a6e13b">xCopyOfStruct</a> (const <a class="el" href="structXStructure.html">XStructure</a> *s)</td></tr>
<tr class="separator:ad78b2fb3d6d1474c8a44c57575a6e13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7447cdd983402a27a25a70cc7187275" id="r_af7447cdd983402a27a25a70cc7187275"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#af7447cdd983402a27a25a70cc7187275">xCountFields</a> (const <a class="el" href="structXStructure.html">XStructure</a> *s)</td></tr>
<tr class="separator:af7447cdd983402a27a25a70cc7187275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9897f06ef8a22d5ddb8538d5fe223ae2" id="r_a9897f06ef8a22d5ddb8538d5fe223ae2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXField.html">XField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a9897f06ef8a22d5ddb8538d5fe223ae2">xCreate1DField</a> (const char *name, <a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a> type, int count, const void *values)</td></tr>
<tr class="separator:a9897f06ef8a22d5ddb8538d5fe223ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fa86a7d296f1efa6b41079bc2a6b65" id="r_ad2fa86a7d296f1efa6b41079bc2a6b65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXField.html">XField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#ad2fa86a7d296f1efa6b41079bc2a6b65">xCreateBooleanField</a> (const char *name, <a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a> value)</td></tr>
<tr class="separator:ad2fa86a7d296f1efa6b41079bc2a6b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ac206d0ec3608a0872f09c7f7bc189" id="r_ab7ac206d0ec3608a0872f09c7f7bc189"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXField.html">XField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#ab7ac206d0ec3608a0872f09c7f7bc189">xCreateDoubleField</a> (const char *name, double value)</td></tr>
<tr class="separator:ab7ac206d0ec3608a0872f09c7f7bc189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e4e75cbf8f721ef4b251c692dcd7cb" id="r_a42e4e75cbf8f721ef4b251c692dcd7cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXField.html">XField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a42e4e75cbf8f721ef4b251c692dcd7cb">xCreateField</a> (const char *name, <a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a> type, int ndim, const int *sizes, const void *value)</td></tr>
<tr class="separator:a42e4e75cbf8f721ef4b251c692dcd7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4405d56659397e044b6d4fdda394dfa" id="r_aa4405d56659397e044b6d4fdda394dfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXField.html">XField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#aa4405d56659397e044b6d4fdda394dfa">xCreateIntField</a> (const char *name, int value)</td></tr>
<tr class="separator:aa4405d56659397e044b6d4fdda394dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4587dcd0157acce30373288e19f1237d" id="r_a4587dcd0157acce30373288e19f1237d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXField.html">XField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a4587dcd0157acce30373288e19f1237d">xCreateLongField</a> (const char *name, long long value)</td></tr>
<tr class="separator:a4587dcd0157acce30373288e19f1237d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bee9eeac947d7e36ea436252e8dc2d" id="r_af8bee9eeac947d7e36ea436252e8dc2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXLookupTable.html">XLookupTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#af8bee9eeac947d7e36ea436252e8dc2d">xCreateLookup</a> (const <a class="el" href="structXStructure.html">XStructure</a> *s, <a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a> recursive)</td></tr>
<tr class="separator:af8bee9eeac947d7e36ea436252e8dc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7c0e588603da8bd8893807408f51e3" id="r_a5b7c0e588603da8bd8893807408f51e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXField.html">XField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a5b7c0e588603da8bd8893807408f51e3">xCreateMixed1DField</a> (const char *name, int size, <a class="el" href="structXField.html">XField</a> *value)</td></tr>
<tr class="separator:a5b7c0e588603da8bd8893807408f51e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0823001995982977fe1e07b088c953" id="r_acf0823001995982977fe1e07b088c953"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXField.html">XField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#acf0823001995982977fe1e07b088c953">xCreateMixedArrayField</a> (const char *name, int ndim, const int *sizes, <a class="el" href="structXField.html">XField</a> *value)</td></tr>
<tr class="separator:acf0823001995982977fe1e07b088c953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965f7e58fd1c10570c6f6a472599b08f" id="r_a965f7e58fd1c10570c6f6a472599b08f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXField.html">XField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a965f7e58fd1c10570c6f6a472599b08f">xCreateScalarField</a> (const char *name, <a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a> type, const void *value)</td></tr>
<tr class="separator:a965f7e58fd1c10570c6f6a472599b08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc77bed0d8b738ba615019721a6a2b6" id="r_a9dc77bed0d8b738ba615019721a6a2b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXField.html">XField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a9dc77bed0d8b738ba615019721a6a2b6">xCreateStringField</a> (const char *name, const char *value)</td></tr>
<tr class="separator:a9dc77bed0d8b738ba615019721a6a2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12112584a34e07f9ef7b08f6ef1bc865" id="r_a12112584a34e07f9ef7b08f6ef1bc865"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXStructure.html">XStructure</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a12112584a34e07f9ef7b08f6ef1bc865">xCreateStruct</a> ()</td></tr>
<tr class="separator:a12112584a34e07f9ef7b08f6ef1bc865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789489313df89d33aa50de911e1e42ff" id="r_a789489313df89d33aa50de911e1e42ff"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a789489313df89d33aa50de911e1e42ff">xDeepCountFields</a> (const <a class="el" href="structXStructure.html">XStructure</a> *s)</td></tr>
<tr class="separator:a789489313df89d33aa50de911e1e42ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ce99c867b11bd14971031eec8ba4ad" id="r_ae0ce99c867b11bd14971031eec8ba4ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#ae0ce99c867b11bd14971031eec8ba4ad">xDestroyField</a> (<a class="el" href="structXField.html">XField</a> *f)</td></tr>
<tr class="separator:ae0ce99c867b11bd14971031eec8ba4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ea2d67e4c540ad706edcc1b3a0431e" id="r_a02ea2d67e4c540ad706edcc1b3a0431e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a02ea2d67e4c540ad706edcc1b3a0431e">xDestroyLookup</a> (<a class="el" href="structXLookupTable.html">XLookupTable</a> *tab)</td></tr>
<tr class="separator:a02ea2d67e4c540ad706edcc1b3a0431e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3fda2f392bae11e136e8c0c90f086d" id="r_afe3fda2f392bae11e136e8c0c90f086d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#afe3fda2f392bae11e136e8c0c90f086d">xDestroyStruct</a> (<a class="el" href="structXStructure.html">XStructure</a> *s)</td></tr>
<tr class="separator:afe3fda2f392bae11e136e8c0c90f086d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ec26d18b20fc0da9ec9032af73fa9e" id="r_af5ec26d18b20fc0da9ec9032af73fa9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#af5ec26d18b20fc0da9ec9032af73fa9e">xElementSizeOf</a> (<a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a> type)</td></tr>
<tr class="separator:af5ec26d18b20fc0da9ec9032af73fa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606c4844e51124bee155e30bac8ca885" id="r_a606c4844e51124bee155e30bac8ca885"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a606c4844e51124bee155e30bac8ca885">xError</a> (const char *fn, int code)</td></tr>
<tr class="separator:a606c4844e51124bee155e30bac8ca885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc701c734a3b95d356660ca5ee16a96a" id="r_acc701c734a3b95d356660ca5ee16a96a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#acc701c734a3b95d356660ca5ee16a96a">xErrorDescription</a> (int code)</td></tr>
<tr class="separator:acc701c734a3b95d356660ca5ee16a96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e104d7a23090f8ae0e6ea3cc55a84f" id="r_a32e104d7a23090f8ae0e6ea3cc55a84f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a32e104d7a23090f8ae0e6ea3cc55a84f">xGetAggregateID</a> (const char *group, const char *key)</td></tr>
<tr class="separator:a32e104d7a23090f8ae0e6ea3cc55a84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35e0d8c0ebbb4948c233f96c54bd8d6" id="r_ad35e0d8c0ebbb4948c233f96c54bd8d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#ad35e0d8c0ebbb4948c233f96c54bd8d6">xGetElementCount</a> (int ndim, const int *sizes)</td></tr>
<tr class="separator:ad35e0d8c0ebbb4948c233f96c54bd8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f1d50fc0f1553b806bedbd17d2206e" id="r_ad3f1d50fc0f1553b806bedbd17d2206e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXField.html">XField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#ad3f1d50fc0f1553b806bedbd17d2206e">xGetField</a> (const <a class="el" href="structXStructure.html">XStructure</a> *s, const char *name)</td></tr>
<tr class="separator:ad3f1d50fc0f1553b806bedbd17d2206e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1720e156de63fd0585224738ccbb5688" id="r_a1720e156de63fd0585224738ccbb5688"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a1720e156de63fd0585224738ccbb5688">xGetFieldCount</a> (const <a class="el" href="structXField.html">XField</a> *f)</td></tr>
<tr class="separator:a1720e156de63fd0585224738ccbb5688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a58e33c4730e272af459dfb7f016f9" id="r_a97a58e33c4730e272af459dfb7f016f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXStructure.html">XStructure</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a97a58e33c4730e272af459dfb7f016f9">xGetSubstruct</a> (const <a class="el" href="structXStructure.html">XStructure</a> *s, const char *id)</td></tr>
<tr class="separator:a97a58e33c4730e272af459dfb7f016f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc86baacb3ddebcc529e269223274b8" id="r_adcc86baacb3ddebcc529e269223274b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#adcc86baacb3ddebcc529e269223274b8">xIsCharSequence</a> (<a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a> type)</td></tr>
<tr class="separator:adcc86baacb3ddebcc529e269223274b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6e78e07733ca246ca485b0fcf02d21" id="r_aec6e78e07733ca246ca485b0fcf02d21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#aec6e78e07733ca246ca485b0fcf02d21">xIsFieldValid</a> (const <a class="el" href="structXField.html">XField</a> *f)</td></tr>
<tr class="separator:aec6e78e07733ca246ca485b0fcf02d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a6c2d802ebadd46ffcfdde7fb438b8" id="r_a46a6c2d802ebadd46ffcfdde7fb438b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a46a6c2d802ebadd46ffcfdde7fb438b8">xIsVerbose</a> ()</td></tr>
<tr class="separator:a46a6c2d802ebadd46ffcfdde7fb438b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a9fbc1235164bfeed5fbba1f7d8692" id="r_ab9a9fbc1235164bfeed5fbba1f7d8692"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#ab9a9fbc1235164bfeed5fbba1f7d8692">xLastSeparator</a> (const char *id)</td></tr>
<tr class="separator:ab9a9fbc1235164bfeed5fbba1f7d8692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e81b8f1bf3e1c3572ca74edb2836fe" id="r_a13e81b8f1bf3e1c3572ca74edb2836fe"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a13e81b8f1bf3e1c3572ca74edb2836fe">xLookupCount</a> (const <a class="el" href="structXLookupTable.html">XLookupTable</a> *tab)</td></tr>
<tr class="separator:a13e81b8f1bf3e1c3572ca74edb2836fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3a316b7d0c5c40ed079f3df2d9fcc9" id="r_a5e3a316b7d0c5c40ed079f3df2d9fcc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXField.html">XField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a5e3a316b7d0c5c40ed079f3df2d9fcc9">xLookupField</a> (const <a class="el" href="structXLookupTable.html">XLookupTable</a> *tab, const char *id)</td></tr>
<tr class="separator:a5e3a316b7d0c5c40ed079f3df2d9fcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b423bf135d2ed42319abff99fda78e4" id="r_a3b423bf135d2ed42319abff99fda78e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a3b423bf135d2ed42319abff99fda78e4">xLookupPut</a> (<a class="el" href="structXLookupTable.html">XLookupTable</a> *tab, const char *prefix, const <a class="el" href="structXField.html">XField</a> *field, <a class="el" href="structXField.html">XField</a> **oldValue)</td></tr>
<tr class="separator:a3b423bf135d2ed42319abff99fda78e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a19055586ae79dee6d43c5de0cb32b" id="r_a91a19055586ae79dee6d43c5de0cb32b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a91a19055586ae79dee6d43c5de0cb32b">xLookupPutAll</a> (<a class="el" href="structXLookupTable.html">XLookupTable</a> *tab, const char *prefix, const <a class="el" href="structXStructure.html">XStructure</a> *s, <a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a> recursive)</td></tr>
<tr class="separator:a91a19055586ae79dee6d43c5de0cb32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f2c5443ebef48499398453a39710da" id="r_a85f2c5443ebef48499398453a39710da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXField.html">XField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a85f2c5443ebef48499398453a39710da">xLookupRemove</a> (<a class="el" href="structXLookupTable.html">XLookupTable</a> *tab, const char *id)</td></tr>
<tr class="separator:a85f2c5443ebef48499398453a39710da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4a6ffa5866d770bd21636d00b9d3d7" id="r_add4a6ffa5866d770bd21636d00b9d3d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#add4a6ffa5866d770bd21636d00b9d3d7">xLookupRemoveAll</a> (<a class="el" href="structXLookupTable.html">XLookupTable</a> *tab, const char *prefix, const <a class="el" href="structXStructure.html">XStructure</a> *s, <a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a> recursive)</td></tr>
<tr class="separator:add4a6ffa5866d770bd21636d00b9d3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aae0dafd1d461877eef63c9c730592" id="r_a90aae0dafd1d461877eef63c9c730592"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a90aae0dafd1d461877eef63c9c730592">xMatchNextID</a> (const char *token, const char *id)</td></tr>
<tr class="separator:a90aae0dafd1d461877eef63c9c730592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af436eb535b32fa88ab4e600c0a37c19d" id="r_af436eb535b32fa88ab4e600c0a37c19d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#af436eb535b32fa88ab4e600c0a37c19d">xNextIDToken</a> (const char *id)</td></tr>
<tr class="separator:af436eb535b32fa88ab4e600c0a37c19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994ae91adbbffc3b55b47b0219338282" id="r_a994ae91adbbffc3b55b47b0219338282"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a994ae91adbbffc3b55b47b0219338282">xParseBoolean</a> (char *str, char **end)</td></tr>
<tr class="separator:a994ae91adbbffc3b55b47b0219338282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309b9ae681c40121517672ca50ba665b" id="r_a309b9ae681c40121517672ca50ba665b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a309b9ae681c40121517672ca50ba665b">xParseDims</a> (const char *src, int *sizes)</td></tr>
<tr class="separator:a309b9ae681c40121517672ca50ba665b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2e177c11fe7f44ca5ce11f316c0ad9" id="r_a7e2e177c11fe7f44ca5ce11f316c0ad9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a7e2e177c11fe7f44ca5ce11f316c0ad9">xParseDouble</a> (const char *str, char **tail)</td></tr>
<tr class="separator:a7e2e177c11fe7f44ca5ce11f316c0ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced93c2ca8cef260663ff1f9cfc0140e" id="r_aced93c2ca8cef260663ff1f9cfc0140e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#aced93c2ca8cef260663ff1f9cfc0140e">xPrintDims</a> (char *dst, int ndim, const int *sizes)</td></tr>
<tr class="separator:aced93c2ca8cef260663ff1f9cfc0140e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb8c827cfc2139687d175649284f7be" id="r_a3eb8c827cfc2139687d175649284f7be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a3eb8c827cfc2139687d175649284f7be">xPrintDouble</a> (char *str, double value)</td></tr>
<tr class="separator:a3eb8c827cfc2139687d175649284f7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee406a1c0c8d1076620ae4f77695216" id="r_a9ee406a1c0c8d1076620ae4f77695216"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a9ee406a1c0c8d1076620ae4f77695216">xPrintFloat</a> (char *str, float value)</td></tr>
<tr class="separator:a9ee406a1c0c8d1076620ae4f77695216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc31fe75f06a6e0e469fba3a57c4fb25" id="r_acc31fe75f06a6e0e469fba3a57c4fb25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#acc31fe75f06a6e0e469fba3a57c4fb25">xReduceAllDims</a> (<a class="el" href="structXStructure.html">XStructure</a> *s)</td></tr>
<tr class="separator:acc31fe75f06a6e0e469fba3a57c4fb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fb99b219c5a61db1d1c3d630277987" id="r_a36fb99b219c5a61db1d1c3d630277987"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a36fb99b219c5a61db1d1c3d630277987">xReduceDims</a> (int *ndim, int *sizes)</td></tr>
<tr class="separator:a36fb99b219c5a61db1d1c3d630277987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9f913cdb79d8653668a5d9bdda6ab1" id="r_aec9f913cdb79d8653668a5d9bdda6ab1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXField.html">XField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#aec9f913cdb79d8653668a5d9bdda6ab1">xRemoveField</a> (<a class="el" href="structXStructure.html">XStructure</a> *s, const char *name)</td></tr>
<tr class="separator:aec9f913cdb79d8653668a5d9bdda6ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32d8a3f211a3b101142879ae31146ec" id="r_ad32d8a3f211a3b101142879ae31146ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#ad32d8a3f211a3b101142879ae31146ec">xReverseFieldOrder</a> (<a class="el" href="structXStructure.html">XStructure</a> *s, <a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a> recursive)</td></tr>
<tr class="separator:ad32d8a3f211a3b101142879ae31146ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1304b59a5882b2286e86c6837faead" id="r_a6c1304b59a5882b2286e86c6837faead"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a6c1304b59a5882b2286e86c6837faead">xSetDebug</a> (<a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a> value)</td></tr>
<tr class="separator:a6c1304b59a5882b2286e86c6837faead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cb91bd6aa14c0dae9d24bfbe7b76f4" id="r_ab1cb91bd6aa14c0dae9d24bfbe7b76f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXField.html">XField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#ab1cb91bd6aa14c0dae9d24bfbe7b76f4">xSetField</a> (<a class="el" href="structXStructure.html">XStructure</a> *s, <a class="el" href="structXField.html">XField</a> *f)</td></tr>
<tr class="separator:ab1cb91bd6aa14c0dae9d24bfbe7b76f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84cbb4639f2fbfb604b698a86caf944" id="r_ad84cbb4639f2fbfb604b698a86caf944"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structXField.html">XField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#ad84cbb4639f2fbfb604b698a86caf944">xSetSubstruct</a> (<a class="el" href="structXStructure.html">XStructure</a> *s, const char *name, <a class="el" href="structXStructure.html">XStructure</a> *substruct)</td></tr>
<tr class="separator:ad84cbb4639f2fbfb604b698a86caf944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe85067ddbc92577cd00ac8f6e3026f" id="r_afbe85067ddbc92577cd00ac8f6e3026f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#afbe85067ddbc92577cd00ac8f6e3026f">xSetVerbose</a> (<a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a> value)</td></tr>
<tr class="separator:afbe85067ddbc92577cd00ac8f6e3026f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d006a2788adeb0fc9b4799297a69ff" id="r_aa1d006a2788adeb0fc9b4799297a69ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#aa1d006a2788adeb0fc9b4799297a69ff">xSortFields</a> (<a class="el" href="structXStructure.html">XStructure</a> *s, int(*cmp)(const <a class="el" href="structXField.html">XField</a> **f1, const <a class="el" href="structXField.html">XField</a> **f2), <a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a> recursive)</td></tr>
<tr class="separator:aa1d006a2788adeb0fc9b4799297a69ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d1f6b9b92ebe82353e75a3d7e9daae" id="r_a74d1f6b9b92ebe82353e75a3d7e9daae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a74d1f6b9b92ebe82353e75a3d7e9daae">xSortFieldsByName</a> (<a class="el" href="structXStructure.html">XStructure</a> *s, <a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a> recursive)</td></tr>
<tr class="separator:a74d1f6b9b92ebe82353e75a3d7e9daae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6af91336f4b5501d0a0e3d5cf88ad3" id="r_acd6af91336f4b5501d0a0e3d5cf88ad3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#acd6af91336f4b5501d0a0e3d5cf88ad3">xSplitID</a> (char *id, char **pKey)</td></tr>
<tr class="separator:acd6af91336f4b5501d0a0e3d5cf88ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d730a1a98963816de2dd73e72957a5" id="r_a01d730a1a98963816de2dd73e72957a5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a01d730a1a98963816de2dd73e72957a5">xStringCopyOf</a> (const char *str)</td></tr>
<tr class="separator:a01d730a1a98963816de2dd73e72957a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8816199a4473325a942e14057dcd9ab8" id="r_a8816199a4473325a942e14057dcd9ab8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a8816199a4473325a942e14057dcd9ab8">xStringElementSizeOf</a> (<a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a> type)</td></tr>
<tr class="separator:a8816199a4473325a942e14057dcd9ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b0637ea4bc09f522c67e4c49da13ce" id="r_ae6b0637ea4bc09f522c67e4c49da13ce"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#ae6b0637ea4bc09f522c67e4c49da13ce">xTypeChar</a> (<a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a> type)</td></tr>
<tr class="separator:ae6b0637ea4bc09f522c67e4c49da13ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3605bad086ec39e14f97e42e25334227" id="r_a3605bad086ec39e14f97e42e25334227"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xchange_8h.html#a3605bad086ec39e14f97e42e25334227">xZero</a> (void *buf, <a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a> type, int count)</td></tr>
<tr class="separator:a3605bad086ec39e14f97e42e25334227"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ace21b1dd3eab2ce044a2fea31e393e7b" id="r_ace21b1dd3eab2ce044a2fea31e393e7b"><td class="memItemLeft" align="right" valign="top"><a id="ace21b1dd3eab2ce044a2fea31e393e7b" name="ace21b1dd3eab2ce044a2fea31e393e7b"></a>
<a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><b>xDebug</b></td></tr>
<tr class="memdesc:ace21b1dd3eab2ce044a2fea31e393e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch to enable debugging (very verbose) output for XChange operations. <br /></td></tr>
<tr class="separator:ace21b1dd3eab2ce044a2fea31e393e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363b67b316973290c30c11bea7931c64" id="r_a363b67b316973290c30c11bea7931c64"><td class="memItemLeft" align="right" valign="top"><a id="a363b67b316973290c30c11bea7931c64" name="a363b67b316973290c30c11bea7931c64"></a>
<a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><b>xVerbose</b></td></tr>
<tr class="memdesc:a363b67b316973290c30c11bea7931c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch to enable verbose console output for XChange operations. <br /></td></tr>
<tr class="separator:a363b67b316973290c30c11bea7931c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section date"><dt>Date</dt><dd>Mar 14, 2019 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Attila Kovacs</dd></dl>
<p>A Basic set of utilities to allow platform-independent structured data exchange from C/C++. It also includes a JSON parser and emitter implementation.</p>
<dl class="section version"><dt>Version</dt><dd>0.9.1 </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="abf5d02e3f3ec45ae6fe1e6afd09690a5" name="abf5d02e3f3ec45ae6fe1e6afd09690a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5d02e3f3ec45ae6fe1e6afd09690a5">&#9670;&#160;</a></span>X_FIELD_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define X_FIELD_INIT&#160;&#160;&#160;{NULL, NULL, <a class="el" href="xchange_8h.html#a1f2359ea36bfcb29d936b1eef60a53a3">X_UNKNOWN</a>, NULL, 0, {0}, <a class="el" href="xjson_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, NULL}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Static initializer for the <a class="el" href="structXField.html" title="An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...">XField</a> data structure. </p>

</div>
</div>
<a id="a374255b53a06fcd02222b435d59e220f" name="a374255b53a06fcd02222b435d59e220f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374255b53a06fcd02222b435d59e220f">&#9670;&#160;</a></span>X_STRUCT_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define X_STRUCT_INIT&#160;&#160;&#160;{NULL}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Static initializer for an <a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a> data structure. </p>

</div>
</div>
<a id="a2e8ac004db0f6cb82e1b7a13b79380c5" name="a2e8ac004db0f6cb82e1b7a13b79380c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8ac004db0f6cb82e1b7a13b79380c5">&#9670;&#160;</a></span>XCHANGE_VERSION_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCHANGE_VERSION_STRING</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                  <a class="code hl_define" href="xchange_8h.html#a03b3076533e6967aaa48dcccf9ded4a0">str_2</a>(<a class="code hl_define" href="xchange_8h.html#a13ea68e798d0cd9cab06667707737055">XCHANGE_MAJOR_VERSION</a>) <span class="stringliteral">&quot;.&quot;</span> <a class="code hl_define" href="xchange_8h.html#a03b3076533e6967aaa48dcccf9ded4a0">str_2</a>(<a class="code hl_define" href="xchange_8h.html#a52519844e66bcff3ed17e4feaab76b2f">XCHANGE_MINOR_VERSION</a>) \</div>
<div class="line">                                  <span class="stringliteral">&quot;.&quot;</span> <a class="code hl_define" href="xchange_8h.html#a03b3076533e6967aaa48dcccf9ded4a0">str_2</a>(<a class="code hl_define" href="xchange_8h.html#aef108c611a8388c435502dfd89c41a5f">XCHANGE_PATCHLEVEL</a>) <a class="code hl_define" href="xchange_8h.html#a1cda2967190e2d61c5560bf6b43d930d">XCHANGE_RELEASE_STRING</a></div>
<div class="ttc" id="axchange_8h_html_a03b3076533e6967aaa48dcccf9ded4a0"><div class="ttname"><a href="xchange_8h.html#a03b3076533e6967aaa48dcccf9ded4a0">str_2</a></div><div class="ttdeci">#define str_2(s)</div><div class="ttdoc">Stringify level 2 macro.</div><div class="ttdef"><b>Definition</b> xchange.h:36</div></div>
<div class="ttc" id="axchange_8h_html_a13ea68e798d0cd9cab06667707737055"><div class="ttname"><a href="xchange_8h.html#a13ea68e798d0cd9cab06667707737055">XCHANGE_MAJOR_VERSION</a></div><div class="ttdeci">#define XCHANGE_MAJOR_VERSION</div><div class="ttdoc">API major version.</div><div class="ttdef"><b>Definition</b> xchange.h:19</div></div>
<div class="ttc" id="axchange_8h_html_a1cda2967190e2d61c5560bf6b43d930d"><div class="ttname"><a href="xchange_8h.html#a1cda2967190e2d61c5560bf6b43d930d">XCHANGE_RELEASE_STRING</a></div><div class="ttdeci">#define XCHANGE_RELEASE_STRING</div><div class="ttdoc">Additional release information in version, e.g. &quot;-1&quot;, or &quot;-rc1&quot;.</div><div class="ttdef"><b>Definition</b> xchange.h:28</div></div>
<div class="ttc" id="axchange_8h_html_a52519844e66bcff3ed17e4feaab76b2f"><div class="ttname"><a href="xchange_8h.html#a52519844e66bcff3ed17e4feaab76b2f">XCHANGE_MINOR_VERSION</a></div><div class="ttdeci">#define XCHANGE_MINOR_VERSION</div><div class="ttdoc">API minor version.</div><div class="ttdef"><b>Definition</b> xchange.h:22</div></div>
<div class="ttc" id="axchange_8h_html_aef108c611a8388c435502dfd89c41a5f"><div class="ttname"><a href="xchange_8h.html#aef108c611a8388c435502dfd89c41a5f">XCHANGE_PATCHLEVEL</a></div><div class="ttdeci">#define XCHANGE_PATCHLEVEL</div><div class="ttdoc">Integer sub version of the release.</div><div class="ttdef"><b>Definition</b> xchange.h:25</div></div>
</div><!-- fragment -->
<p>The version string for this library. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3525be19588c2b740fc0dbd54a936dcb" name="a3525be19588c2b740fc0dbd54a936dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3525be19588c2b740fc0dbd54a936dcb">&#9670;&#160;</a></span>xAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * xAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a buffer for a given SMA-X type and element count. The buffer is initialized with zeroes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>SMA-X type </td></tr>
    <tr><td class="paramname">count</td><td>number of elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the initialized buffer or NULL if there was an error (errno will be set accordingly). </dd></dl>

<p class="reference">References <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8c.html#ac39ae03ca89b115d49a12f633522dc31">x_trace_null()</a>, and <a class="el" href="xchange_8c.html#af5ec26d18b20fc0da9ec9032af73fa9e">xElementSizeOf()</a>.</p>

</div>
</div>
<a id="a01a94b3210aed984dbee956fbb26fcfd" name="a01a94b3210aed984dbee956fbb26fcfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a94b3210aed984dbee956fbb26fcfd">&#9670;&#160;</a></span>xAllocLookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXLookupTable.html">XLookupTable</a> * xAllocLookup </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a new lookup with the specified hash size. The hash size should correspond to the number of elements stored in the lookup. If it's larger or roughtly equal to the number of elements to be stored, then the lookup time will stay approximately constant with the number of elements. If the size is much smaller than the number of elements <em>N</em> stored, then the lookup time will scale as <em>O(N/size)</em> typically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of hash bins to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new lookup table, or else NULL if there was an error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xlookup_8c.html#af8bee9eeac947d7e36ea436252e8dc2d">xCreateLookup()</a> </dd>
<dd>
<a class="el" href="xlookup_8c.html#a02ea2d67e4c540ad706edcc1b3a0431e">xDestroyLookup()</a> </dd></dl>

<p class="reference">References <a class="el" href="xjson_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="structXLookupTable.html#a8b6505c37d4ff95854b8b00527e4d9fa">XLookupTable::priv</a>, and <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>.</p>

</div>
</div>
<a id="a2b81d2bbe48788a9741e815cdaa336eb" name="a2b81d2bbe48788a9741e815cdaa336eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b81d2bbe48788a9741e815cdaa336eb">&#9670;&#160;</a></span>xClearField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xClearField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXField.html">XField</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears an X structure field, freeing up all referfenced resources. However, the field itself is kept, but its contents are reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to the field to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#ae0ce99c867b11bd14971031eec8ba4ad">xDestroyField()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXField.html#a5ac083a645d964373f022d03df4849c8">XField::name</a>, <a class="el" href="structXField.html#a2f076846fbd6b30183ba3ab61e3334e5">XField::subtype</a>, <a class="el" href="structXField.html#a6535ecc7e6d29e64f0d34cd926823fd9">XField::type</a>, <a class="el" href="structXField.html#a4e9aec275e566b978a3ccb4e043d8c61">XField::value</a>, <a class="el" href="xchange_8h.html#a7e4c8b651428f090a441804bd8b7673e">X_FIELD</a>, <a class="el" href="xchange_8h.html#a63de1f3edab36b1a53ee312ac0711cbb">X_STRUCT</a>, <a class="el" href="xstruct_8c.html#a2b81d2bbe48788a9741e815cdaa336eb">xClearField()</a>, <a class="el" href="xstruct_8c.html#ae45c0a047c30a17aba84d2fc8c08a2dc">xClearStruct()</a>, and <a class="el" href="xstruct_8c.html#a1720e156de63fd0585224738ccbb5688">xGetFieldCount()</a>.</p>

</div>
</div>
<a id="ae45c0a047c30a17aba84d2fc8c08a2dc" name="ae45c0a047c30a17aba84d2fc8c08a2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45c0a047c30a17aba84d2fc8c08a2dc">&#9670;&#160;</a></span>xClearStruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xClearStruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys the contents of an X structure, leaving the structure empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the structure to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>smaDestroyStruct() </dd></dl>

<p class="reference">References <a class="el" href="structXStructure.html#a501ae8af2201d9cfaa60e3af21ff58fc">XStructure::firstField</a>, <a class="el" href="structXField.html#ae1ebaf87eb62e6266b14908eee28e565">XField::next</a>, and <a class="el" href="xstruct_8c.html#ae0ce99c867b11bd14971031eec8ba4ad">xDestroyField()</a>.</p>

</div>
</div>
<a id="ab20a0213369a947a7e48ff45aabee3c0" name="ab20a0213369a947a7e48ff45aabee3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20a0213369a947a7e48ff45aabee3c0">&#9670;&#160;</a></span>xCopyIDToken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * xCopyIDToken </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a copy of the next next component in a compound ID. Leading ID separators are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Aggregate X ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the start of the next compound ID token, or NULL if there is no more components in the ID. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a923cd66e2074f32817a3468c5617a440">X_SEP</a>, <a class="el" href="xchange_8h.html#a28120364666ec6054159012a58ba27af">X_SEP_LENGTH</a>, and <a class="el" href="xstruct_8c.html#af436eb535b32fa88ab4e600c0a37c19d">xNextIDToken()</a>.</p>

</div>
</div>
<a id="afdb31906269568772fdf63adb6685fbc" name="afdb31906269568772fdf63adb6685fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb31906269568772fdf63adb6685fbc">&#9670;&#160;</a></span>xCopyOfField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXField.html">XField</a> * xCopyOfField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structXField.html">XField</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a deep copy of the supplied field. The returned copy is a standalone field, unlinked to another to avoid corrupting any structure in which the original field may reside in. Note, that this only works with vanilla xchange structures with native storage fields. For example, SMA-X structures store data in serialized forms, and therefore it needs its own implementation for making deep copies of fields!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to the original field or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A fully independent (deep) copy of the argument or NULL if the input field is NULL.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#ad78b2fb3d6d1474c8a44c57575a6e13b">xCopyOfStruct()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXStructure.html#a501ae8af2201d9cfaa60e3af21ff58fc">XStructure::firstField</a>, <a class="el" href="structXField.html#aaa68a7e140a5370ed0eb52710744c341">XField::isSerialized</a>, <a class="el" href="structXField.html#a5ac083a645d964373f022d03df4849c8">XField::name</a>, <a class="el" href="structXField.html#ae1ebaf87eb62e6266b14908eee28e565">XField::next</a>, <a class="el" href="structXField.html#a6535ecc7e6d29e64f0d34cd926823fd9">XField::type</a>, <a class="el" href="structXField.html#a4e9aec275e566b978a3ccb4e043d8c61">XField::value</a>, <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#adb72c72467963a6ace1632638a8a6a7b">X_RAW</a>, <a class="el" href="xchange_8h.html#a2443dd783d2728a3559361fba845e533">X_STRING</a>, <a class="el" href="xchange_8h.html#a63de1f3edab36b1a53ee312ac0711cbb">X_STRUCT</a>, <a class="el" href="xchange_8c.html#ac39ae03ca89b115d49a12f633522dc31">x_trace_null()</a>, <a class="el" href="xstruct_8c.html#ad78b2fb3d6d1474c8a44c57575a6e13b">xCopyOfStruct()</a>, <a class="el" href="xstruct_8c.html#ae0ce99c867b11bd14971031eec8ba4ad">xDestroyField()</a>, <a class="el" href="xchange_8c.html#af5ec26d18b20fc0da9ec9032af73fa9e">xElementSizeOf()</a>, <a class="el" href="xstruct_8c.html#a1720e156de63fd0585224738ccbb5688">xGetFieldCount()</a>, and <a class="el" href="xchange_8c.html#a01d730a1a98963816de2dd73e72957a5">xStringCopyOf()</a>.</p>

</div>
</div>
<a id="ad78b2fb3d6d1474c8a44c57575a6e13b" name="ad78b2fb3d6d1474c8a44c57575a6e13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78b2fb3d6d1474c8a44c57575a6e13b">&#9670;&#160;</a></span>xCopyOfStruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXStructure.html">XStructure</a> * xCopyOfStruct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a deep copy of the supplied structure. Note that this only works with vanilla xchange structures with native storage fields. For example, SMA-X structures store data in serialized forms, and therefore it needs its own implementation for making deep copies of structs!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the original structure or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A fully independent (deep) copy of the argument or NULL if the input structure is NULL.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#afdb31906269568772fdf63adb6685fbc">xCopyOfField()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXStructure.html#a501ae8af2201d9cfaa60e3af21ff58fc">XStructure::firstField</a>, <a class="el" href="structXField.html#ae1ebaf87eb62e6266b14908eee28e565">XField::next</a>, <a class="el" href="structXField.html#a6535ecc7e6d29e64f0d34cd926823fd9">XField::type</a>, <a class="el" href="structXField.html#a4e9aec275e566b978a3ccb4e043d8c61">XField::value</a>, <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a63de1f3edab36b1a53ee312ac0711cbb">X_STRUCT</a>, <a class="el" href="xchange_8c.html#ac39ae03ca89b115d49a12f633522dc31">x_trace_null()</a>, <a class="el" href="xstruct_8c.html#afdb31906269568772fdf63adb6685fbc">xCopyOfField()</a>, <a class="el" href="xstruct_8c.html#a12112584a34e07f9ef7b08f6ef1bc865">xCreateStruct()</a>, <a class="el" href="xstruct_8c.html#afe3fda2f392bae11e136e8c0c90f086d">xDestroyStruct()</a>, and <a class="el" href="xstruct_8c.html#a1720e156de63fd0585224738ccbb5688">xGetFieldCount()</a>.</p>

</div>
</div>
<a id="af7447cdd983402a27a25a70cc7187275" name="af7447cdd983402a27a25a70cc7187275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7447cdd983402a27a25a70cc7187275">&#9670;&#160;</a></span>xCountFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xCountFields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of fields contained inside the structure. It is not recursive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the structure to investigate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of fields cotnained in the structure (but not counting fields in sub-structures).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#a789489313df89d33aa50de911e1e42ff">xDeepCountFields()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXStructure.html#a501ae8af2201d9cfaa60e3af21ff58fc">XStructure::firstField</a>, and <a class="el" href="structXField.html#ae1ebaf87eb62e6266b14908eee28e565">XField::next</a>.</p>

</div>
</div>
<a id="a9897f06ef8a22d5ddb8538d5fe223ae2" name="a9897f06ef8a22d5ddb8538d5fe223ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9897f06ef8a22d5ddb8538d5fe223ae2">&#9670;&#160;</a></span>xCreate1DField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXField.html">XField</a> * xCreate1DField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a generic field for a 1D array of a given name and native data. The structure will hold a copy of the value that is pointed at.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Field name (it may not contain a separator X_SEP) </td></tr>
    <tr><td class="paramname">type</td><td>Storage type, e.g. X_INT. </td></tr>
    <tr><td class="paramname">count</td><td>Number of elements in array </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to an array of native values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created field with the supplied data, or NULL if there was an error. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8c.html#ac39ae03ca89b115d49a12f633522dc31">x_trace_null()</a>, and <a class="el" href="xstruct_8c.html#a42e4e75cbf8f721ef4b251c692dcd7cb">xCreateField()</a>.</p>

</div>
</div>
<a id="ad2fa86a7d296f1efa6b41079bc2a6b65" name="ad2fa86a7d296f1efa6b41079bc2a6b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fa86a7d296f1efa6b41079bc2a6b65">&#9670;&#160;</a></span>xCreateBooleanField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXField.html">XField</a> * xCreateBooleanField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a field holding a single boolean value value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Field name (it may not contain a separator X_SEP) </td></tr>
    <tr><td class="paramname">value</td><td>Associated value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created field with the supplied data, or NULL if there was an error. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8h.html#abe0465f7669775b6129551a7ef3300bc">X_BOOLEAN</a>, <a class="el" href="xchange_8c.html#ac39ae03ca89b115d49a12f633522dc31">x_trace_null()</a>, and <a class="el" href="xstruct_8c.html#a965f7e58fd1c10570c6f6a472599b08f">xCreateScalarField()</a>.</p>

</div>
</div>
<a id="ab7ac206d0ec3608a0872f09c7f7bc189" name="ab7ac206d0ec3608a0872f09c7f7bc189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ac206d0ec3608a0872f09c7f7bc189">&#9670;&#160;</a></span>xCreateDoubleField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXField.html">XField</a> * xCreateDoubleField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a field holding a single double-precision value value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Field name (it may not contain a separator X_SEP) </td></tr>
    <tr><td class="paramname">value</td><td>Associated value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created field with the supplied data, or NULL if there was an error. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8h.html#a849c7ccb02f63d8554323a889a3d8b4d">X_DOUBLE</a>, <a class="el" href="xchange_8c.html#ac39ae03ca89b115d49a12f633522dc31">x_trace_null()</a>, and <a class="el" href="xstruct_8c.html#a965f7e58fd1c10570c6f6a472599b08f">xCreateScalarField()</a>.</p>

</div>
</div>
<a id="a42e4e75cbf8f721ef4b251c692dcd7cb" name="a42e4e75cbf8f721ef4b251c692dcd7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e4e75cbf8f721ef4b251c692dcd7cb">&#9670;&#160;</a></span>xCreateField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXField.html">XField</a> * xCreateField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a generic field of a given name and type and dimensions using a copy of the specified native data, unless type is X_STRUCT in which case the value is referenced directly inside the field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Field name (it may not contain a separator X_SEP) </td></tr>
    <tr><td class="paramname">type</td><td>Storage type, e.g. X_INT. </td></tr>
    <tr><td class="paramname">ndim</td><td>Number of dimensionas (1:20). If ndim &lt; 1, it will be reinterpreted as ndim=1, size[0]=1; </td></tr>
    <tr><td class="paramname">sizes</td><td>Array of sizes along each dimensions, with at least ndim elements, or NULL with ndim&lt;1. </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the native data location in memory, or NULL to leave unassigned for now.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created field with the copy of the supplied data, or NULL if there was an error. </dd></dl>

<p class="reference">References <a class="el" href="structXField.html#a5ac083a645d964373f022d03df4849c8">XField::name</a>, <a class="el" href="structXField.html#a0d9c8cbc461c7cf86cad8e548f195bd1">XField::ndim</a>, <a class="el" href="structXField.html#af743830ee6c7d5e81a0206b07238ca5d">XField::sizes</a>, <a class="el" href="structXField.html#a6535ecc7e6d29e64f0d34cd926823fd9">XField::type</a>, <a class="el" href="structXField.html#a4e9aec275e566b978a3ccb4e043d8c61">XField::value</a>, <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a910ee1c8cd983bf127f7ca2c705d7894">X_MAX_DIMS</a>, <a class="el" href="xchange_8h.html#adb72c72467963a6ace1632638a8a6a7b">X_RAW</a>, <a class="el" href="xchange_8h.html#a2443dd783d2728a3559361fba845e533">X_STRING</a>, <a class="el" href="xchange_8h.html#a63de1f3edab36b1a53ee312ac0711cbb">X_STRUCT</a>, <a class="el" href="xstruct_8c.html#ae0ce99c867b11bd14971031eec8ba4ad">xDestroyField()</a>, <a class="el" href="xchange_8c.html#af5ec26d18b20fc0da9ec9032af73fa9e">xElementSizeOf()</a>, <a class="el" href="xchange_8c.html#ad35e0d8c0ebbb4948c233f96c54bd8d6">xGetElementCount()</a>, <a class="el" href="xstruct_8c.html#ab9a9fbc1235164bfeed5fbba1f7d8692">xLastSeparator()</a>, and <a class="el" href="xchange_8c.html#a01d730a1a98963816de2dd73e72957a5">xStringCopyOf()</a>.</p>

</div>
</div>
<a id="aa4405d56659397e044b6d4fdda394dfa" name="aa4405d56659397e044b6d4fdda394dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4405d56659397e044b6d4fdda394dfa">&#9670;&#160;</a></span>xCreateIntField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXField.html">XField</a> * xCreateIntField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a field holding a single ineger value value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Field name (it may not contain a separator X_SEP) </td></tr>
    <tr><td class="paramname">value</td><td>Associated value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created field with the supplied data, or NULL if there was an error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#a4587dcd0157acce30373288e19f1237d">xCreateLongField()</a> </dd></dl>

<p class="reference">References <a class="el" href="xchange_8h.html#a4003d7fe06200f77805c52cc7db56784">X_INT</a>, <a class="el" href="xchange_8c.html#ac39ae03ca89b115d49a12f633522dc31">x_trace_null()</a>, and <a class="el" href="xstruct_8c.html#a965f7e58fd1c10570c6f6a472599b08f">xCreateScalarField()</a>.</p>

</div>
</div>
<a id="a4587dcd0157acce30373288e19f1237d" name="a4587dcd0157acce30373288e19f1237d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4587dcd0157acce30373288e19f1237d">&#9670;&#160;</a></span>xCreateLongField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXField.html">XField</a> * xCreateLongField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a field holding a single ineger value value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Field name (it may not contain a separator X_SEP) </td></tr>
    <tr><td class="paramname">value</td><td>Associated value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created field with the supplied data, or NULL if there was an error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#aa4405d56659397e044b6d4fdda394dfa">xCreateIntField()</a> </dd></dl>

<p class="reference">References <a class="el" href="xchange_8h.html#a36405f1834eb7cd51a17f103b2942e21">X_LONG</a>, <a class="el" href="xchange_8c.html#ac39ae03ca89b115d49a12f633522dc31">x_trace_null()</a>, and <a class="el" href="xstruct_8c.html#a965f7e58fd1c10570c6f6a472599b08f">xCreateScalarField()</a>.</p>

</div>
</div>
<a id="af8bee9eeac947d7e36ea436252e8dc2d" name="af8bee9eeac947d7e36ea436252e8dc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bee9eeac947d7e36ea436252e8dc2d">&#9670;&#160;</a></span>xCreateLookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXLookupTable.html">XLookupTable</a> * xCreateLookup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a>&#160;</td>
          <td class="paramname"><em>recursive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a fast name lookup table for the fields of structure, with or without including fields of embedded substructures also. For structures with a large number of fields, such a lookup can significantly improve access times for retrieving specific fields from a structure. However, the lookup will not track fields added or removed after its creation, and so it is suited for accessing structures with a fixed layout only.</p>
<p>Since the lookup table contains references to the structure, you should not destroy the structure as long as the lookup table is used.</p>
<p>Once the lookup table is no longer used, the caller should explicitly destroy it with <code><a class="el" href="xlookup_8c.html#a02ea2d67e4c540ad706edcc1b3a0431e">xDestroyLookup()</a></code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to a structure, for which to create a field lookup. </td></tr>
    <tr><td class="paramname">recursive</td><td>Whether to include fields from substructures recursively in the lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lookup table, or NULL if there was an error (errno will inform about the type of error).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xlookup_8c.html#a5e3a316b7d0c5c40ed079f3df2d9fcc9">xLookupField()</a> </dd>
<dd>
<a class="el" href="xlookup_8c.html#a02ea2d67e4c540ad706edcc1b3a0431e">xDestroyLookup()</a> </dd></dl>

<p class="reference">References <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8c.html#ac39ae03ca89b115d49a12f633522dc31">x_trace_null()</a>, <a class="el" href="xlookup_8c.html#a01a94b3210aed984dbee956fbb26fcfd">xAllocLookup()</a>, <a class="el" href="xstruct_8c.html#af7447cdd983402a27a25a70cc7187275">xCountFields()</a>, and <a class="el" href="xstruct_8c.html#a789489313df89d33aa50de911e1e42ff">xDeepCountFields()</a>.</p>

</div>
</div>
<a id="a5b7c0e588603da8bd8893807408f51e3" name="a5b7c0e588603da8bd8893807408f51e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7c0e588603da8bd8893807408f51e3">&#9670;&#160;</a></span>xCreateMixed1DField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXField.html">XField</a> * xCreateMixed1DField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structXField.html">XField</a> *&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a field containing a 1D array of heterogeneous fields. Each element of the array may have a different type and/or size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the array field </td></tr>
    <tr><td class="paramname">size</td><td>The number of heterogeneous fields in the array. </td></tr>
    <tr><td class="paramname">array</td><td>The <a class="el" href="structXField.html" title="An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...">XField</a> array of rows containing varying types and dimensions within them. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A field containing a heterogeneous array of entries, or NULL if there was an error. The entries are initially empty, except for their names bearing '.' followed by the 1-based array index, e.g. '.1', '.2'...</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#a7bb186343d1ff6dab01cc39e233b9069">xCreateMixedArrayField()</a> </dd></dl>

<p class="reference">References <a class="el" href="xchange_8h.html#a910ee1c8cd983bf127f7ca2c705d7894">X_MAX_DIMS</a>, and <a class="el" href="xstruct_8c.html#a7bb186343d1ff6dab01cc39e233b9069">xCreateMixedArrayField()</a>.</p>

</div>
</div>
<a id="acf0823001995982977fe1e07b088c953" name="acf0823001995982977fe1e07b088c953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0823001995982977fe1e07b088c953">&#9670;&#160;</a></span>xCreateMixedArrayField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXField.html">XField</a> * xCreateMixedArrayField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structXField.html">XField</a> *&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a field containing an array of heterogeneous fields. Each element of the array may have a different type and/or size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the array field </td></tr>
    <tr><td class="paramname">ndim</td><td>The dimensionality of the heterogeneous components </td></tr>
    <tr><td class="paramname">sizes</td><td>The individual sizes along each dimension </td></tr>
    <tr><td class="paramname">array</td><td>The <a class="el" href="structXField.html" title="An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...">XField</a> array of elements containing varying types and dimensions within them. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A field containing a heterogeneous array of entries, or NULL if there was an error. The entries are initially empty, except for their names bearing '.' followed by the 1-based array index, e.g. '.1', '.2'...</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#a0b37b00634177189d5e717e3c84820e3">xCreateMixed1DField()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXField.html#a5ac083a645d964373f022d03df4849c8">XField::name</a>, <a class="el" href="xchange_8h.html#a7e4c8b651428f090a441804bd8b7673e">X_FIELD</a>, <a class="el" href="xchange_8c.html#ac39ae03ca89b115d49a12f633522dc31">x_trace_null()</a>, <a class="el" href="xstruct_8c.html#a42e4e75cbf8f721ef4b251c692dcd7cb">xCreateField()</a>, <a class="el" href="xchange_8c.html#ad35e0d8c0ebbb4948c233f96c54bd8d6">xGetElementCount()</a>, and <a class="el" href="xchange_8c.html#a01d730a1a98963816de2dd73e72957a5">xStringCopyOf()</a>.</p>

</div>
</div>
<a id="a965f7e58fd1c10570c6f6a472599b08f" name="a965f7e58fd1c10570c6f6a472599b08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a965f7e58fd1c10570c6f6a472599b08f">&#9670;&#160;</a></span>xCreateScalarField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXField.html">XField</a> * xCreateScalarField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a generic scalar field of a given name and native value. The structure will hold a copy of the value that is pointed at.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Field name (it may not contain a separator X_SEP) </td></tr>
    <tr><td class="paramname">type</td><td>Storage type, e.g. X_INT. </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the native data location in memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created field with the supplied data, or NULL if there was an error. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8c.html#ac39ae03ca89b115d49a12f633522dc31">x_trace_null()</a>, and <a class="el" href="xstruct_8c.html#a42e4e75cbf8f721ef4b251c692dcd7cb">xCreateField()</a>.</p>

</div>
</div>
<a id="a9dc77bed0d8b738ba615019721a6a2b6" name="a9dc77bed0d8b738ba615019721a6a2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc77bed0d8b738ba615019721a6a2b6">&#9670;&#160;</a></span>xCreateStringField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXField.html">XField</a> * xCreateStringField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a field holding a single string value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Field name (it may not contain a separator X_SEP) </td></tr>
    <tr><td class="paramname">value</td><td>Associated value. NULL values will be treated as empty strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created field referencing the supplied string, or NULL if there was an error. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8h.html#a2443dd783d2728a3559361fba845e533">X_STRING</a>, <a class="el" href="xchange_8c.html#ac39ae03ca89b115d49a12f633522dc31">x_trace_null()</a>, and <a class="el" href="xstruct_8c.html#a965f7e58fd1c10570c6f6a472599b08f">xCreateScalarField()</a>.</p>

</div>
</div>
<a id="a12112584a34e07f9ef7b08f6ef1bc865" name="a12112584a34e07f9ef7b08f6ef1bc865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12112584a34e07f9ef7b08f6ef1bc865">&#9670;&#160;</a></span>xCreateStruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXStructure.html">XStructure</a> * xCreateStruct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new empty <a class="el" href="structXStructure.html" title="SMA-X structure object, containing a linked-list of XField elements.">XStructure</a>.</p>
<dl class="section see"><dt>See also</dt><dd>smaxDestroyStruct() </dd></dl>

</div>
</div>
<a id="a789489313df89d33aa50de911e1e42ff" name="a789489313df89d33aa50de911e1e42ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789489313df89d33aa50de911e1e42ff">&#9670;&#160;</a></span>xDeepCountFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long xDeepCountFields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counts the number of fields in a structure, including the field count for all embedded substructures also recursively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to a structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of fields present in the structure and all its sub-structures.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#af7447cdd983402a27a25a70cc7187275">xCountFields()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXStructure.html#a501ae8af2201d9cfaa60e3af21ff58fc">XStructure::firstField</a>, <a class="el" href="structXField.html#a5ac083a645d964373f022d03df4849c8">XField::name</a>, <a class="el" href="structXField.html#ae1ebaf87eb62e6266b14908eee28e565">XField::next</a>, <a class="el" href="structXField.html#a6535ecc7e6d29e64f0d34cd926823fd9">XField::type</a>, <a class="el" href="structXField.html#a4e9aec275e566b978a3ccb4e043d8c61">XField::value</a>, <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a63de1f3edab36b1a53ee312ac0711cbb">X_STRUCT</a>, <a class="el" href="xchange_8c.html#a9b61b8b8b3ef0f7cc0b96ab499265c74">x_trace()</a>, <a class="el" href="xstruct_8c.html#a789489313df89d33aa50de911e1e42ff">xDeepCountFields()</a>, and <a class="el" href="xstruct_8c.html#a1720e156de63fd0585224738ccbb5688">xGetFieldCount()</a>.</p>

</div>
</div>
<a id="ae0ce99c867b11bd14971031eec8ba4ad" name="ae0ce99c867b11bd14971031eec8ba4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ce99c867b11bd14971031eec8ba4ad">&#9670;&#160;</a></span>xDestroyField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xDestroyField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXField.html">XField</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys an X structure field, freeing up all referenced resources, and destroying the field itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to the field to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#a2b81d2bbe48788a9741e815cdaa336eb">xClearField()</a> </dd></dl>

<p class="reference">References <a class="el" href="xstruct_8c.html#a2b81d2bbe48788a9741e815cdaa336eb">xClearField()</a>.</p>

</div>
</div>
<a id="a02ea2d67e4c540ad706edcc1b3a0431e" name="a02ea2d67e4c540ad706edcc1b3a0431e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ea2d67e4c540ad706edcc1b3a0431e">&#9670;&#160;</a></span>xDestroyLookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xDestroyLookup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXLookupTable.html">XLookupTable</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys a lookup table, freeing up it's in-memory resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>Pointer to the lookup table to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xlookup_8c.html#af8bee9eeac947d7e36ea436252e8dc2d">xCreateLookup()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXLookupTable.html#a8b6505c37d4ff95854b8b00527e4d9fa">XLookupTable::priv</a>.</p>

</div>
</div>
<a id="afe3fda2f392bae11e136e8c0c90f086d" name="afe3fda2f392bae11e136e8c0c90f086d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3fda2f392bae11e136e8c0c90f086d">&#9670;&#160;</a></span>xDestroyStruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xDestroyStruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys an X structure, freeing up resources used by name and value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the structure to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="xstruct_8c.html#ae45c0a047c30a17aba84d2fc8c08a2dc">xClearStruct()</a>.</p>

</div>
</div>
<a id="af5ec26d18b20fc0da9ec9032af73fa9e" name="af5ec26d18b20fc0da9ec9032af73fa9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ec26d18b20fc0da9ec9032af73fa9e">&#9670;&#160;</a></span>xElementSizeOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xElementSizeOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the storage byte size of a single element of a given type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The data type, as defined in '<a class="el" href="xchange_8h.html">xchange.h</a>'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>[bytes] the native storage size of a single element of that type. E.g. for X_CHAR(20) it will return 20. X_DOUBLE will return 8, etc. Unrecognised types will return 0. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8h.html#abe0465f7669775b6129551a7ef3300bc">X_BOOLEAN</a>, <a class="el" href="xchange_8h.html#afb01219635d162589ae5aadb90702bb0">X_BYTE</a>, <a class="el" href="xchange_8h.html#a849c7ccb02f63d8554323a889a3d8b4d">X_DOUBLE</a>, <a class="el" href="xchange_8h.html#a7e4c8b651428f090a441804bd8b7673e">X_FIELD</a>, <a class="el" href="xchange_8h.html#a99605e05158426b1b44e924e42a1162c">X_FLOAT</a>, <a class="el" href="xchange_8h.html#a4003d7fe06200f77805c52cc7db56784">X_INT</a>, <a class="el" href="xchange_8h.html#a36405f1834eb7cd51a17f103b2942e21">X_LONG</a>, <a class="el" href="xchange_8h.html#adb72c72467963a6ace1632638a8a6a7b">X_RAW</a>, <a class="el" href="xchange_8h.html#adfdc22097b12d42c040dcce8700d64b8">X_SHORT</a>, <a class="el" href="xchange_8h.html#a2443dd783d2728a3559361fba845e533">X_STRING</a>, and <a class="el" href="xchange_8h.html#a63de1f3edab36b1a53ee312ac0711cbb">X_STRUCT</a>.</p>

</div>
</div>
<a id="a606c4844e51124bee155e30bac8ca885" name="a606c4844e51124bee155e30bac8ca885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606c4844e51124bee155e30bac8ca885">&#9670;&#160;</a></span>xError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xError </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a descriptive error message to stderr, and returns the error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>String that describes the function or location where the error occurred. </td></tr>
    <tr><td class="paramname">code</td><td>The xchange error code that describes the failure (see <a class="el" href="xchange_8h.html">xchange.h</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same error code as specified on input. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8h.html#a9e947ab368178c7e248b3cf8b26defa1">X_ALREADY_OPEN</a>, <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a1d4a0c99f979fd0ecf0e9dcb7191a8d7">X_FAILURE</a>, <a class="el" href="xchange_8h.html#a48c78a0e8290b2fd3701031ebce3fa15">X_GROUP_INVALID</a>, <a class="el" href="xchange_8h.html#a888dbfa464548f0b65794e172713160b">X_INCOMPLETE</a>, <a class="el" href="xchange_8h.html#a3942401de37f774e72393ffa73c9fb9f">X_INTERRUPTED</a>, <a class="el" href="xchange_8h.html#a5426366367d169401f779c4764ba7736">X_NAME_INVALID</a>, <a class="el" href="xchange_8h.html#a0783aebbbcc863bf212273131709ad3c">X_NO_BLOCKED_READ</a>, <a class="el" href="xchange_8h.html#a1324cef45d5b26097bf488ad3b7f9e7b">X_NO_INIT</a>, <a class="el" href="xchange_8h.html#a385df18f40a243b7c3d3d0b4ffbdb336">X_NO_PIPELINE</a>, <a class="el" href="xchange_8h.html#a7aeb707470a6d1a45626c123e84abe86">X_NO_SERVICE</a>, <a class="el" href="xchange_8h.html#a2e8ccb371c640d2b79a16bb6bdd13cc4">X_NOT_ENOUGH_TOKENS</a>, <a class="el" href="xchange_8h.html#aadbbe3ae01369cbddf4d57d430b33133">X_NULL</a>, <a class="el" href="xchange_8h.html#a86d83cc351dfae22fe7346559f5a440e">X_PARSE_ERROR</a>, <a class="el" href="xchange_8h.html#a816c5dad11d9bfd91a795ed1af30e732">X_SIZE_INVALID</a>, <a class="el" href="xchange_8h.html#a7b2679c964ea5f2160380ed55654b873">X_SUCCESS</a>, <a class="el" href="xchange_8h.html#ad525869626b4f755aa27d6ef37a15c3d">X_TIMEDOUT</a>, and <a class="el" href="xchange_8h.html#aecc19edf892709b39a9c0d3d944f8f9a">X_TYPE_INVALID</a>.</p>

</div>
</div>
<a id="acc701c734a3b95d356660ca5ee16a96a" name="acc701c734a3b95d356660ca5ee16a96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc701c734a3b95d356660ca5ee16a96a">&#9670;&#160;</a></span>xErrorDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * xErrorDescription </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a string description for one of the standard X-change error codes, and sets errno as appropriate also. (The mapping to error codes is not one-to-one. The same errno may be used to describe different X-change errors. Nevertheless, it is a guide that can be used when the X-change error is not directtly available, e.g. because it is not returned by a given function.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>One of the error codes defined in '<a class="el" href="xchange_8h.html">xchange.h</a>'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant string with the error description. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8h.html#a9e947ab368178c7e248b3cf8b26defa1">X_ALREADY_OPEN</a>, <a class="el" href="xchange_8h.html#a1d4a0c99f979fd0ecf0e9dcb7191a8d7">X_FAILURE</a>, <a class="el" href="xchange_8h.html#a48c78a0e8290b2fd3701031ebce3fa15">X_GROUP_INVALID</a>, <a class="el" href="xchange_8h.html#a888dbfa464548f0b65794e172713160b">X_INCOMPLETE</a>, <a class="el" href="xchange_8h.html#a3942401de37f774e72393ffa73c9fb9f">X_INTERRUPTED</a>, <a class="el" href="xchange_8h.html#a5426366367d169401f779c4764ba7736">X_NAME_INVALID</a>, <a class="el" href="xchange_8h.html#a0783aebbbcc863bf212273131709ad3c">X_NO_BLOCKED_READ</a>, <a class="el" href="xchange_8h.html#a1324cef45d5b26097bf488ad3b7f9e7b">X_NO_INIT</a>, <a class="el" href="xchange_8h.html#a385df18f40a243b7c3d3d0b4ffbdb336">X_NO_PIPELINE</a>, <a class="el" href="xchange_8h.html#a7aeb707470a6d1a45626c123e84abe86">X_NO_SERVICE</a>, <a class="el" href="xchange_8h.html#a2e8ccb371c640d2b79a16bb6bdd13cc4">X_NOT_ENOUGH_TOKENS</a>, <a class="el" href="xchange_8h.html#aadbbe3ae01369cbddf4d57d430b33133">X_NULL</a>, <a class="el" href="xchange_8h.html#a86d83cc351dfae22fe7346559f5a440e">X_PARSE_ERROR</a>, <a class="el" href="xchange_8h.html#a816c5dad11d9bfd91a795ed1af30e732">X_SIZE_INVALID</a>, <a class="el" href="xchange_8h.html#a7b2679c964ea5f2160380ed55654b873">X_SUCCESS</a>, <a class="el" href="xchange_8h.html#ad525869626b4f755aa27d6ef37a15c3d">X_TIMEDOUT</a>, and <a class="el" href="xchange_8h.html#aecc19edf892709b39a9c0d3d944f8f9a">X_TYPE_INVALID</a>.</p>

</div>
</div>
<a id="a32e104d7a23090f8ae0e6ea3cc55a84f" name="a32e104d7a23090f8ae0e6ea3cc55a84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e104d7a23090f8ae0e6ea3cc55a84f">&#9670;&#160;</a></span>xGetAggregateID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * xGetAggregateID </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the aggregated (hierarchical) &lt;table&gt;:&lt;key&gt; ID. The caller is responsible for calling free() on the returned string after use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>SMA-X hastable name </td></tr>
    <tr><td class="paramname">key</td><td>The lower-level id to concatenate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The aggregated ID, or NULL if both arguments were NULL themselves.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#acd6af91336f4b5501d0a0e3d5cf88ad3">xSplitID()</a> </dd></dl>

<p class="reference">References <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a923cd66e2074f32817a3468c5617a440">X_SEP</a>, <a class="el" href="xchange_8h.html#a28120364666ec6054159012a58ba27af">X_SEP_LENGTH</a>, and <a class="el" href="xchange_8c.html#a01d730a1a98963816de2dd73e72957a5">xStringCopyOf()</a>.</p>

</div>
</div>
<a id="ad35e0d8c0ebbb4948c233f96c54bd8d6" name="ad35e0d8c0ebbb4948c233f96c54bd8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35e0d8c0ebbb4948c233f96c54bd8d6">&#9670;&#160;</a></span>xGetElementCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xGetElementCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the total element count specified by along a number of dimensions. It ignores dimensions that have size components &lt;= 0;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ndim</td><td>Number of dimensions </td></tr>
    <tr><td class="paramname">sizes</td><td>Sizes along each dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total element count specified by the dimensions. Defaults to 1. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, and <a class="el" href="xchange_8h.html#a910ee1c8cd983bf127f7ca2c705d7894">X_MAX_DIMS</a>.</p>

</div>
</div>
<a id="ad3f1d50fc0f1553b806bedbd17d2206e" name="ad3f1d50fc0f1553b806bedbd17d2206e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f1d50fc0f1553b806bedbd17d2206e">&#9670;&#160;</a></span>xGetField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXField.html">XField</a> * xGetField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the field by the specified name, or NULL if no such field exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Structure from which to retrieve a given field. </td></tr>
    <tr><td class="paramname">id</td><td>Name or aggregate ID of the field to retrieve</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matching field from the structure or NULL if there is no match or one of the arguments is NULL.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xlookup_8c.html#a5e3a316b7d0c5c40ed079f3df2d9fcc9">xLookupField()</a> </dd>
<dd>
<a class="el" href="xstruct_8c.html#ab1cb91bd6aa14c0dae9d24bfbe7b76f4">xSetField()</a> </dd>
<dd>
<a class="el" href="xstruct_8c.html#a97a58e33c4730e272af459dfb7f016f9">xGetSubstruct()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXStructure.html#a501ae8af2201d9cfaa60e3af21ff58fc">XStructure::firstField</a>, <a class="el" href="structXField.html#a5ac083a645d964373f022d03df4849c8">XField::name</a>, <a class="el" href="structXField.html#ae1ebaf87eb62e6266b14908eee28e565">XField::next</a>, <a class="el" href="structXField.html#a6535ecc7e6d29e64f0d34cd926823fd9">XField::type</a>, <a class="el" href="structXField.html#a4e9aec275e566b978a3ccb4e043d8c61">XField::value</a>, <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a63de1f3edab36b1a53ee312ac0711cbb">X_STRUCT</a>, <a class="el" href="xchange_8h.html#a7b2679c964ea5f2160380ed55654b873">X_SUCCESS</a>, <a class="el" href="xstruct_8c.html#a442f155b0c6549549737510ce42bb66d">xGetField()</a>, <a class="el" href="xstruct_8c.html#a90aae0dafd1d461877eef63c9c730592">xMatchNextID()</a>, and <a class="el" href="xstruct_8c.html#af436eb535b32fa88ab4e600c0a37c19d">xNextIDToken()</a>.</p>

</div>
</div>
<a id="a1720e156de63fd0585224738ccbb5688" name="a1720e156de63fd0585224738ccbb5688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1720e156de63fd0585224738ccbb5688">&#9670;&#160;</a></span>xGetFieldCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xGetFieldCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structXField.html">XField</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the total number of primitive elements in a field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of primitive elements contained in the field. </dd></dl>

<p class="reference">References <a class="el" href="structXField.html#a0d9c8cbc461c7cf86cad8e548f195bd1">XField::ndim</a>, <a class="el" href="structXField.html#af743830ee6c7d5e81a0206b07238ca5d">XField::sizes</a>, and <a class="el" href="xchange_8c.html#ad35e0d8c0ebbb4948c233f96c54bd8d6">xGetElementCount()</a>.</p>

</div>
</div>
<a id="a97a58e33c4730e272af459dfb7f016f9" name="a97a58e33c4730e272af459dfb7f016f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a58e33c4730e272af459dfb7f016f9">&#9670;&#160;</a></span>xGetSubstruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXStructure.html">XStructure</a> * xGetSubstruct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a substructure by the specified name, or NULL if no such sub-structure exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Structure from which to retrieve a given sub-structure. </td></tr>
    <tr><td class="paramname">id</td><td>Name or aggregate ID of the substructure to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matching sub-structure from the structure or NULL if there is no match or one of the arguments is NULL.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#ad84cbb4639f2fbfb604b698a86caf944">xSetSubstruct()</a> </dd>
<dd>
<a class="el" href="xstruct_8c.html#a442f155b0c6549549737510ce42bb66d">xGetField()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXField.html#a6535ecc7e6d29e64f0d34cd926823fd9">XField::type</a>, <a class="el" href="structXField.html#a4e9aec275e566b978a3ccb4e043d8c61">XField::value</a>, <a class="el" href="xchange_8h.html#a63de1f3edab36b1a53ee312ac0711cbb">X_STRUCT</a>, and <a class="el" href="xstruct_8c.html#a442f155b0c6549549737510ce42bb66d">xGetField()</a>.</p>

</div>
</div>
<a id="adcc86baacb3ddebcc529e269223274b8" name="adcc86baacb3ddebcc529e269223274b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc86baacb3ddebcc529e269223274b8">&#9670;&#160;</a></span>xIsCharSequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a> xIsCharSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the type represents a fixed-size character / binary sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>X-Change type to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if it is a type for a (fixed size) character array, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="aec6e78e07733ca246ca485b0fcf02d21" name="aec6e78e07733ca246ca485b0fcf02d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6e78e07733ca246ca485b0fcf02d21">&#9670;&#160;</a></span>xIsFieldValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a> xIsFieldValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structXField.html">XField</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a given field has valid data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to the field to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE is the field seems to contain valid data, otherwise FALSE. </dd></dl>

<p class="reference">References <a class="el" href="xjson_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="structXField.html#a5ac083a645d964373f022d03df4849c8">XField::name</a>, <a class="el" href="structXField.html#a0d9c8cbc461c7cf86cad8e548f195bd1">XField::ndim</a>, <a class="el" href="structXField.html#af743830ee6c7d5e81a0206b07238ca5d">XField::sizes</a>, <a class="el" href="xjson_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="el" href="structXField.html#a6535ecc7e6d29e64f0d34cd926823fd9">XField::type</a>, <a class="el" href="structXField.html#a4e9aec275e566b978a3ccb4e043d8c61">XField::value</a>, <a class="el" href="xchange_8h.html#a63de1f3edab36b1a53ee312ac0711cbb">X_STRUCT</a>, <a class="el" href="xchange_8c.html#af5ec26d18b20fc0da9ec9032af73fa9e">xElementSizeOf()</a>, and <a class="el" href="xstruct_8c.html#ab9a9fbc1235164bfeed5fbba1f7d8692">xLastSeparator()</a>.</p>

</div>
</div>
<a id="a46a6c2d802ebadd46ffcfdde7fb438b8" name="a46a6c2d802ebadd46ffcfdde7fb438b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a6c2d802ebadd46ffcfdde7fb438b8">&#9670;&#160;</a></span>xIsVerbose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a> xIsVerbose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if verbosity is enabled for the xchange library.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE (1) if verbosity is enabled, or else FALSE (0).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xchange_8c.html#afbe85067ddbc92577cd00ac8f6e3026f">xSetVerbose()</a> </dd>
<dd>
<a class="el" href="xchange_8c.html#a6c1304b59a5882b2286e86c6837faead">xSetDebug()</a> </dd></dl>

<p class="reference">References <a class="el" href="xchange_8c.html#a363b67b316973290c30c11bea7931c64">xVerbose</a>.</p>

</div>
</div>
<a id="ab9a9fbc1235164bfeed5fbba1f7d8692" name="ab9a9fbc1235164bfeed5fbba1f7d8692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a9fbc1235164bfeed5fbba1f7d8692">&#9670;&#160;</a></span>xLastSeparator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * xLastSeparator </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the string pointer to the begining of the last separator in the ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Compound SMA-X ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the beginning of the last separator in the ID, or NULL if the ID does not contain a separator.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#acd6af91336f4b5501d0a0e3d5cf88ad3">xSplitID()</a> </dd></dl>

<p class="reference">References <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a923cd66e2074f32817a3468c5617a440">X_SEP</a>, and <a class="el" href="xchange_8h.html#a28120364666ec6054159012a58ba27af">X_SEP_LENGTH</a>.</p>

</div>
</div>
<a id="a13e81b8f1bf3e1c3572ca74edb2836fe" name="a13e81b8f1bf3e1c3572ca74edb2836fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e81b8f1bf3e1c3572ca74edb2836fe">&#9670;&#160;</a></span>xLookupCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long xLookupCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structXLookupTable.html">XLookupTable</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of fields in the lookup table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>Pointer to the lookup table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of fields stored. </dd></dl>

<p class="reference">References <a class="el" href="structXLookupTable.html#a8b6505c37d4ff95854b8b00527e4d9fa">XLookupTable::priv</a>.</p>

</div>
</div>
<a id="a5e3a316b7d0c5c40ed079f3df2d9fcc9" name="a5e3a316b7d0c5c40ed079f3df2d9fcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3a316b7d0c5c40ed079f3df2d9fcc9">&#9670;&#160;</a></span>xLookupField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXField.html">XField</a> * xLookupField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structXLookupTable.html">XLookupTable</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a named field from a lookup table. When retriving a large number (hundreds or more) fields by name from very large structures, this methods of locating the relevant data can be significantly faster than the <a class="el" href="xstruct_8c.html#a442f155b0c6549549737510ce42bb66d">xGetField()</a> / <a class="el" href="xstruct_8c.html#a97a58e33c4730e272af459dfb7f016f9">xGetSubstruct()</a> approach.</p>
<p>Note however, that preparing the lookup table has significant <em>O(N)</em> computational cost also, whereas retrieving <em>M</em> fields with <a class="el" href="xstruct_8c.html#a442f155b0c6549549737510ce42bb66d">xGetField()</a> / <a class="el" href="xstruct_8c.html#a97a58e33c4730e272af459dfb7f016f9">xGetSubstruct()</a> have costs that scale <em>O(N&times;M)</em>. Therefore, a lookup table is practical only if you are going to use it repeatedly, many times over. As a rule of thumb, lookups may have the advantage if accessing fields in a structure by name hundreds of times, or more.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>Pointer to the lookup table </td></tr>
    <tr><td class="paramname">id</td><td>The aggregate ID of the field to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding field or NULL if no such field exists or tab was NULL.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xlookup_8c.html#af8bee9eeac947d7e36ea436252e8dc2d">xCreateLookup()</a> </dd>
<dd>
<a class="el" href="xstruct_8c.html#a442f155b0c6549549737510ce42bb66d">xGetField()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXLookupTable.html#a8b6505c37d4ff95854b8b00527e4d9fa">XLookupTable::priv</a>, and <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>.</p>

</div>
</div>
<a id="a3b423bf135d2ed42319abff99fda78e4" name="a3b423bf135d2ed42319abff99fda78e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b423bf135d2ed42319abff99fda78e4">&#9670;&#160;</a></span>xLookupPut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xLookupPut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXLookupTable.html">XLookupTable</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structXField.html">XField</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structXField.html">XField</a> **&#160;</td>
          <td class="paramname"><em>oldValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Puts a field into the lookup table with the specified aggregate ID prefix. For example, if the prefix is "system:subsystem", and the field's name is "property", then the field will be available as "system:subsystem:property" in the lookup.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>Pointer to a lookup table </td></tr>
    <tr><td class="paramname">prefix</td><td>The aggregate ID prefix before the field's name, not including a separator </td></tr>
    <tr><td class="paramname">field</td><td>The field </td></tr>
    <tr><td class="paramname">oldValue</td><td>(optional) pointer to a buffer in which to return the old field value (if any) stored under the same name. It may be NULL if not needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully added a new field, 1 if updated an existing fields, or else X_NULL if either of the arguments were NULL, or X_FAILURE if some other error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xlookup_8c.html#a91a19055586ae79dee6d43c5de0cb32b">xLookupPutAll()</a> </dd>
<dd>
<a class="el" href="xlookup_8c.html#a85f2c5443ebef48499398453a39710da">xLookupRemove()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXLookupTable.html#a8b6505c37d4ff95854b8b00527e4d9fa">XLookupTable::priv</a>, <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a1d4a0c99f979fd0ecf0e9dcb7191a8d7">X_FAILURE</a>, and <a class="el" href="xchange_8h.html#aadbbe3ae01369cbddf4d57d430b33133">X_NULL</a>.</p>

</div>
</div>
<a id="a91a19055586ae79dee6d43c5de0cb32b" name="a91a19055586ae79dee6d43c5de0cb32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a19055586ae79dee6d43c5de0cb32b">&#9670;&#160;</a></span>xLookupPutAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xLookupPutAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXLookupTable.html">XLookupTable</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a>&#160;</td>
          <td class="paramname"><em>recursive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Puts all fields from a structure into the lookup table with the specified aggregate ID prefix, with or without including embedded substructures. For example, if the prefix is "system:subsystem", and a field's name is "property", then that field will be available as "system:subsystem:property" in the lookup.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>Pointer to a lookup table </td></tr>
    <tr><td class="paramname">prefix</td><td>The aggregate ID prefix before the field's name, not including a separator </td></tr>
    <tr><td class="paramname">s</td><td>The structure </td></tr>
    <tr><td class="paramname">recursive</td><td>Whether to include fields in all substructures recursively also. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of fields added (&lt;=0), or else X_NULL if either of the arguments were NULL, or X_FAILURE if some other error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xlookup_8c.html#add4a6ffa5866d770bd21636d00b9d3d7">xLookupRemoveAll()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXLookupTable.html#a8b6505c37d4ff95854b8b00527e4d9fa">XLookupTable::priv</a>, <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a1d4a0c99f979fd0ecf0e9dcb7191a8d7">X_FAILURE</a>, and <a class="el" href="xchange_8h.html#aadbbe3ae01369cbddf4d57d430b33133">X_NULL</a>.</p>

</div>
</div>
<a id="a85f2c5443ebef48499398453a39710da" name="a85f2c5443ebef48499398453a39710da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f2c5443ebef48499398453a39710da">&#9670;&#160;</a></span>xLookupRemove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXField.html">XField</a> * xLookupRemove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXLookupTable.html">XLookupTable</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a field from a lookup table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>Pointer to the lookup table </td></tr>
    <tr><td class="paramname">id</td><td>The aggregate ID of the field as stored in the lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The field that was removed, or else NULL if not found.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xlookup_8c.html#add4a6ffa5866d770bd21636d00b9d3d7">xLookupRemoveAll()</a> </dd>
<dd>
<a class="el" href="xlookup_8c.html#a3b423bf135d2ed42319abff99fda78e4">xLookupPut()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXLookupTable.html#a8b6505c37d4ff95854b8b00527e4d9fa">XLookupTable::priv</a>, <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, and <a class="el" href="xchange_8h.html#aadbbe3ae01369cbddf4d57d430b33133">X_NULL</a>.</p>

</div>
</div>
<a id="add4a6ffa5866d770bd21636d00b9d3d7" name="add4a6ffa5866d770bd21636d00b9d3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4a6ffa5866d770bd21636d00b9d3d7">&#9670;&#160;</a></span>xLookupRemoveAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xLookupRemoveAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXLookupTable.html">XLookupTable</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a>&#160;</td>
          <td class="paramname"><em>recursive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all fields of a structure from the lookup table with the specified aggregate ID prefix, with or without including embedded substructures. For example, if the prefix is "system:subsystem", and a field's name is "property", then the field referred to as "system:subsystem:property" in the lookup is affected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>Pointer to a lookup table </td></tr>
    <tr><td class="paramname">prefix</td><td>The aggregate ID prefix before the field's name, not including a separator </td></tr>
    <tr><td class="paramname">s</td><td>The structure </td></tr>
    <tr><td class="paramname">recursive</td><td>Whether to include fields in all substructures recursively also. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of fields removed (&lt;=0), or else X_NULL if either of the arguments were NULL, or X_FAILURE if some other error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xlookup_8c.html#add4a6ffa5866d770bd21636d00b9d3d7">xLookupRemoveAll()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXLookupTable.html#a8b6505c37d4ff95854b8b00527e4d9fa">XLookupTable::priv</a>, <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a1d4a0c99f979fd0ecf0e9dcb7191a8d7">X_FAILURE</a>, and <a class="el" href="xchange_8h.html#aadbbe3ae01369cbddf4d57d430b33133">X_NULL</a>.</p>

</div>
</div>
<a id="a90aae0dafd1d461877eef63c9c730592" name="a90aae0dafd1d461877eef63c9c730592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90aae0dafd1d461877eef63c9c730592">&#9670;&#160;</a></span>xMatchNextID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xMatchNextID </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the next component in a compound id matches a given token.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>Full token to check for </td></tr>
    <tr><td class="paramname">id</td><td>Compount X ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X_SUCCESS if it's a match. Otherwise X_FAILURE or another X error if the arguments are invalid. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a1d4a0c99f979fd0ecf0e9dcb7191a8d7">X_FAILURE</a>, <a class="el" href="xchange_8h.html#a48c78a0e8290b2fd3701031ebce3fa15">X_GROUP_INVALID</a>, <a class="el" href="xchange_8h.html#a5426366367d169401f779c4764ba7736">X_NAME_INVALID</a>, <a class="el" href="xchange_8h.html#aadbbe3ae01369cbddf4d57d430b33133">X_NULL</a>, <a class="el" href="xchange_8h.html#a923cd66e2074f32817a3468c5617a440">X_SEP</a>, <a class="el" href="xchange_8h.html#a28120364666ec6054159012a58ba27af">X_SEP_LENGTH</a>, and <a class="el" href="xchange_8h.html#a7b2679c964ea5f2160380ed55654b873">X_SUCCESS</a>.</p>

</div>
</div>
<a id="af436eb535b32fa88ab4e600c0a37c19d" name="af436eb535b32fa88ab4e600c0a37c19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af436eb535b32fa88ab4e600c0a37c19d">&#9670;&#160;</a></span>xNextIDToken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * xNextIDToken </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the beginning of the next component in a compound ID. Leading ID separators are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Aggregate X ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the start of the next compound ID token, or NULL if there is no more components in the ID. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8h.html#a923cd66e2074f32817a3468c5617a440">X_SEP</a>, and <a class="el" href="xchange_8h.html#a28120364666ec6054159012a58ba27af">X_SEP_LENGTH</a>.</p>

</div>
</div>
<a id="a994ae91adbbffc3b55b47b0219338282" name="a994ae91adbbffc3b55b47b0219338282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994ae91adbbffc3b55b47b0219338282">&#9670;&#160;</a></span>xParseBoolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a> xParseBoolean </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a boolean value, either as a zero/non-zero number or as a case-insensitive match to the next token to one of the recognized boolean terms, such as "true"/"false", "on"/"off", "yes"/"no", "t"/"f", "y"/"n", "enabled"/"disabled" or "active"/"inactive". If a boolean value cannot be matched, FALSE is returned, and errno is set to ERANGE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to the string token. </td></tr>
    <tr><td class="paramname">end</td><td>Where the pointer to after the successfully parsed token is returned, on NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE (1) or FALSE (0). </dd></dl>

<p class="reference">References <a class="el" href="xjson_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="xjson_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, and <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>.</p>

</div>
</div>
<a id="a309b9ae681c40121517672ca50ba665b" name="a309b9ae681c40121517672ca50ba665b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309b9ae681c40121517672ca50ba665b">&#9670;&#160;</a></span>xParseDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xParseDims </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deserializes the sizes from a space-separated list of dimensions. The parsing will terminate at the first non integer value or the end of string, whichever comes first. Integer values &lt;= 0 are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Pointer to a string buffer that contains the serialized dimensions, as a list of space separated integers. </td></tr>
    <tr><td class="paramname">sizes</td><td>Pointer to an array of ints (usually of X_MAX_DIMS size) to which the valid dimensions are deserialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of valid (i.e. positive) dimensions parsed. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, and <a class="el" href="xchange_8h.html#a910ee1c8cd983bf127f7ca2c705d7894">X_MAX_DIMS</a>.</p>

</div>
</div>
<a id="a7e2e177c11fe7f44ca5ce11f316c0ad9" name="a7e2e177c11fe7f44ca5ce11f316c0ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2e177c11fe7f44ca5ce11f316c0ad9">&#9670;&#160;</a></span>xParseDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double xParseDouble </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as strtod() on C99, but with explicit parsing of NaN and Infinity values on older platforms also.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to parse floating-point value from </td></tr>
    <tr><td class="paramname">tail</td><td>(optional) reference to pointed in which to return the parse position after successfully parsing a floating-point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the floating-point value at the head of the string, or NAN if the input string is NULL. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8h.html#a956e2723d559858d08644ac99146e910">INFINITY</a>, <a class="el" href="xchange_8h.html#a8abfcc76130f3f991d124dd22d7e69bc">NAN</a>, and <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>.</p>

</div>
</div>
<a id="aced93c2ca8cef260663ff1f9cfc0140e" name="aced93c2ca8cef260663ff1f9cfc0140e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced93c2ca8cef260663ff1f9cfc0140e">&#9670;&#160;</a></span>xPrintDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xPrintDims </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serializes the dimensions to a string as a space-separated list of integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>Pointer to a string buffer with at least X_MAX_STRING_DIMS bytes size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ndim</td><td>Number of dimensions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>Sizes along each dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters written into the destination buffer, not counting the string termination, or -1 if an the essential pointer arguments is NULL. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, and <a class="el" href="xchange_8h.html#a910ee1c8cd983bf127f7ca2c705d7894">X_MAX_DIMS</a>.</p>

</div>
</div>
<a id="a3eb8c827cfc2139687d175649284f7be" name="a3eb8c827cfc2139687d175649284f7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb8c827cfc2139687d175649284f7be">&#9670;&#160;</a></span>xPrintDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xPrintDouble </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a double precision number, restricted to IEEE double-precision range. If the native value has abolute value smaller than the smallest non-zero value, then 0 will printed instead. For values that exceed the IEEE double precision range, "nan" will be printed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to buffer for printed value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters printed into the buffer, or -1 if there was an error. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>.</p>

</div>
</div>
<a id="a9ee406a1c0c8d1076620ae4f77695216" name="a9ee406a1c0c8d1076620ae4f77695216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee406a1c0c8d1076620ae4f77695216">&#9670;&#160;</a></span>xPrintFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xPrintFloat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a single-precision number, restricted to IEEE single-precision range. If the native value has abolute value smaller than the smallest non-zero value, then 0 will printed instead. For values that exceed the IEEE double precision range, "nan" will be printed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to buffer for printed value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters printed into the buffer. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>.</p>

</div>
</div>
<a id="acc31fe75f06a6e0e469fba3a57c4fb25" name="acc31fe75f06a6e0e469fba3a57c4fb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc31fe75f06a6e0e469fba3a57c4fb25">&#9670;&#160;</a></span>xReduceAllDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xReduceAllDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively eliminates unneccessary embedding of singular structures inside a structure as well as reduces the dimension of all array fields with <a class="el" href="xstruct_8c.html#a36fb99b219c5a61db1d1c3d630277987">xReduceDims()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to a structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X_SUCCESS (0) if successful or else X_STRUCT_INVALID if the argument is NULL (errno is also set to EINVAL)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#a36fb99b219c5a61db1d1c3d630277987">xReduceDims()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXStructure.html#a501ae8af2201d9cfaa60e3af21ff58fc">XStructure::firstField</a>, <a class="el" href="structXField.html#a5ac083a645d964373f022d03df4849c8">XField::name</a>, <a class="el" href="structXField.html#a0d9c8cbc461c7cf86cad8e548f195bd1">XField::ndim</a>, <a class="el" href="structXField.html#ae1ebaf87eb62e6266b14908eee28e565">XField::next</a>, <a class="el" href="structXStructure.html#a82ba053944ce97d83d41c05f68ec4f3d">XStructure::parent</a>, <a class="el" href="structXField.html#af743830ee6c7d5e81a0206b07238ca5d">XField::sizes</a>, <a class="el" href="structXField.html#a6535ecc7e6d29e64f0d34cd926823fd9">XField::type</a>, <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a63de1f3edab36b1a53ee312ac0711cbb">X_STRUCT</a>, <a class="el" href="xchange_8h.html#af4b6e6d9baf3e6767041faa3e356af7a">X_STRUCT_INVALID</a>, <a class="el" href="xchange_8c.html#a9b61b8b8b3ef0f7cc0b96ab499265c74">x_trace()</a>, <a class="el" href="xstruct_8c.html#a1720e156de63fd0585224738ccbb5688">xGetFieldCount()</a>, <a class="el" href="xstruct_8c.html#acc31fe75f06a6e0e469fba3a57c4fb25">xReduceAllDims()</a>, and <a class="el" href="xstruct_8c.html#a36fb99b219c5a61db1d1c3d630277987">xReduceDims()</a>.</p>

</div>
</div>
<a id="a36fb99b219c5a61db1d1c3d630277987" name="a36fb99b219c5a61db1d1c3d630277987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fb99b219c5a61db1d1c3d630277987">&#9670;&#160;</a></span>xReduceDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xReduceDims </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reduces the dimensions by eliminating axes that contain a singular elements. Thus a size of {1, 3, 1, 5} will reduce to {3, 5} containing the same number of elements, in fewer dimensions. If any of the dimensions are zero then it reduces to { 0 }.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ndim</td><td>Pointer to the dimensions (will be updated in situ) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sizes</td><td>Array of sizes along the dimensions (will be updated in situ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X_SUCCESS (0) if successful or else X_SIZE_INVALID if the ndim argument is NULL, or if it is greater than zero but the sizes argument is NULL (errno set to EINVAL in both cases)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#acc31fe75f06a6e0e469fba3a57c4fb25">xReduceAllDims()</a> </dd></dl>

<p class="reference">References <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a816c5dad11d9bfd91a795ed1af30e732">X_SIZE_INVALID</a>, and <a class="el" href="xchange_8h.html#a7b2679c964ea5f2160380ed55654b873">X_SUCCESS</a>.</p>

</div>
</div>
<a id="aec9f913cdb79d8653668a5d9bdda6ab1" name="aec9f913cdb79d8653668a5d9bdda6ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9f913cdb79d8653668a5d9bdda6ab1">&#9670;&#160;</a></span>xRemoveField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXField.html">XField</a> * xRemoveField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes as field from the structure, returning it if found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to structure </td></tr>
    <tr><td class="paramname">name</td><td>Name of field to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the removed field or else NULL if the was an error or if no matching field existed in the structure. </dd></dl>

<p class="reference">References <a class="el" href="structXStructure.html#a501ae8af2201d9cfaa60e3af21ff58fc">XStructure::firstField</a>, <a class="el" href="structXField.html#a5ac083a645d964373f022d03df4849c8">XField::name</a>, <a class="el" href="structXField.html#ae1ebaf87eb62e6266b14908eee28e565">XField::next</a>, <a class="el" href="structXStructure.html#a82ba053944ce97d83d41c05f68ec4f3d">XStructure::parent</a>, <a class="el" href="structXField.html#a6535ecc7e6d29e64f0d34cd926823fd9">XField::type</a>, <a class="el" href="structXField.html#a4e9aec275e566b978a3ccb4e043d8c61">XField::value</a>, <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a63de1f3edab36b1a53ee312ac0711cbb">X_STRUCT</a>, and <a class="el" href="xstruct_8c.html#a1720e156de63fd0585224738ccbb5688">xGetFieldCount()</a>.</p>

</div>
</div>
<a id="ad32d8a3f211a3b101142879ae31146ec" name="ad32d8a3f211a3b101142879ae31146ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32d8a3f211a3b101142879ae31146ec">&#9670;&#160;</a></span>xReverseFieldOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xReverseFieldOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a>&#160;</td>
          <td class="paramname"><em>recursive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reverse the order of fields in a structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The structure, whose field order to reverse. </td></tr>
    <tr><td class="paramname">recursive</td><td>Whether to apply the reversal to all ebmbedded substructures also </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X_SUCCESS (0) if successful, or else X_NULL if the structure is NULL.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#aa1d006a2788adeb0fc9b4799297a69ff">xSortFields()</a> </dd>
<dd>
<a class="el" href="xstruct_8c.html#a74d1f6b9b92ebe82353e75a3d7e9daae">xSortFieldsByName()</a> </dd>
<dd>
<a class="el" href="xstruct_8c.html#ad6249db6da0a1294d5621cd9fd829f7a">xInsertField()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXStructure.html#a501ae8af2201d9cfaa60e3af21ff58fc">XStructure::firstField</a>, <a class="el" href="structXField.html#ae1ebaf87eb62e6266b14908eee28e565">XField::next</a>, <a class="el" href="xjson_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="el" href="structXField.html#a6535ecc7e6d29e64f0d34cd926823fd9">XField::type</a>, <a class="el" href="structXField.html#a4e9aec275e566b978a3ccb4e043d8c61">XField::value</a>, <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#aadbbe3ae01369cbddf4d57d430b33133">X_NULL</a>, <a class="el" href="xchange_8h.html#a63de1f3edab36b1a53ee312ac0711cbb">X_STRUCT</a>, <a class="el" href="xchange_8h.html#a7b2679c964ea5f2160380ed55654b873">X_SUCCESS</a>, <a class="el" href="xstruct_8c.html#a1720e156de63fd0585224738ccbb5688">xGetFieldCount()</a>, and <a class="el" href="xstruct_8c.html#ad32d8a3f211a3b101142879ae31146ec">xReverseFieldOrder()</a>.</p>

</div>
</div>
<a id="a6c1304b59a5882b2286e86c6837faead" name="a6c1304b59a5882b2286e86c6837faead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1304b59a5882b2286e86c6837faead">&#9670;&#160;</a></span>xSetDebug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xSetDebug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables or disables debugging output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>TRUE (non-zero) to enable verbose output, or else FALSE (0).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xchange_8c.html#afbe85067ddbc92577cd00ac8f6e3026f">xSetVerbose()</a> </dd></dl>

<p class="reference">References <a class="el" href="xjson_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="xjson_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, and <a class="el" href="xchange_8c.html#ace21b1dd3eab2ce044a2fea31e393e7b">xDebug</a>.</p>

</div>
</div>
<a id="ab1cb91bd6aa14c0dae9d24bfbe7b76f4" name="ab1cb91bd6aa14c0dae9d24bfbe7b76f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1cb91bd6aa14c0dae9d24bfbe7b76f4">&#9670;&#160;</a></span>xSetField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXField.html">XField</a> * xSetField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structXField.html">XField</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds or replaces a field in the structure with the specified field value, returning the previous value for the same field. It is up to the caller whether or not the old value should be destoyed or kept. Note though that you should check first to see if the replaced field is the same as the new one before attempting to destroy...</p>
<p>The field's name may not contain a compound ID. To add fields to embedded sub-structures, you may want to use <a class="el" href="xstruct_8c.html#a97a58e33c4730e272af459dfb7f016f9">xGetSubstruct()</a> first to add the field directly to the relevant embedded component.</p>
<p>A note of caution: There is no safeguard against adding the same field to more than one structure, which will result in a corruption of the affected structures, since both structures would link to the field, but the field links to only one specific successive element. Therefore, the user is responsible to ensure that fields are assigned to structures uniquely, and if necessary remove the field from one structure before assigning it to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Structure to which to add the field </td></tr>
    <tr><td class="paramname">f</td><td>Field to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Previous field by the same name, or NULL if the field is new or if there was an error (errno will be set to EINVAL)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#ad6249db6da0a1294d5621cd9fd829f7a">xInsertField()</a> </dd>
<dd>
<a class="el" href="xstruct_8c.html#ad84cbb4639f2fbfb604b698a86caf944">xSetSubstruct()</a> </dd>
<dd>
<a class="el" href="xstruct_8c.html#a97a58e33c4730e272af459dfb7f016f9">xGetSubstruct()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXStructure.html#a501ae8af2201d9cfaa60e3af21ff58fc">XStructure::firstField</a>, <a class="el" href="structXField.html#a5ac083a645d964373f022d03df4849c8">XField::name</a>, <a class="el" href="structXField.html#ae1ebaf87eb62e6266b14908eee28e565">XField::next</a>, and <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>.</p>

</div>
</div>
<a id="ad84cbb4639f2fbfb604b698a86caf944" name="ad84cbb4639f2fbfb604b698a86caf944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84cbb4639f2fbfb604b698a86caf944">&#9670;&#160;</a></span>xSetSubstruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structXField.html">XField</a> * xSetSubstruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>substruct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a structure within a parent structure, returning the old field that may have existed under the requested name before.</p>
<p>The name may not contain a compound ID. To add the structure to embedded sub-structures, you may want to use <a class="el" href="xstruct_8c.html#a97a58e33c4730e272af459dfb7f016f9">xGetSubstruct()</a> first to add the new structure directly to the relevant embedded component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the parent structure </td></tr>
    <tr><td class="paramname">name</td><td>Name of the sub-structure </td></tr>
    <tr><td class="paramname">substruct</td><td>Pointer to the sub-structure. It is added directly as a reference, without making a copy.</td></tr>
  </table>
  </dd>
</dl>
<p>return The prior field stored under the same name or NULL. If there is an error then NULL is returned and errno is set to indicate the nature of the issue. (a message is also printed to stderr if xDebug is enabled.)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#a97a58e33c4730e272af459dfb7f016f9">xGetSubstruct()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXStructure.html#a82ba053944ce97d83d41c05f68ec4f3d">XStructure::parent</a>, <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a63de1f3edab36b1a53ee312ac0711cbb">X_STRUCT</a>, <a class="el" href="xchange_8c.html#ac39ae03ca89b115d49a12f633522dc31">x_trace_null()</a>, <a class="el" href="xstruct_8c.html#a965f7e58fd1c10570c6f6a472599b08f">xCreateScalarField()</a>, and <a class="el" href="xstruct_8c.html#ab1cb91bd6aa14c0dae9d24bfbe7b76f4">xSetField()</a>.</p>

</div>
</div>
<a id="afbe85067ddbc92577cd00ac8f6e3026f" name="afbe85067ddbc92577cd00ac8f6e3026f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe85067ddbc92577cd00ac8f6e3026f">&#9670;&#160;</a></span>xSetVerbose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xSetVerbose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets verbose output for the xchange library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>TRUE (non-zero) to enable verbose output, or else FALSE (0).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xchange_8c.html#a46a6c2d802ebadd46ffcfdde7fb438b8">xIsVerbose()</a> </dd></dl>

<p class="reference">References <a class="el" href="xjson_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="xjson_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, and <a class="el" href="xchange_8c.html#a363b67b316973290c30c11bea7931c64">xVerbose</a>.</p>

</div>
</div>
<a id="aa1d006a2788adeb0fc9b4799297a69ff" name="aa1d006a2788adeb0fc9b4799297a69ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d006a2788adeb0fc9b4799297a69ff">&#9670;&#160;</a></span>xSortFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xSortFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const <a class="el" href="structXField.html">XField</a> **f1, const <a class="el" href="structXField.html">XField</a> **f2)&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a>&#160;</td>
          <td class="paramname"><em>recursive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the fields in a structure using a specific comparator function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The structure, whose fields to sort </td></tr>
    <tr><td class="paramname">cmp</td><td>The comparator function. It takes two pointers to <a class="el" href="structXField.html" title="An SMA-X field, typically as part of an XStructure. A field may be a reference to a nested XStructure...">XField</a> locations as arguments. </td></tr>
    <tr><td class="paramname">recursive</td><td>Whether to apply the sorting to all ebmbedded substructures also </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X_SUCCESS (0) if successful, or else X_NULL if the structure or the comparator function is NULL.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#a74d1f6b9b92ebe82353e75a3d7e9daae">xSortFieldsByName()</a> </dd>
<dd>
<a class="el" href="xstruct_8c.html#ad32d8a3f211a3b101142879ae31146ec">xReverseFieldOrder()</a> </dd></dl>

<p class="reference">References <a class="el" href="structXStructure.html#a501ae8af2201d9cfaa60e3af21ff58fc">XStructure::firstField</a>, <a class="el" href="structXField.html#ae1ebaf87eb62e6266b14908eee28e565">XField::next</a>, <a class="el" href="xjson_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="el" href="structXField.html#a6535ecc7e6d29e64f0d34cd926823fd9">XField::type</a>, <a class="el" href="structXField.html#a4e9aec275e566b978a3ccb4e043d8c61">XField::value</a>, <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#aadbbe3ae01369cbddf4d57d430b33133">X_NULL</a>, <a class="el" href="xchange_8h.html#a63de1f3edab36b1a53ee312ac0711cbb">X_STRUCT</a>, <a class="el" href="xchange_8h.html#a7b2679c964ea5f2160380ed55654b873">X_SUCCESS</a>, <a class="el" href="xstruct_8c.html#a1720e156de63fd0585224738ccbb5688">xGetFieldCount()</a>, and <a class="el" href="xstruct_8c.html#aa1d006a2788adeb0fc9b4799297a69ff">xSortFields()</a>.</p>

</div>
</div>
<a id="a74d1f6b9b92ebe82353e75a3d7e9daae" name="a74d1f6b9b92ebe82353e75a3d7e9daae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d1f6b9b92ebe82353e75a3d7e9daae">&#9670;&#160;</a></span>xSortFieldsByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xSortFieldsByName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXStructure.html">XStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a621c38f1f10a1c565d897e3178b16d6e">boolean</a>&#160;</td>
          <td class="paramname"><em>recursive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the fields of a structure by field name, in ascending alphabetical order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The structure, whose fields to sort </td></tr>
    <tr><td class="paramname">recursive</td><td>Whether to apply the sorting to all ebmbedded substructures also </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X_SUCCESS (0) if successful, or else X_NULL if the structure is NULL.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#ad32d8a3f211a3b101142879ae31146ec">xReverseFieldOrder()</a> </dd></dl>

<p class="reference">References <a class="el" href="xchange_8h.html#a7b2679c964ea5f2160380ed55654b873">X_SUCCESS</a>, and <a class="el" href="xstruct_8c.html#aa1d006a2788adeb0fc9b4799297a69ff">xSortFields()</a>.</p>

</div>
</div>
<a id="acd6af91336f4b5501d0a0e3d5cf88ad3" name="acd6af91336f4b5501d0a0e3d5cf88ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6af91336f4b5501d0a0e3d5cf88ad3">&#9670;&#160;</a></span>xSplitID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xSplitID </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>pKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Splits the id into two strings (sharing the same input buffer): (1) the id of the embedding structure, and (2) the embedded field name. The original input id is string terminated after the table name. And the pointer to the key part that follows after the last separator is returned in the second (optional argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">id</td><td>String containing an aggregate ID, which will be terminated after the last substructure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pKey</td><td>Returned pointer to the second component after the separator within the same buffer. This is not an independent pointer. Use <a class="el" href="xchange_8c.html#a01d730a1a98963816de2dd73e72957a5">xStringCopyOf()</a> if you need an idependent string on which free() can be called! The returned value pointed to may be NULL if the ID could not be split. The argument may also be null, in which case the input string is just terminated at the stem, without returning the second part.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X_SUCCESS (0) if the ID was successfully split into two components. X_NULL if the id argument is NULL. X_NAME_INVALID if no separator was found</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xstruct_8c.html#a2cbbd824406d862b2018e28a466ff318">xGetAggregateID()</a> </dd>
<dd>
<a class="el" href="xstruct_8c.html#ab9a9fbc1235164bfeed5fbba1f7d8692">xLastSeparator()</a> </dd></dl>

<p class="reference">References <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a5426366367d169401f779c4764ba7736">X_NAME_INVALID</a>, <a class="el" href="xchange_8h.html#aadbbe3ae01369cbddf4d57d430b33133">X_NULL</a>, <a class="el" href="xchange_8h.html#a28120364666ec6054159012a58ba27af">X_SEP_LENGTH</a>, <a class="el" href="xchange_8h.html#a7b2679c964ea5f2160380ed55654b873">X_SUCCESS</a>, and <a class="el" href="xstruct_8c.html#ab9a9fbc1235164bfeed5fbba1f7d8692">xLastSeparator()</a>.</p>

</div>
</div>
<a id="a01d730a1a98963816de2dd73e72957a5" name="a01d730a1a98963816de2dd73e72957a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d730a1a98963816de2dd73e72957a5">&#9670;&#160;</a></span>xStringCopyOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * xStringCopyOf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a freshly allocated string with the same content as the argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to string we want to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the supplied string, or NULL if the argument itself was NULL. </dd></dl>

</div>
</div>
<a id="a8816199a4473325a942e14057dcd9ab8" name="a8816199a4473325a942e14057dcd9ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8816199a4473325a942e14057dcd9ab8">&#9670;&#160;</a></span>xStringElementSizeOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xStringElementSizeOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of characters, including a '\0' termination that a single element of the might be expected to fill.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>X-Change type to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters (including termination) required for the string representation of an element of the given variable, or 0 if the variable is of unknown type. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8h.html#abe0465f7669775b6129551a7ef3300bc">X_BOOLEAN</a>, <a class="el" href="xchange_8h.html#afb01219635d162589ae5aadb90702bb0">X_BYTE</a>, <a class="el" href="xchange_8h.html#a849c7ccb02f63d8554323a889a3d8b4d">X_DOUBLE</a>, <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>, <a class="el" href="xchange_8h.html#a99605e05158426b1b44e924e42a1162c">X_FLOAT</a>, <a class="el" href="xchange_8h.html#a4003d7fe06200f77805c52cc7db56784">X_INT</a>, <a class="el" href="xchange_8h.html#a36405f1834eb7cd51a17f103b2942e21">X_LONG</a>, and <a class="el" href="xchange_8h.html#adfdc22097b12d42c040dcce8700d64b8">X_SHORT</a>.</p>

</div>
</div>
<a id="ae6b0637ea4bc09f522c67e4c49da13ce" name="ae6b0637ea4bc09f522c67e4c49da13ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b0637ea4bc09f522c67e4c49da13ce">&#9670;&#160;</a></span>xTypeChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char xTypeChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the character of the field type. For X_CHAR types it returns 'C' (without the length specification), and for all other types it returns the constant XType value itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The single-character IF of the field type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A character that represented the type. </dd></dl>

<p class="reference">References <a class="el" href="xchange_8c.html#ae73aaf705dc4e7d58dfb0fd81f4805c7">x_error()</a>.</p>

</div>
</div>
<a id="a3605bad086ec39e14f97e42e25334227" name="a3605bad086ec39e14f97e42e25334227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3605bad086ec39e14f97e42e25334227">&#9670;&#160;</a></span>xZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xZero </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xchange_8h.html#a1c7e02eda23566a7891310fd09307a70">XType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Zeroes out the contents of an SMA-X buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the buffer to fill with zeroes. </td></tr>
    <tr><td class="paramname">type</td><td>SMA-X type </td></tr>
    <tr><td class="paramname">count</td><td>number of elements. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="xchange_8c.html#af5ec26d18b20fc0da9ec9032af73fa9e">xElementSizeOf()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="xchange_8h.html">xchange.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
