.TH "src/super.c" 3 "Version v1.2" "SuperNOVAS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/super.c
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "double \fBapp_to_cirs_ra\fP (double jd_tt, enum \fBnovas_accuracy\fP accuracy, double ra)"
.br
.ti -1c
.RI "double \fBcirs_to_app_ra\fP (double jd_tt, enum \fBnovas_accuracy\fP accuracy, double ra)"
.br
.ti -1c
.RI "int \fBcirs_to_itrs\fP (double jd_tt_high, double jd_tt_low, double ut1_to_tt, enum \fBnovas_accuracy\fP accuracy, double xp, double yp, const double *in, double *out)"
.br
.ti -1c
.RI "int \fBcirs_to_tod\fP (double jd_tt, enum \fBnovas_accuracy\fP accuracy, const double *in, double *out)"
.br
.ti -1c
.RI "int \fBecl2equ\fP (double jd_tt, enum \fBnovas_equator_type\fP coord_sys, enum \fBnovas_accuracy\fP accuracy, double elon, double elat, double *ra, double *dec)"
.br
.ti -1c
.RI "int \fBgal2equ\fP (double glon, double glat, double *ra, double *dec)"
.br
.ti -1c
.RI "double \fBget_ut1_to_tt\fP (int leap_seconds, double dut1)"
.br
.ti -1c
.RI "double \fBget_utc_to_tt\fP (int leap_seconds)"
.br
.ti -1c
.RI "double \fBgrav_redshift\fP (double M_kg, double r_m)"
.br
.ti -1c
.RI "int \fBgrav_undef\fP (double jd_tdb, enum \fBnovas_accuracy\fP accuracy, const double *pos_app, const double *pos_obs, double *out)"
.br
.ti -1c
.RI "int \fBgrav_undo_planets\fP (const double *pos_app, const double *pos_obs, const \fBnovas_planet_bundle\fP *planets, double *out)"
.br
.ti -1c
.RI "int \fBhor_to_itrs\fP (const \fBon_surface\fP *location, double az, double za, double *itrs)"
.br
.ti -1c
.RI "int \fBitrs_to_cirs\fP (double jd_tt_high, double jd_tt_low, double ut1_to_tt, enum \fBnovas_accuracy\fP accuracy, double xp, double yp, const double *in, double *out)"
.br
.ti -1c
.RI "int \fBitrs_to_hor\fP (const \fBon_surface\fP *location, const double *itrs, double *az, double *za)"
.br
.ti -1c
.RI "int \fBitrs_to_tod\fP (double jd_tt_high, double jd_tt_low, double ut1_to_tt, enum \fBnovas_accuracy\fP accuracy, double xp, double yp, const double *in, double *out)"
.br
.ti -1c
.RI "int \fBj2000_to_gcrs\fP (const double *in, double *out)"
.br
.ti -1c
.RI "int \fBmake_airborne_observer\fP (const \fBon_surface\fP *location, const double *vel, \fBobserver\fP *obs)"
.br
.ti -1c
.RI "int \fBmake_cat_object\fP (const \fBcat_entry\fP *star, \fBobject\fP *source)"
.br
.ti -1c
.RI "int \fBmake_ephem_object\fP (const char *name, long num, \fBobject\fP *body)"
.br
.ti -1c
.RI "int \fBmake_redshifted_object\fP (const char *name, double ra, double dec, double z, \fBobject\fP *source)"
.br
.ti -1c
.RI "int \fBmake_solar_system_observer\fP (const double *sc_pos, const double *sc_vel, \fBobserver\fP *obs)"
.br
.ti -1c
.RI "double \fBnovas_v2z\fP (double vel)"
.br
.ti -1c
.RI "double \fBnovas_z_add\fP (double z1, double z2)"
.br
.ti -1c
.RI "double \fBnovas_z_inv\fP (double z)"
.br
.ti -1c
.RI "int \fBplace_cirs\fP (double jd_tt, const \fBobject\fP *source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP *pos)"
.br
.ti -1c
.RI "int \fBplace_gcrs\fP (double jd_tt, const \fBobject\fP *source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP *pos)"
.br
.ti -1c
.RI "int \fBplace_icrs\fP (double jd_tt, const \fBobject\fP *source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP *pos)"
.br
.ti -1c
.RI "int \fBplace_j2000\fP (double jd_tt, const \fBobject\fP *source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP *pos)"
.br
.ti -1c
.RI "int \fBplace_mod\fP (double jd_tt, const \fBobject\fP *source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP *pos)"
.br
.ti -1c
.RI "int \fBplace_tod\fP (double jd_tt, const \fBobject\fP *source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP *pos)"
.br
.ti -1c
.RI "double \fBredshift_vrad\fP (double vrad, double z)"
.br
.ti -1c
.RI "int \fBtod_to_cirs\fP (double jd_tt, enum \fBnovas_accuracy\fP accuracy, const double *in, double *out)"
.br
.ti -1c
.RI "int \fBtod_to_itrs\fP (double jd_tt_high, double jd_tt_low, double ut1_to_tt, enum \fBnovas_accuracy\fP accuracy, double xp, double yp, const double *in, double *out)"
.br
.ti -1c
.RI "double \fBunredshift_vrad\fP (double vrad, double z)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBDate\fP
.RS 4
Created on Aug 24, 2024 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
SuperNOVAS only functions, which are not integral to the functionality of \fBnovas\&.c\fP, and thus can live in a separate, more manageably sized, module\&. 
.SH "Function Documentation"
.PP 
.SS "double app_to_cirs_ra (double jd_tt, enum \fBnovas_accuracy\fP accuracy, double ra)"
Converts an apparent right ascension coordinate (measured from the true equinox of date) to a CIRS R\&.A\&., measured from the CIO\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIra\fP [h] the apparent R\&.A\&. coordinate measured from the true equinox of date\&. 
.RE
.PP
\fBReturns\fP
.RS 4
[h] The CIRS right ascension coordinate, measured from the CIO [0:24], or NAN if the accuracy is invalid, or if there wan an error from \fBcio_ra()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBcirs_to_app_ra()\fP 
.PP
\fBtod_to_cirs()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBcio_ra()\fP\&.
.SS "double cirs_to_app_ra (double jd_tt, enum \fBnovas_accuracy\fP accuracy, double ra)"
Converts a CIRS right ascension coordinate (measured from the CIO) to an apparent R\&.A\&. measured from the true equinox of date\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIra\fP [h] The CIRS right ascension coordinate, measured from the CIO\&. 
.RE
.PP
\fBReturns\fP
.RS 4
[h] the apparent R\&.A\&. coordinate measured from the true equinox of date [0:24], or NAN if the accuracy is invalid, or if there wan an error from \fBcio_ra()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBapp_to_cirs_ra()\fP 
.PP
\fBcirs_to_tod()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBcio_ra()\fP\&.
.SS "int cirs_to_itrs (double jd_tt_high, double jd_tt_low, double ut1_to_tt, enum \fBnovas_accuracy\fP accuracy, double xp, double yp, const double * in, double * out)"
Rotates a position vector from the dynamical CIRS frame of date to the Earth-fixed ITRS frame (IAU 2000 standard method)\&.
.PP
If both 'xp' and 'yp' are set to 0 no polar motion is included in the transformation\&.
.PP
If extreme (sub-microarcsecond) accuracy is not required, you can use UT1-based Julian date instead of the TT-based Julian date and set the 'ut1_to_tt' argument to 0\&.0\&. and you can use UTC-based Julian date the same way\&.for arcsec-level precision also\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Kaplan, G\&. H\&. et\&. al\&. (1989)\&. Astron\&. Journ\&. 97, 1197-1210\&. 
.IP "2." 4
Kaplan, G\&. H\&. (2003), 'Another Look at Non-Rotating Origins', Proceedings of IAU XXV Joint Discussion 16\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIjd_tt_high\fP [day] High-order part of Terrestrial Time (TT) based Julian date\&. 
.br
\fIjd_tt_low\fP [day] Low-order part of Terrestrial Time (TT) based Julian date\&. 
.br
\fIut1_to_tt\fP [s] TT - UT1 Time difference in seconds 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIxp\fP [arcsec] Conventionally-defined X coordinate of celestial intermediate pole with respect to ITRS pole, in arcseconds\&. 
.br
\fIyp\fP [arcsec] Conventionally-defined Y coordinate of celestial intermediate pole with respect to ITRS pole, in arcseconds\&. 
.br
\fIin\fP Position vector, geocentric equatorial rectangular coordinates, referred to CIRS axes (celestial system)\&. 
.br
\fIout\fP Position vector, geocentric equatorial rectangular coordinates, referred to ITRS axes (terrestrial system)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, -1 if either of the vector arguments is NULL, 1 if 'accuracy' is invalid, 2 if 'method' is invalid 10--20, 3 if the method and option are mutually incompatible, or else 10 + the error from \fBcio_location()\fP, or 20 + error from \fBcio_basis()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBtod_to_itrs()\fP 
.PP
\fBitrs_to_cirs()\fP 
.PP
\fBgcrs_to_cirs()\fP 
.PP
\fBcirs_to_gcrs()\fP 
.PP
\fBcirs_to_tod()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBcel2ter()\fP, \fBEROT_ERA\fP, and \fBNOVAS_DYNAMICAL_CLASS\fP\&.
.SS "int cirs_to_tod (double jd_tt, enum \fBnovas_accuracy\fP accuracy, const double * in, double * out)"
Transforms a rectangular equatorial (x, y, z) vector from the Celestial Intermediate Reference System (CIRS) at the given epoch to the True of Date (TOD) reference system\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date that defines the output epoch\&. Typically it does not require much precision, and Julian dates in other time measures will be unlikely to affect the result 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIin\fP CIRS Input (x, y, z) position or velocity vector 
.br
\fIout\fP Output position or velocity 3-vector in the True of Date (TOD) frame\&. It can be the same vector as the input\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if either of the vector arguments is NULL or the accuracy is invalid, or 10 + the error from \fBcio_location()\fP, or else 20 + the error from \fBcio_basis()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBtod_to_cirs()\fP 
.PP
\fBcirs_to_app_ra()\fP 
.PP
\fBcirs_to_gcrs()\fP 
.PP
\fBcirs_to_itrs()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBcio_ra()\fP, \fBNOVAS_FULL_ACCURACY\fP, and \fBspin()\fP\&.
.SS "int ecl2equ (double jd_tt, enum \fBnovas_equator_type\fP coord_sys, enum \fBnovas_accuracy\fP accuracy, double elon, double elat, double * ra, double * dec)"
Convert ecliptic longitude and latitude to right ascension and declination\&. To convert GCRS ecliptic coordinates (mean ecliptic and equinox of J2000\&.0), set 'coord_sys' to \fBNOVAS_GCRS_EQUATOR(2)\fP; in this case the value of 'jd_tt' can be set to anything, since J2000\&.0 is assumed\&. Otherwise, all input coordinates are dynamical at'jd_tt'\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date\&. (Unused if 'coord_sys' is NOVAS_GCRS_EQUATOR[2]) 
.br
\fIcoord_sys\fP The astrometric reference system of the coordinates\&. If 'coord_sys' is \fBNOVAS_GCRS_EQUATOR(2)\fP, the input GCRS coordinates are converted to J2000 ecliptic coordinates\&. 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIelon\fP [deg] Ecliptic longitude in degrees, referred to specified ecliptic and equinox of date\&. 
.br
\fIelat\fP [deg] Ecliptic latitude in degrees, referred to specified ecliptic and equinox of date\&. 
.br
\fIra\fP [h] Right ascension in hours, referred to specified equator and equinox of date\&. 
.br
\fIdec\fP [deg] Declination in degrees, referred to specified equator and equinox of date\&.
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or else 1 if the value of 'coord_sys' is invalid\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBecl2equ_vec()\fP 
.PP
\fBequ2ecl()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBecl2equ_vec()\fP\&.
.SS "int gal2equ (double glon, double glat, double * ra, double * dec)"
Converts galactic longitude and latitude to ICRS right ascension and declination\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Hipparcos and Tycho Catalogues, Vol\&. 1, Section 1\&.5\&.3\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIglon\fP [deg] Galactic longitude in degrees\&. 
.br
\fIglat\fP [deg] Galactic latitude in degrees\&. 
.br
\fIra\fP [h] ICRS right ascension in hours\&. 
.br
\fIdec\fP [deg] ICRS declination in degrees\&.
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if either of the output pointer arguments are NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBequ2gal()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.SS "double get_ut1_to_tt (int leap_seconds, double dut1)"
Returns the TT - UT1 time difference given the leap seconds and the actual UT1 - UTC time difference as measured and published by IERS\&.
.PP
NOTES: 
.PD 0
.IP "1." 4
The current UT1 - UTC time difference, and polar offsets, historical data and near-term projections are published in the <a href="https://www.iers.org/IERS/EN/Publications/Bulletins/bulletins.html>IERS Bulletins  
.PP
.PP
\fBParameters\fP
.RS 4
\fIleap_seconds\fP [s] Leap seconds at the time of observations 
.br
\fIdut1\fP [s] UT1 - UTC time difference [-0\&.5:0\&.5] 
.RE
.PP
\fBReturns\fP
.RS 4
[s] The TT - UT1 time difference that is suitable for used with all calls in this library that require a \fRut1_to_tt\fP argument\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBget_utc_to_tt()\fP 
.PP
\fBplace()\fP 
.PP
\fBcel_pole()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBget_utc_to_tt()\fP\&.
.SS "double get_utc_to_tt (int leap_seconds)"
Returns the difference between Terrestrial Time (TT) and Universal Coordinated Time (UTC)
.PP
\fBParameters\fP
.RS 4
\fIleap_seconds\fP [s] The current leap seconds (see IERS Bulletins) 
.RE
.PP
\fBReturns\fP
.RS 4
[s] The TT - UTC time difference
.RE
.PP
\fBSee also\fP
.RS 4
\fBget_ut1_to_tt()\fP 
.PP
\fBjulian_date()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBNOVAS_TAI_TO_TT\fP\&.
.SS "double grav_redshift (double M_kg, double r_m)"
Returns the gravitational redshift (\fIz\fP) for light emitted near a massive spherical body at some distance from its center, and observed at some very large (infinite) distance away\&.
.PP
\fBParameters\fP
.RS 4
\fIM_kg\fP [kg] Mass of gravitating body that is contained inside the emitting radius\&. 
.br
\fIr_m\fP [m] Radius at which light is emitted\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The gravitational redshift (\fIz\fP) for an observer at very large (infinite) distance from the gravitating body\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredshift_vrad()\fP 
.PP
\fBunredshift_vrad()\fP 
.PP
\fBnovas_z_add()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.2 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBC\fP\&.
.SS "int grav_undef (double jd_tdb, enum \fBnovas_accuracy\fP accuracy, const double * pos_app, const double * pos_obs, double * out)"
Computes the gravitationally undeflected position of an observed source position due to the major gravitating bodies in the solar system\&. This function valid for an observed body within the solar system as well as for a star\&.
.PP
If 'accuracy' is set to zero (full accuracy), three bodies (Sun, Jupiter, and Saturn) are used in the calculation\&. If the reduced-accuracy option is set, only the Sun is used in the calculation\&. In both cases, if the observer is not at the geocenter, the deflection due to the Earth is included\&.
.PP
The number of bodies used at full and reduced accuracy can be set by making a change to the code in this function as indicated in the comments\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Klioner, S\&. (2003), Astronomical Journal 125, 1580-1597, Section 6\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIjd_tdb\fP [day] Barycentric Dynamical Time (TDB) based Julian date 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIpos_app\fP [AU] Apparent position 3-vector of observed object, with respect to origin at observer (or the geocenter), referred to ICRS axes, components in AU\&. 
.br
\fIpos_obs\fP [AU] Position 3-vector of observer (or the geocenter), with respect to origin at solar system barycenter, referred to ICRS axes, components in AU\&. 
.br
\fIout\fP [AU] Nominal position vector of observed object, with respect to origin at observer (or the geocenter), referred to ICRS axes, without gravitational deflection, components in AU\&. It can be the same vector as the input, but not the same as pos_obs\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, -1 if any of the pointer arguments is NULL (errno = EINVAL) or if the result did not converge (errno = ECANCELED), or else an error from \fBobs_planets()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBgrav_def()\fP 
.PP
\fBnovas_app_to_geom()\fP 
.PP
\fBset_planet_provider()\fP 
.PP
\fBset_planet_provider_hp()\fP 
.PP
\fBgrav_bodies_full_accuracy\fP 
.PP
\fBgrav_bodies_reduced_accuracy\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBgrav_bodies_full_accuracy\fP, \fBgrav_bodies_reduced_accuracy\fP, \fBgrav_undo_planets()\fP, \fBNOVAS_FULL_ACCURACY\fP, and \fBobs_planets()\fP\&.
.SS "int grav_undo_planets (const double * pos_app, const double * pos_obs, const \fBnovas_planet_bundle\fP * planets, double * out)"
Computes the gravitationally undeflected position of an observed source position due to the specified Solar-system bodies\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Klioner, S\&. (2003), Astronomical Journal 125, 1580-1597, Section 6\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIpos_app\fP [AU] Apparent position 3-vector of observed object, with respect to origin at observer (or the geocenter), referred to ICRS axes, components in AU\&. 
.br
\fIpos_obs\fP [AU] Position 3-vector of observer (or the geocenter), with respect to origin at solar system barycenter, referred to ICRS axes, components in AU\&. 
.br
\fIplanets\fP Apparent planet data containing positions and velocities for the major gravitating bodies in the solar-system\&. 
.br
\fIout\fP [AU] Nominal position vector of observed object, with respect to origin at observer (or the geocenter), referred to ICRS axes, without gravitational deflection, components in AU\&. It can be the same vector as the input, but not the same as pos_obs\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, -1 if any of the pointer arguments is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBobs_planets()\fP 
.PP
\fBgrav_planets()\fP 
.PP
\fBnovas_app_to_geom()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBgrav_planets()\fP, and \fBnovas_inv_max_iter\fP\&.
.SS "int hor_to_itrs (const \fBon_surface\fP * location, double az, double za, double * itrs)"
Converts astrometric (unrefracted) azimuth and zenith angles at the specified observer location to a unit position vector in the Earth-fixed ITRS frame\&.
.PP
\fBParameters\fP
.RS 4
\fIlocation\fP Observer location on Earth 
.br
\fIaz\fP [deg] astrometric azimuth angle at observer location [0:360]\&. It may be NULL if not required\&. 
.br
\fIza\fP [deg] astrometric zenith angle at observer location [0:180]\&. It may be NULL if not required\&. 
.br
\fIitrs\fP Unit 3-vector direction in Earth-fixed ITRS frame 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or else -1 if the location or the input vector is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBitrs_to_hor()\fP 
.PP
\fBitrs_to_cirs()\fP 
.PP
\fBitrs_to_tod()\fP 
.PP
\fBrefract()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBon_surface::latitude\fP, and \fBon_surface::longitude\fP\&.
.SS "int itrs_to_cirs (double jd_tt_high, double jd_tt_low, double ut1_to_tt, enum \fBnovas_accuracy\fP accuracy, double xp, double yp, const double * in, double * out)"
Rotates a position vector from the Earth-fixed ITRS frame to the dynamical CIRS frame of date (IAU 2000 standard method)\&.
.PP
If both 'xp' and 'yp' are set to 0 no polar motion is included in the transformation\&.
.PP
If extreme (sub-microarcsecond) accuracy is not required, you can use UT1-based Julian date instead of the TT-based Julian date and set the 'ut1_to_tt' argument to 0\&.0\&. and you can use UTC-based Julian date the same way\&.for arcsec-level precision also\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Kaplan, G\&. H\&. et\&. al\&. (1989)\&. Astron\&. Journ\&. 97, 1197-1210\&. 
.IP "2." 4
Kaplan, G\&. H\&. (2003), 'Another Look at Non-Rotating Origins', Proceedings of IAU XXV Joint Discussion 16\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIjd_tt_high\fP [day] High-order part of Terrestrial Time (TT) based Julian date\&. 
.br
\fIjd_tt_low\fP [day] Low-order part of Terrestrial Time (TT) based Julian date\&. 
.br
\fIut1_to_tt\fP [s] TT - UT1 Time difference in seconds 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIxp\fP [arcsec] Conventionally-defined X coordinate of celestial intermediate pole with respect to ITRS pole, in arcseconds\&. 
.br
\fIyp\fP [arcsec] Conventionally-defined Y coordinate of celestial intermediate pole with respect to ITRS pole, in arcseconds\&. 
.br
\fIin\fP Position vector, geocentric equatorial rectangular coordinates, referred to ITRS axes (terrestrial system) 
.br
\fIout\fP Position vector, geocentric equatorial rectangular coordinates, referred to CIRS axes (celestial system)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, -1 if either of the vector arguments is NULL, 1 if 'accuracy' is invalid, or else 10 + the error from \fBcio_location()\fP, or 20 + error from \fBcio_basis()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBitrs_to_tod()\fP 
.PP
\fBcirs_to_itrs()\fP 
.PP
\fBcirs_to_gcrs()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBEROT_ERA\fP, \fBNOVAS_DYNAMICAL_CLASS\fP, and \fBter2cel()\fP\&.
.SS "int itrs_to_hor (const \fBon_surface\fP * location, const double * itrs, double * az, double * za)"
Converts a position vector in the Earth-fixed ITRS frame to astrometric (unrefracted) azimuth and zenith angles at the specified observer location\&.
.PP
\fBParameters\fP
.RS 4
\fIlocation\fP Observer location on Earth 
.br
\fIitrs\fP 3-vector position in Earth-fixed ITRS frame 
.br
\fIaz\fP [deg] astrometric azimuth angle at observer location [0:360]\&. It may be NULL if not required\&. 
.br
\fIza\fP [deg] astrometric zenith angle at observer location [0:180]\&. It may be NULL if not required\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or else -1 if the location or the input vector is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBhor_to_itrs()\fP 
.PP
\fBcirs_to_itrs()\fP 
.PP
\fBtod_to_itrs()\fP 
.PP
\fBrefract_astro()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBon_surface::latitude\fP, and \fBon_surface::longitude\fP\&.
.SS "int itrs_to_tod (double jd_tt_high, double jd_tt_low, double ut1_to_tt, enum \fBnovas_accuracy\fP accuracy, double xp, double yp, const double * in, double * out)"
Rotates a position vector from the Earth-fixed ITRS frame to the dynamical True of Date (TOD) frame of date (pre IAU 2000 method)\&.
.PP
If both 'xp' and 'yp' are set to 0 no polar motion is included in the transformation\&.
.PP
If extreme (sub-microarcsecond) accuracy is not required, you can use UT1-based Julian date instead of the TT-based Julian date and set the 'ut1_to_tt' argument to 0\&.0\&. and you can use UTC-based Julian date the same way\&.for arcsec-level precision also\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Kaplan, G\&. H\&. et\&. al\&. (1989)\&. Astron\&. Journ\&. 97, 1197-1210\&. 
.IP "2." 4
Kaplan, G\&. H\&. (2003), 'Another Look at Non-Rotating Origins', Proceedings of IAU XXV Joint Discussion 16\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIjd_tt_high\fP [day] High-order part of Terrestrial Time (TT) based Julian date\&. 
.br
\fIjd_tt_low\fP [day] Low-order part of Terrestrial Time (TT) based Julian date\&. 
.br
\fIut1_to_tt\fP [s] TT - UT1 Time difference in seconds 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIxp\fP [arcsec] Conventionally-defined X coordinate of celestial intermediate pole with respect to ITRS pole, in arcseconds\&. 
.br
\fIyp\fP [arcsec] Conventionally-defined Y coordinate of celestial intermediate pole with respect to ITRS pole, in arcseconds\&. 
.br
\fIin\fP Position vector, geocentric equatorial rectangular coordinates, referred to ITRS axes (terrestrial system) 
.br
\fIout\fP Position vector, geocentric equatorial rectangular coordinates, referred to True of Date (TOD) axes (celestial system) 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, -1 if either of the vector arguments is NULL, 1 if 'accuracy' is invalid, or else 10 + the error from \fBcio_location()\fP, or 20 + error from \fBcio_basis()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBitrs_to_cirs()\fP 
.PP
\fBtod_to_itrs()\fP 
.PP
\fBtod_to_j2000()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBEROT_GST\fP, \fBNOVAS_DYNAMICAL_CLASS\fP, and \fBter2cel()\fP\&.
.SS "int j2000_to_gcrs (const double * in, double * out)"
Change J2000 coordinates to GCRS coordinates\&. Same as \fBframe_tie()\fP called with J2000_TO_ICRS
.PP
\fBParameters\fP
.RS 4
\fIin\fP J2000 input 3-vector 
.br
\fIout\fP GCRS output 3-vector 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or else an error from \fBframe_tie()\fP
.RE
.PP
\fBSee also\fP
.RS 4
\fBj2000_to_tod()\fP 
.PP
\fBgcrs_to_j2000()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBframe_tie()\fP, and \fBJ2000_TO_ICRS\fP\&.
.SS "int make_airborne_observer (const \fBon_surface\fP * location, const double * vel, \fBobserver\fP * obs)"
Populates an 'observer' data structure for an observer moving relative to the surface of Earth, such as an airborne observer\&. Airborne observers have an earth fixed momentary location, defined by longitude, latitude, and altitude, the same was as for a stationary observer on Earth, but are moving relative to the surface, such as in an aircraft or balloon observatory\&.
.PP
\fBParameters\fP
.RS 4
\fIlocation\fP Current longitude, latitude and altitude, and local weather (temperature and pressure) 
.br
\fIvel\fP [km/s] Surface velocity\&. 
.br
\fIobs\fP Pointer to data structure to populate\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if the output argument is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
make_observer_at geocenter() 
.PP
\fBmake_observer_in_space()\fP 
.PP
\fBmake_observer_on_surface()\fP 
.PP
\fBmake_solar_system_observer()\fP 
.PP
novas_calc_geometric_position() 
.PP
\fBplace()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBmake_observer()\fP, \fBNOVAS_AIRBORNE_OBSERVER\fP, and \fBin_space::sc_vel\fP\&.
.SS "int make_cat_object (const \fBcat_entry\fP * star, \fBobject\fP * source)"
Populates and object data structure with the data for a catalog source\&.
.PP
\fBParameters\fP
.RS 4
\fIstar\fP Pointer to structure to populate with the catalog data for a celestial object located outside the solar system\&. 
.br
\fIsource\fP Pointer to the celestial object data structure to be populated\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if 'cel_obj' is NULL or when type is NOVAS_CATALOG_OBJECT and 'star' is NULL, or else 1 if 'type' is invalid, 2 if 'number' is out of legal range or 5 if 'name' is too long\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmake_cat_entry()\fP 
.PP
\fBmake_planet()\fP 
.PP
\fBmake_ephem_object()\fP 
.PP
\fBplace()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBmake_object()\fP, \fBNOVAS_CATALOG_OBJECT\fP, \fBcat_entry::starname\fP, and \fBcat_entry::starnumber\fP\&.
.SS "int make_ephem_object (const char * name, long num, \fBobject\fP * body)"
Sets a celestial object to be a Solar-system ephemeris body\&. Typically this would be used to define minor planets, asteroids, comets and planetary satellites\&.
.PP
\fBParameters\fP
.RS 4
\fIname\fP Name of object\&. By default converted to upper-case, unless \fBnovas_case_sensitive()\fP was called with a non-zero argument\&. Max\&. SIZE_OF_OBJ_NAME long, including termination\&. 
.br
\fInum\fP Solar-system body ID number (e\&.g\&. NAIF) 
.br
\fIbody\fP Pointer to structure to populate\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or else -1 if the 'planet' pointer is NULL or the name is too long\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmake_planet()\fP 
.PP
\fBmake_cat_entry()\fP 
.PP
\fBplace()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBmake_object()\fP, and \fBNOVAS_EPHEM_OBJECT\fP\&.
.SS "int make_redshifted_object (const char * name, double ra, double dec, double z, \fBobject\fP * source)"
Populates a celestial object data structure with the parameters for a redhifted catalog source, such as a distant quasar or galaxy\&. It is similar to \fR\fBmake_cat_object()\fP\fP except that it takes a Doppler-shift (z) instead of radial velocity and it assumes no parallax and no proper motion (appropriately for a distant redshifted source)\&. The catalog name is set to \fREXT\fP to indicate an extragalactic source, and the catalog number defaults to 0\&. The user may change these default field values as appropriate afterwards, if necessary\&.
.PP
\fBParameters\fP
.RS 4
\fIname\fP Object name (less than SIZE_OF_OBJ_NAME in length)\&. It may be NULL\&. 
.br
\fIra\fP [h] Right ascension of the object (hours)\&. 
.br
\fIdec\fP [deg] Declination of the object (degrees)\&. 
.br
\fIz\fP Redhift value (\*<obs\*>  / \*<rest\*>  - 1 = f\*<rest\*>  / f\*<obs\*>  - 1)\&. 
.br
\fIsource\fP Pointer to structure to populate\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or 5 if 'name' is too long, else -1 if the 'source' pointer is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmake_cat_object()\fP 
.PP
\fBnovas_v2z()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.2 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBmake_cat_entry()\fP, \fBmake_cat_object()\fP, and \fBnovas_z2v()\fP\&.
.SS "int make_solar_system_observer (const double * sc_pos, const double * sc_vel, \fBobserver\fP * obs)"
Populates an 'observer' data structure, for an observer situated on a near-Earth spacecraft, with the specified geocentric position and velocity vectors\&. Solar-system observers are similar to observers in Earth-orbit but their momentary position and velocity is defined relative to the Solar System Barycenter, instead of the geocenter\&.
.PP
\fBParameters\fP
.RS 4
\fIsc_pos\fP [AU] Solar-system barycentric (x, y, z) position vector in ICRS\&. 
.br
\fIsc_vel\fP [AU/day] Solar-system barycentric (x, y, z) velocity vector in ICRS\&. 
.br
\fIobs\fP Pointer to the data structure to populate 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if the output argument is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmake_observer_in_space()\fP 
.PP
\fBmake_observer_on_surface()\fP 
.PP
\fBmake_observer_at_geocenter()\fP 
.PP
\fBmake_airborne_observer()\fP 
.PP
novas_calc_geometric_position() 
.PP
\fBplace()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBmake_in_space()\fP, \fBmake_observer()\fP, and \fBNOVAS_SOLAR_SYSTEM_OBSERVER\fP\&.
.SS "double novas_v2z (double vel)"
Converts a radial recession velocity to a redshift value (z = f / f\*<rest\*> )\&. It is based on the relativistic formula: 
.PP
.nf

 1 + z = sqrt((1 + ) / (1 - ))
.fi
.PP
 where  = v / c\&.
.PP
\fBParameters\fP
.RS 4
\fIvel\fP [km/s] velocity (i\&.e\&. rate) of recession\&. 
.RE
.PP
\fBReturns\fP
.RS 4
the corresponding redshift value ( / \*<rest\*> ), or NAN if the input velocity is invalid (i\&.e\&., it exceeds the speed of light)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBnovas_z2v()\fP 
.PP
\fBnovas_z_add()\fP
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP
\fBSince\fP
.RS 4
1\&.2 
.RE
.PP

.PP
References \fBC\fP\&.
.SS "double novas_z_add (double z1, double z2)"
Compounds two redshift corrections, e\&.g\&. to apply (or undo) a series gravitational redshift corrections and/or corrections for a moving observer\&. It's effectively using (1 + z) = (1 + z1) * (1 + z2)\&.
.PP
\fBParameters\fP
.RS 4
\fIz1\fP One of the redshift values 
.br
\fIz2\fP The other redshift value 
.RE
.PP
\fBReturns\fP
.RS 4
The compound redshift value, ot NAN if either input redshift is invalid (errno will be set to EINVAL)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBgrav_redshift()\fP 
.PP
\fBredshift_vrad()\fP 
.PP
\fBunredshift_vrad()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.2 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.SS "double novas_z_inv (double z)"
Returns the inverse of a redshift value, that is the redshift for a body moving with the same velocity as the original but in the opposite direction\&.
.PP
\fBParameters\fP
.RS 4
\fIz\fP A redhift value 
.RE
.PP
\fBReturns\fP
.RS 4
The redshift value for a body moving in the opposite direction with the same speed, or NAN if the input redshift is invalid\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBnovas_z_add()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.2 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.SS "int place_cirs (double jd_tt, const \fBobject\fP * source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP * pos)"
Computes the Celestial Intermediate Reference System (CIRS) dynamical position position of a source as 'seen' from the geocenter at the given time of observation\&. See \fR\fBplace()\fP\fP for more information\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date of observation\&. 
.br
\fIsource\fP Catalog source or solar_system body\&. 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIpos\fP Structure to populate with the calculated CIRS position data 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if any of the input pointer arguments is NULL, or else an error from \fBplace()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBplace_tod()\fP 
.PP
\fBplace_gcrs()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBNOVAS_CIRS\fP, and \fBplace()\fP\&.
.SS "int place_gcrs (double jd_tt, const \fBobject\fP * source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP * pos)"
Computes the Geocentric Celestial Reference System (GCRS) position of a source (as 'seen' from the geocenter) at the given time of observation\&. Unlike \fR\fBplace_icrs()\fP\fP, this includes aberration for the moving frame of the geocenter as well as gravitational deflections calculated for a virtual observer located at the geocenter\&. See \fR\fBplace()\fP\fP for more information\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date of observation\&. 
.br
\fIsource\fP Catalog source or solar_system body\&. 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIpos\fP Structure to populate with the calculated GCRS position data 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if any of the input pointer arguments is NULL, or else an error from \fBplace()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBplace_icrs()\fP 
.PP
\fBplace_cirs()\fP 
.PP
\fBplace_tod()\fP 
.PP
\fBvirtual_star()\fP 
.PP
\fBvirtual_planet()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBNOVAS_GCRS\fP, and \fBplace()\fP\&.
.SS "int place_icrs (double jd_tt, const \fBobject\fP * source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP * pos)"
Computes the International Celestial Reference System (ICRS) position of a source\&. (from the geocenter)\&. Unlike \fR\fBplace_gcrs()\fP\fP, this version does not include aberration or gravitational deflection corrections\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date of observation\&. 
.br
\fIsource\fP Catalog source or solar_system body\&. 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIpos\fP Structure to populate with the calculated geocentric ICRS position data (Unlike \fBplace_gcrs()\fP, the calculated coordinates do not account for aberration or gravitational deflection)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if any of the input pointer arguments is NULL, or else an error from \fBplace()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBplace_gcrs()\fP 
.PP
\fBplace_cirs()\fP 
.PP
\fBplace_tod()\fP 
.PP
\fBmean_star()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBNOVAS_ICRS\fP, and \fBplace()\fP\&.
.SS "int place_j2000 (double jd_tt, const \fBobject\fP * source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP * pos)"
Computes the J2000 dynamical position position of a source as 'seen' from the geocenter at the given time of observation\&. See \fR\fBplace()\fP\fP for more information\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date of observation\&. 
.br
\fIsource\fP Catalog source or solar_system body\&. 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIpos\fP Structure to populate with the calculated CIRS position data 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if any of the input pointer arguments is NULL, or else an error from \fBplace()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBplace_cirs()\fP 
.PP
\fBplace_gcrs()\fP 
.PP
\fBapp_star()\fP 
.PP
\fBapp_planet()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBNOVAS_J2000\fP, and \fBplace()\fP\&.
.SS "int place_mod (double jd_tt, const \fBobject\fP * source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP * pos)"
Computes the Mean of Date (MOD) dynamical position position of a source as 'seen' from the geocenter at the given time of observation\&. See \fR\fBplace()\fP\fP for more information\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date of observation\&. 
.br
\fIsource\fP Catalog source or solar_system body\&. 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIpos\fP Structure to populate with the calculated CIRS position data 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if any of the input pointer arguments is NULL, or else an error from \fBplace()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBplace_cirs()\fP 
.PP
\fBplace_gcrs()\fP 
.PP
\fBapp_star()\fP 
.PP
\fBapp_planet()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBNOVAS_MOD\fP, and \fBplace()\fP\&.
.SS "int place_tod (double jd_tt, const \fBobject\fP * source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP * pos)"
Computes the True of Date (TOD) dynamical position position of a source as 'seen' from the geocenter at the given time of observation\&. See \fR\fBplace()\fP\fP for more information\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date of observation\&. 
.br
\fIsource\fP Catalog source or solar_system body\&. 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIpos\fP Structure to populate with the calculated CIRS position data 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if any of the input pointer arguments is NULL, or else an error from \fBplace()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBplace_cirs()\fP 
.PP
\fBplace_gcrs()\fP 
.PP
\fBapp_star()\fP 
.PP
\fBapp_planet()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBNOVAS_TOD\fP, and \fBplace()\fP\&.
.SS "double redshift_vrad (double vrad, double z)"
Applies an incremental redshift correction to a radial velocity\&. For example, you may use this function to correct a radial velocity calculated by \fR\fBrad_vel()\fP\fP or \fR\fBrad_vel2()\fP\fP for a Solar-system body to account for the gravitational redshift for light originating at a specific distance away from the body\&. For the Sun, you may want to undo the redshift correction applied for the photosphere using \fR\fBunredshift_vrad()\fP\fP first\&.
.PP
\fBParameters\fP
.RS 4
\fIvrad\fP [km/s] Radial velocity 
.br
\fIz\fP Redshift correction to apply 
.RE
.PP
\fBReturns\fP
.RS 4
[km/s] The redshift corrected radial velocity or NAN if the redshift value is invalid (errno will be set to EINVAL)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBunredshift_vrad()\fP 
.PP
\fBgrav_redshift()\fP 
.PP
\fBnovas_z_add()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.2 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBnovas_v2z()\fP, and \fBnovas_z2v()\fP\&.
.SS "int tod_to_cirs (double jd_tt, enum \fBnovas_accuracy\fP accuracy, const double * in, double * out)"
Transforms a rectangular equatorial (x, y, z) vector from the True of Date (TOD) reference system to the Celestial Intermediate Reference System (CIRS) at the given epoch to the \&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date that defines the output epoch\&. Typically it does not require much precision, and Julian dates in other time measures will be unlikely to affect the result 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIin\fP CIRS Input (x, y, z) position or velocity vector 
.br
\fIout\fP Output position or velocity 3-vector in the True of Date (TOD) frame\&. It can be the same vector as the input\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if either of the vector arguments is NULL or the accuracy is invalid, or 10 + the error from \fBcio_location()\fP, or else 20 + the error from \fBcio_basis()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBcirs_to_tod()\fP 
.PP
\fBapp_to_cirs_ra()\fP 
.PP
tod_to_gcrs() 
.PP
\fBtod_to_j2000()\fP 
.PP
\fBtod_to_itrs()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBcio_ra()\fP, \fBNOVAS_FULL_ACCURACY\fP, and \fBspin()\fP\&.
.SS "int tod_to_itrs (double jd_tt_high, double jd_tt_low, double ut1_to_tt, enum \fBnovas_accuracy\fP accuracy, double xp, double yp, const double * in, double * out)"
Rotates a position vector from the dynamical True of Date (TOD) frame of date the Earth-fixed ITRS frame (pre IAU 2000 method)\&.
.PP
If both 'xp' and 'yp' are set to 0 no polar motion is included in the transformation\&.
.PP
If extreme (sub-microarcsecond) accuracy is not required, you can use UT1-based Julian date instead of the TT-based Julian date and set the 'ut1_to_tt' argument to 0\&.0\&. and you can use UTC-based Julian date the same way\&.for arcsec-level precision also\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Kaplan, G\&. H\&. et\&. al\&. (1989)\&. Astron\&. Journ\&. 97, 1197-1210\&. 
.IP "2." 4
Kaplan, G\&. H\&. (2003), 'Another Look at Non-Rotating Origins', Proceedings of IAU XXV Joint Discussion 16\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIjd_tt_high\fP [day] High-order part of Terrestrial Time (TT) based Julian date\&. 
.br
\fIjd_tt_low\fP [day] Low-order part of Terrestrial Time (TT) based Julian date\&. 
.br
\fIut1_to_tt\fP [s] TT - UT1 Time difference in seconds\&. 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIxp\fP [arcsec] Conventionally-defined X coordinate of celestial intermediate pole with respect to ITRS pole, in arcseconds\&. 
.br
\fIyp\fP [arcsec] Conventionally-defined Y coordinate of celestial intermediate pole with respect to ITRS pole, in arcseconds\&. 
.br
\fIin\fP Position vector, geocentric equatorial rectangular coordinates, referred to True of Date (TOD) axes (celestial system)\&. 
.br
\fIout\fP Position vector, geocentric equatorial rectangular coordinates, referred to ITRS axes (terrestrial system)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, -1 if either of the vector arguments is NULL, 1 if 'accuracy' is invalid, 2 if 'method' is invalid 10--20, 3 if the method and option are mutually incompatible, or else 10 + the error from \fBcio_location()\fP, or 20 + error from \fBcio_basis()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBcirs_to_itrs()\fP 
.PP
\fBitrs_to_tod()\fP 
.PP
\fBj2000_to_tod()\fP 
.PP
tod_to_gcrs() 
.PP
\fBtod_to_j2000()\fP 
.PP
\fBtod_to_cirs()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBcel2ter()\fP, \fBEROT_GST\fP, and \fBNOVAS_DYNAMICAL_CLASS\fP\&.
.SS "double unredshift_vrad (double vrad, double z)"
Undoes an incremental redshift correction that was applied to radial velocity\&.
.PP
\fBParameters\fP
.RS 4
\fIvrad\fP [km/s] Radial velocity 
.br
\fIz\fP Redshift correction to apply 
.RE
.PP
\fBReturns\fP
.RS 4
[km/s] The radial velocity without the redshift correction or NAN if the redshift value is invalid\&. (errno will be set to EINVAL)
.RE
.PP
\fBSee also\fP
.RS 4
\fBredshift_vrad()\fP 
.PP
\fBgrav_redshift()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.2 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBnovas_v2z()\fP, and \fBnovas_z2v()\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for SuperNOVAS from the source code\&.
