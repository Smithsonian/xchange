.TH "src/xchange.c" 3 "Version v0.9" "xchange" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/xchange.c \- A collection of commonly used functions for standard data exchange for scalars and arrays, and ASCII representations\&.  

.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBEIXPLICIT_PARSE_SPECIAL_DOUBLES\fP   \fBTRUE\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void * \fBxAlloc\fP (\fBXType\fP type, int count)"
.br
.ti -1c
.RI "int \fBxElementSizeOf\fP (\fBXType\fP type)"
.br
.ti -1c
.RI "int \fBxError\fP (const char *func, int errorCode)"
.br
.ti -1c
.RI "const char * \fBxErrorDescription\fP (int code)"
.br
.ti -1c
.RI "int \fBxGetElementCount\fP (int ndim, const int *sizes)"
.br
.ti -1c
.RI "\fBboolean\fP \fBxIsCharSequence\fP (\fBXType\fP type)"
.br
.ti -1c
.RI "\fBboolean\fP \fBxIsVerbose\fP ()"
.br
.ti -1c
.RI "\fBboolean\fP \fBxParseBoolean\fP (char *str, char **end)"
.br
.ti -1c
.RI "int \fBxParseDims\fP (const char *src, int *sizes)"
.br
.ti -1c
.RI "double \fBxParseDouble\fP (const char *str, char **tail)"
.br
.ti -1c
.RI "int \fBxPrintDims\fP (char *dst, int ndim, const int *sizes)"
.br
.ti -1c
.RI "int \fBxPrintDouble\fP (char *str, double value)"
.br
.ti -1c
.RI "int \fBxPrintFloat\fP (char *str, float value)"
.br
.ti -1c
.RI "void \fBxSetVerbose\fP (\fBboolean\fP value)"
.br
.ti -1c
.RI "char * \fBxStringCopyOf\fP (const char *str)"
.br
.ti -1c
.RI "int \fBxStringElementSizeOf\fP (\fBXType\fP type)"
.br
.ti -1c
.RI "char \fBxTypeChar\fP (\fBXType\fP type)"
.br
.ti -1c
.RI "void \fBxZero\fP (void *buf, \fBXType\fP type, int count)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBboolean\fP \fBxDebug\fP = \fBFALSE\fP"
.br
.RI "Switch to enable debugging (very verbose) output for XChange operations\&. "
.ti -1c
.RI "\fBboolean\fP \fBxVerbose\fP"
.br
.RI "Switch to enable verbose console output for XChange operations\&. "
.in -1c
.SH "Detailed Description"
.PP 
A collection of commonly used functions for standard data exchange for scalars and arrays, and ASCII representations\&. 


.PP
\fBDate\fP
.RS 4
Nov 25, 2020 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP

.SH "Macro Definition Documentation"
.PP 
.SS "#define EIXPLICIT_PARSE_SPECIAL_DOUBLES   \fBTRUE\fP"
Check if we need to parse special floating point values, such as 'nan', 'infinity' or 'inf'\&.\&.\&. These were added in the C99 standard, at the same time as the constant INFINITY was added\&. 
.SH "Function Documentation"
.PP 
.SS "void * xAlloc (\fBXType\fP type, int count)"
Allocates a buffer for a given SMA-X type and element count\&. The buffer is initialized with zeroes\&.
.PP
\fBParameters\fP
.RS 4
\fItype\fP SMA-X type 
.br
\fIcount\fP number of elements\&.
.RE
.PP
\fBReturns\fP
.RS 4
Pointer to the initialized buffer or NULL if there was an error (errno will be set accordingly)\&. 
.RE
.PP

.PP
References \fBxElementSizeOf()\fP\&.
.SS "int xElementSizeOf (\fBXType\fP type)"
Returns the storage byte size of a single element of a given type\&.
.PP
\fBParameters\fP
.RS 4
\fItype\fP The data type, as defined in '\fBxchange\&.h\fP'
.RE
.PP
\fBReturns\fP
.RS 4
[bytes] the native storage size of a single element of that type\&. E\&.g\&. for X_CHAR(20) it will return 20\&. X_DOUBLE will return 8, etc\&. Unrecognised types will return 0\&. 
.RE
.PP

.PP
References \fBX_BOOLEAN\fP, \fBX_BYTE\fP, \fBX_BYTE_HEX\fP, \fBX_DOUBLE\fP, \fBX_FLOAT\fP, \fBX_INT\fP, \fBX_INT_HEX\fP, \fBX_LONG\fP, \fBX_LONG_HEX\fP, \fBX_RAW\fP, \fBX_SHORT\fP, \fBX_SHORT_HEX\fP, \fBX_STRING\fP, and \fBX_STRUCT\fP\&.
.SS "int xError (const char * func, int errorCode)"
Prints a descriptive error message to stderr, and returns the error code\&.
.PP
\fBParameters\fP
.RS 4
\fIfunc\fP String that describes the function or location where the error occurred\&. 
.br
\fIerrorCode\fP Error code that describes the failure\&.
.RE
.PP
\fBReturns\fP
.RS 4
Same error code as specified on input\&. 
.RE
.PP

.PP
References \fBxDebug\fP, and \fBxErrorDescription()\fP\&.
.SS "const char * xErrorDescription (int code)"
Returns a string description for one of the standard X-change error codes, and sets errno as appropriate also\&. (The mapping to error codes is not one-to-one\&. The same errno may be used to describe different X-change errors\&. Nevertheless, it is a guide that can be used when the X-change error is not directtly available, e\&.g\&. because it is not returned by a given function\&.)
.PP
\fBParameters\fP
.RS 4
\fIcode\fP One of the error codes defined in '\fBxchange\&.h\fP'
.RE
.PP
\fBReturns\fP
.RS 4
A constant string with the error description\&. 
.RE
.PP

.PP
References \fBX_ALREADY_OPEN\fP, \fBX_FAILURE\fP, \fBX_GROUP_INVALID\fP, \fBX_INCOMPLETE\fP, \fBX_INTERRUPTED\fP, \fBX_NAME_INVALID\fP, \fBX_NO_BLOCKED_READ\fP, \fBX_NO_INIT\fP, \fBX_NO_PIPELINE\fP, \fBX_NO_SERVICE\fP, \fBX_NOT_ENOUGH_TOKENS\fP, \fBX_NULL\fP, \fBX_PARSE_ERROR\fP, \fBX_SIZE_INVALID\fP, \fBX_SUCCESS\fP, \fBX_TIMEDOUT\fP, and \fBX_TYPE_INVALID\fP\&.
.SS "int xGetElementCount (int ndim, const int * sizes)"
Returns the total element count specified by along a number of dimensions\&. It ignores dimensions that have size components <= 0;
.PP
\fBParameters\fP
.RS 4
\fIndim\fP Number of dimensions 
.br
\fIsizes\fP Sizes along each dimension\&.
.RE
.PP
\fBReturns\fP
.RS 4
Total element count specified by the dimensions\&. Defaults to 1\&. 
.RE
.PP

.PP
References \fBX_MAX_DIMS\fP\&.
.SS "\fBboolean\fP xIsCharSequence (\fBXType\fP type)"
Checks if the type represents a (fixed size) character sequence\&.
.PP
\fBParameters\fP
.RS 4
\fItype\fP X-Change type to check\&.
.RE
.PP
\fBReturns\fP
.RS 4
TRUE if it is a type for a (fixed size) character array, otherwise FALSE\&. 
.RE
.PP

.SS "\fBboolean\fP xIsVerbose ()"
Checks if verbosity is enabled for the xchange library\&.
.PP
\fBReturns\fP
.RS 4
TRUE (1) if verbosity is enabled, or else FALSE (0)\&.
.RE
.PP
\fBSee also\fP
.RS 4
setVerbose() 
.RE
.PP

.PP
References \fBxVerbose\fP\&.
.SS "\fBboolean\fP xParseBoolean (char * str, char ** end)"
Parses a boolean value, either as a zero/non-zero number or as a case-insensitive match to the next token to one of the recognized boolean terms, such as 'true'/'false', 'on'/'off', 'yes'/'no', 't'/'f', 'y'/'n', 'enabled'/'disabled' or 'active'/'inactive'\&. If a boolean value cannot be matched, FALSE is returned, and errno is set to ERANGE\&.
.PP
\fBParameters\fP
.RS 4
\fIstr\fP Pointer to the string token\&. 
.br
\fIend\fP Where the pointer to after the successfully parsed token is returned, on NULL\&. 
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) or FALSE (0)\&. 
.RE
.PP

.PP
References \fBFALSE\fP, and \fBTRUE\fP\&.
.SS "int xParseDims (const char * src, int * sizes)"
Deserializes the sizes from a multi-dimensional specification\&. The parsing will terminate at the first non integer value or the end of string, whichever comes first\&. Integer values <= 0 are ignored\&.
.PP
\fBParameters\fP
.RS 4
\fIsrc\fP Pointer to a string buffer that contains the serialized dimensions, as a list of space separated integers\&. 
.br
\fIsizes\fP Pointer to an array of ints (usually of X_MAX_DIMS size) to which the valid dimensions are deserialized\&.
.RE
.PP
\fBReturns\fP
.RS 4
Number of valid (i\&.e\&. positive) dimensions parsed\&. 
.RE
.PP

.PP
References \fBX_MAX_DIMS\fP\&.
.SS "double xParseDouble (const char * str, char ** tail)"
Same as strtod() on C99, but with explicit parsing of NaN and Infinity values on older platforms also\&.
.PP
\fBParameters\fP
.RS 4
\fIstr\fP String to parse floating-point value from 
.br
\fItail\fP (optional) reference to pointed in which to return the parse position after successfully parsing a floating-point value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
the floating-point value at the head of the string\&. 
.RE
.PP

.PP
References \fBNAN\fP\&.
.SS "int xPrintDims (char * dst, int ndim, const int * sizes)"
Serializes the dimensions to a string\&.
.PP
\fBParameters\fP
.RS 4
\fIdst\fP Pointer to a string buffer with at least X_MAX_STRING_DIMS bytes size\&. 
.br
\fIndim\fP Number of dimensions 
.br
\fIsizes\fP Sizes along each dimension\&.
.RE
.PP
\fBReturns\fP
.RS 4
Number of characters written into the destonation buffer, not counting the string termination\&. 
.RE
.PP

.PP
References \fBX_MAX_DIMS\fP\&.
.SS "int xPrintDouble (char * str, double value)"
Prints a double precision number, restricted to IEEE double-precision range\&. If the native value has abolute value smaller than the smallest non-zero value, then 0 will printed instead\&. For values that exceed the IEEE double precision range, 'nan' will be printed\&.
.PP
\fBParameters\fP
.RS 4
\fIstr\fP Pointer to buffer for printed value\&. 
.br
\fIvalue\fP Value to print\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Number of characters printed into the buffer\&. 
.RE
.PP

.SS "int xPrintFloat (char * str, float value)"
Prints a single-precision number, restricted to IEEE single-precision range\&. If the native value has abolute value smaller than the smallest non-zero value, then 0 will printed instead\&. For values that exceed the IEEE double precision range, 'nan' will be printed\&.
.PP
\fBParameters\fP
.RS 4
\fIstr\fP Pointer to buffer for printed value\&. 
.br
\fIvalue\fP Value to print\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Number of characters printed into the buffer\&. 
.RE
.PP

.SS "void xSetVerbose (\fBboolean\fP value)"
Sets verbose output for the xchange library\&.
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP TRUE (non-zero) to enable verbose output, or else FALSE (0)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBxIsVerbose()\fP 
.RE
.PP

.PP
References \fBFALSE\fP, \fBTRUE\fP, and \fBxVerbose\fP\&.
.SS "char * xStringCopyOf (const char * str)"
Returns a freshly allocated string with the same content as the argument\&.
.PP
\fBParameters\fP
.RS 4
\fIstr\fP Pointer to string we want to copy\&.
.RE
.PP
\fBReturns\fP
.RS 4
A copy of the supplied string, or NULL if the argument itself was NULL\&. 
.RE
.PP

.SS "int xStringElementSizeOf (\fBXType\fP type)"
Returns the number of characters, including a '\\0' termination that a single element of the might be expected to fill\&.
.PP
\fBParameters\fP
.RS 4
\fItype\fP X-Change type to check\&.
.RE
.PP
\fBReturns\fP
.RS 4
Number of characters (including termination) required for the string representation of an element of the given variable, or 0 if the variable is of unknown type\&. 
.RE
.PP

.PP
References \fBX_BOOLEAN\fP, \fBX_BYTE\fP, \fBX_BYTE_HEX\fP, \fBX_DOUBLE\fP, \fBX_FLOAT\fP, \fBX_INT\fP, \fBX_INT_HEX\fP, \fBX_LONG\fP, \fBX_LONG_HEX\fP, \fBX_SHORT\fP, and \fBX_SHORT_HEX\fP\&.
.SS "char xTypeChar (\fBXType\fP type)"
Returns the character of the field type\&. For X_CHAR types it returns 'C' (without the length specification), and for all other types it returns the constant XType value itself\&.
.PP
\fBParameters\fP
.RS 4
\fItype\fP The single-character IF of the field type\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A character that represented the type\&. 
.RE
.PP

.SS "void xZero (void * buf, \fBXType\fP type, int count)"
Zeroes out the contents of an SMA-X buffer\&.
.PP
\fBParameters\fP
.RS 4
\fIbuf\fP Pointer to the buffer to fill with zeroes\&. 
.br
\fItype\fP SMA-X type 
.br
\fIcount\fP number of elements\&. 
.RE
.PP

.PP
References \fBxElementSizeOf()\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for xchange from the source code\&.
