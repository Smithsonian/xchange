.TH "src/xchange.c" 3 "Version v1.0" "xchange" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/xchange.c \- A collection of commonly used functions for standard data exchange for scalars and arrays, and ASCII representations\&.  

.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB__XCHANGE_INTERNAL_API__\fP"
.br
.RI "Use internal definitions\&. "
.ti -1c
.RI "#define \fBEIXPLICIT_PARSE_SPECIAL_DOUBLES\fP   \fBTRUE\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBx_error\fP (int ret, int en, const char *from, const char *desc,\&.\&.\&.)"
.br
.ti -1c
.RI "int \fBx_trace\fP (const char *loc, const char *op, int n)"
.br
.ti -1c
.RI "void * \fBx_trace_null\fP (const char *loc, const char *op)"
.br
.ti -1c
.RI "int \fBx_warn\fP (const char *from, const char *desc,\&.\&.\&.)"
.br
.ti -1c
.RI "void * \fBxAlloc\fP (\fBXType\fP type, int count)"
.br
.ti -1c
.RI "int \fBxElementSizeOf\fP (\fBXType\fP type)"
.br
.ti -1c
.RI "int \fBxError\fP (const char *fn, int code)"
.br
.ti -1c
.RI "const char * \fBxErrorDescription\fP (int code)"
.br
.ti -1c
.RI "long \fBxGetElementCount\fP (int ndim, const int *sizes)"
.br
.ti -1c
.RI "\fBboolean\fP \fBxIsCharSequence\fP (\fBXType\fP type)"
.br
.ti -1c
.RI "\fBboolean\fP \fBxIsDecimal\fP (\fBXType\fP type)"
.br
.ti -1c
.RI "\fBboolean\fP \fBxIsInteger\fP (\fBXType\fP type)"
.br
.ti -1c
.RI "\fBboolean\fP \fBxIsNumeric\fP (\fBXType\fP type)"
.br
.ti -1c
.RI "\fBboolean\fP \fBxIsVerbose\fP ()"
.br
.ti -1c
.RI "\fBboolean\fP \fBxParseBoolean\fP (char *str, char **end)"
.br
.ti -1c
.RI "int \fBxParseDims\fP (const char *src, int *sizes)"
.br
.ti -1c
.RI "double \fBxParseDouble\fP (const char *str, char **tail)"
.br
.ti -1c
.RI "int \fBxPrintDims\fP (char *dst, int ndim, const int *sizes)"
.br
.ti -1c
.RI "int \fBxPrintDouble\fP (char *str, double value)"
.br
.ti -1c
.RI "int \fBxPrintFloat\fP (char *str, float value)"
.br
.ti -1c
.RI "void \fBxSetDebug\fP (\fBboolean\fP value)"
.br
.ti -1c
.RI "void \fBxSetVerbose\fP (\fBboolean\fP value)"
.br
.ti -1c
.RI "char * \fBxStringCopyOf\fP (const char *str)"
.br
.ti -1c
.RI "int \fBxStringElementSizeOf\fP (\fBXType\fP type)"
.br
.ti -1c
.RI "char \fBxTypeChar\fP (\fBXType\fP type)"
.br
.ti -1c
.RI "void \fBxZero\fP (void *buf, \fBXType\fP type, int count)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBboolean\fP \fBxDebug\fP = \fBFALSE\fP"
.br
.RI "Switch to enable debugging (very verbose) output for XChange operations\&. "
.ti -1c
.RI "\fBboolean\fP \fBxVerbose\fP"
.br
.RI "Switch to enable verbose console output for XChange operations\&. "
.in -1c
.SH "Detailed Description"
.PP 
A collection of commonly used functions for standard data exchange for scalars and arrays, and ASCII representations\&. 


.PP
\fBDate\fP
.RS 4
Nov 25, 2020 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP

.SH "Macro Definition Documentation"
.PP 
.SS "#define EIXPLICIT_PARSE_SPECIAL_DOUBLES   \fBTRUE\fP"
Check if we need to parse special floating point values, such as 'nan', 'infinity' or 'inf'\&.\&.\&. These were added in the C99 standard, at the same time as the constant INFINITY was added\&. 
.SH "Function Documentation"
.PP 
.SS "int x_error (int ret, int en, const char * from, const char * desc,  \&.\&.\&.)"
(\fIfor internal use\fP) Sets errno and reports errors to the standard error, depending on the current debug mode, before returning the supplied return code\&.
.PP
\fBParameters\fP
.RS 4
\fIret\fP return value 
.br
\fIen\fP UNIX error code (see errno\&.h) 
.br
\fIfrom\fP function (:location) where error originated 
.br
\fIdesc\fP description of error, with information to convey to user\&.
.RE
.PP
\fBSee also\fP
.RS 4
x_set_errno() 
.PP
\fBx_trace()\fP 
.RE
.PP

.PP
References \fBxDebug\fP\&.
.SS "int x_trace (const char * loc, const char * op, int n)"
(\fIfor internal use\fP) Propagates an error (if any)\&. If the error is non-zero, it returns with the offset error value\&. Otherwise it keeps going as if it weren't even there\&.\&.\&.
.PP
\fBParameters\fP
.RS 4
\fIloc\fP Function [:location] where error was produced\&. 
.br
\fIop\fP (optional) further info or NULL\&. 
.br
\fIn\fP error code that was received\&.
.RE
.PP
\fBReturns\fP
.RS 4
n 
.RE
.PP

.PP
References \fBxDebug\fP\&.
.SS "void * x_trace_null (const char * loc, const char * op)"
(\fIfor internal use\fP) Traces an error before returning NULL\&.
.PP
\fBParameters\fP
.RS 4
\fIloc\fP Function [:location] where error was produced\&. 
.br
\fIop\fP (optional) further info or NULL\&. 
.RE
.PP
\fBReturns\fP
.RS 4
NULL 
.RE
.PP

.PP
References \fBxDebug\fP\&.
.SS "int x_warn (const char * from, const char * desc,  \&.\&.\&.)"
(\fIfor internal use\fP) Prints a warning message\&.
.PP
\fBParameters\fP
.RS 4
\fIfrom\fP function (:location) where error originated 
.br
\fIdesc\fP description of error, with information to convey to user\&.
.RE
.PP
\fBSee also\fP
.RS 4
x_set_errno() 
.PP
\fBx_trace()\fP 
.RE
.PP

.PP
References \fBxDebug\fP\&.
.SS "void * xAlloc (\fBXType\fP type, int count)"
Allocates a buffer for a given SMA-X type and element count\&. The buffer is initialized with zeroes\&.
.PP
\fBParameters\fP
.RS 4
\fItype\fP SMA-X type 
.br
\fIcount\fP number of elements\&.
.RE
.PP
\fBReturns\fP
.RS 4
Pointer to the initialized buffer or NULL if there was an error (errno will be set accordingly)\&. 
.RE
.PP

.PP
References \fBx_error()\fP, \fBx_trace_null()\fP, and \fBxElementSizeOf()\fP\&.
.SS "int xElementSizeOf (\fBXType\fP type)"
Returns the storage byte size of a single element of a given type\&.
.PP
\fBParameters\fP
.RS 4
\fItype\fP The data type, as defined in '\fBxchange\&.h\fP'
.RE
.PP
\fBReturns\fP
.RS 4
[bytes] the native storage size of a single element of that type\&. E\&.g\&. for X_CHAR(20) it will return 20\&. X_DOUBLE will return 8, etc\&. Unrecognised types will return 0\&. 
.RE
.PP

.PP
References \fBX_BOOLEAN\fP, \fBX_BYTE\fP, \fBX_DOUBLE\fP, \fBX_FIELD\fP, \fBX_FLOAT\fP, \fBX_INT16\fP, \fBX_INT32\fP, \fBX_INT64\fP, \fBX_RAW\fP, \fBX_STRING\fP, and \fBX_STRUCT\fP\&.
.SS "int xError (const char * fn, int code)"
Prints a descriptive error message to stderr, and returns the error code\&.
.PP
\fBParameters\fP
.RS 4
\fIfn\fP String that describes the function or location where the error occurred\&. 
.br
\fIcode\fP The xchange error code that describes the failure (see \fBxchange\&.h\fP)\&.
.RE
.PP
\fBReturns\fP
.RS 4
Same error code as specified on input\&. 
.RE
.PP

.PP
References \fBX_ALREADY_OPEN\fP, \fBx_error()\fP, \fBX_FAILURE\fP, \fBX_GROUP_INVALID\fP, \fBX_INCOMPLETE\fP, \fBX_INTERRUPTED\fP, \fBX_NAME_INVALID\fP, \fBX_NO_BLOCKED_READ\fP, \fBX_NO_INIT\fP, \fBX_NO_PIPELINE\fP, \fBX_NO_SERVICE\fP, \fBX_NOT_ENOUGH_TOKENS\fP, \fBX_NULL\fP, \fBX_PARSE_ERROR\fP, \fBX_SIZE_INVALID\fP, \fBX_SUCCESS\fP, \fBX_TIMEDOUT\fP, and \fBX_TYPE_INVALID\fP\&.
.SS "const char * xErrorDescription (int code)"
Returns a string description for one of the standard X-change error codes, and sets errno as appropriate also\&. (The mapping to error codes is not one-to-one\&. The same errno may be used to describe different X-change errors\&. Nevertheless, it is a guide that can be used when the X-change error is not directtly available, e\&.g\&. because it is not returned by a given function\&.)
.PP
\fBParameters\fP
.RS 4
\fIcode\fP One of the error codes defined in '\fBxchange\&.h\fP'
.RE
.PP
\fBReturns\fP
.RS 4
A constant string with the error description\&. 
.RE
.PP

.PP
References \fBX_ALREADY_OPEN\fP, \fBX_FAILURE\fP, \fBX_GROUP_INVALID\fP, \fBX_INCOMPLETE\fP, \fBX_INTERRUPTED\fP, \fBX_NAME_INVALID\fP, \fBX_NO_BLOCKED_READ\fP, \fBX_NO_INIT\fP, \fBX_NO_PIPELINE\fP, \fBX_NO_SERVICE\fP, \fBX_NOT_ENOUGH_TOKENS\fP, \fBX_NULL\fP, \fBX_PARSE_ERROR\fP, \fBX_SIZE_INVALID\fP, \fBX_SUCCESS\fP, \fBX_TIMEDOUT\fP, and \fBX_TYPE_INVALID\fP\&.
.SS "long xGetElementCount (int ndim, const int * sizes)"
Returns the total element count specified by along a number of dimensions\&. It ignores dimensions that have size components <= 0;
.PP
\fBParameters\fP
.RS 4
\fIndim\fP Number of dimensions 
.br
\fIsizes\fP Sizes along each dimension\&.
.RE
.PP
\fBReturns\fP
.RS 4
Total element count specified by the dimensions\&. Defaults to 1\&. 
.RE
.PP

.PP
References \fBx_error()\fP, and \fBX_MAX_DIMS\fP\&.
.SS "\fBboolean\fP xIsCharSequence (\fBXType\fP type)"
Checks if the type represents a fixed-size character / binary sequence\&.
.PP
\fBParameters\fP
.RS 4
\fItype\fP xchange type to check\&.
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if it is a type for a (fixed size) character array, otherwise FALSE (0)\&. 
.RE
.PP

.SS "\fBboolean\fP xIsDecimal (\fBXType\fP type)"
Checks if the type represents a floating-point value of any width\&.
.PP
\fBParameters\fP
.RS 4
\fItype\fP xchange type to check\&. 
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the type is for a floating-point value, or else FALSE (0)
.RE
.PP
\fBSee also\fP
.RS 4
\fBxIsInteger()\fP 
.PP
\fBxIsNumeric()\fP 
.PP
\fBxGetAsDouble()\fP 
.RE
.PP

.PP
References \fBX_DOUBLE\fP, and \fBX_FLOAT\fP\&.
.SS "\fBboolean\fP xIsInteger (\fBXType\fP type)"
Checks if the type represents a signed integer value of any width\&.
.PP
\fBParameters\fP
.RS 4
\fItype\fP xchange type to check\&. 
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the type is for an integer value, or else FALSE (0)
.RE
.PP
\fBSee also\fP
.RS 4
\fBxIsDecimal()\fP 
.PP
\fBxIsNumeric()\fP 
.PP
\fBxGetAsLong()\fP 
.RE
.PP

.PP
References \fBFALSE\fP, \fBTRUE\fP, \fBX_BOOLEAN\fP, \fBX_BYTE\fP, \fBX_INT16\fP, \fBX_INT32\fP, and \fBX_INT64\fP\&.
.SS "\fBboolean\fP xIsNumeric (\fBXType\fP type)"
Checks if the type represents a numerical value\&.
.PP
\fBParameters\fP
.RS 4
\fItype\fP xchange type to check\&. 
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the type is for a number value, or else FALSE (0)
.RE
.PP
\fBSee also\fP
.RS 4
\fBxIsInteger()\fP 
.PP
\fBxIsDecimal()\fP 
.RE
.PP

.PP
References \fBxIsDecimal()\fP, and \fBxIsInteger()\fP\&.
.SS "\fBboolean\fP xIsVerbose ()"
Checks if verbosity is enabled for the xchange library\&.
.PP
\fBReturns\fP
.RS 4
TRUE (1) if verbosity is enabled, or else FALSE (0)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBxSetVerbose()\fP 
.PP
\fBxSetDebug()\fP 
.RE
.PP

.PP
References \fBxVerbose\fP\&.
.SS "\fBboolean\fP xParseBoolean (char * str, char ** end)"
Parses a boolean value, either as a zero/non-zero number or as a case-insensitive match to the next token to one of the recognized boolean terms, such as 'true'/'false', 'on'/'off', 'yes'/'no', 't'/'f', 'y'/'n', 'enabled'/'disabled' or 'active'/'inactive'\&. If a boolean value cannot be matched, FALSE is returned, and errno is set to ERANGE\&.
.PP
\fBParameters\fP
.RS 4
\fIstr\fP Pointer to the string token\&. 
.br
\fIend\fP Where the pointer to after the successfully parsed token is returned, on NULL\&. 
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) or FALSE (0)\&. 
.RE
.PP

.PP
References \fBFALSE\fP, \fBTRUE\fP, and \fBx_error()\fP\&.
.SS "int xParseDims (const char * src, int * sizes)"
Deserializes the sizes from a space-separated list of dimensions\&. The parsing will terminate at the first non integer value or the end of string, whichever comes first\&. Integer values <= 0 are ignored\&.
.PP
\fBParameters\fP
.RS 4
\fIsrc\fP Pointer to a string buffer that contains the serialized dimensions, as a list of space separated integers\&. 
.br
\fIsizes\fP Pointer to an array of ints (usually of X_MAX_DIMS size) to which the valid dimensions are deserialized\&.
.RE
.PP
\fBReturns\fP
.RS 4
Number of valid (i\&.e\&. positive) dimensions parsed\&. 
.RE
.PP

.PP
References \fBx_error()\fP, and \fBX_MAX_DIMS\fP\&.
.SS "double xParseDouble (const char * str, char ** tail)"
Same as strtod() on C99, but with explicit parsing of NaN and Infinity values on older platforms also\&.
.PP
\fBParameters\fP
.RS 4
\fIstr\fP String to parse floating-point value from 
.br
\fItail\fP (optional) reference to pointed in which to return the parse position after successfully parsing a floating-point value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
the floating-point value at the head of the string, or NAN if the input string is NULL\&. 
.RE
.PP

.PP
References \fBINFINITY\fP, \fBNAN\fP, and \fBx_error()\fP\&.
.SS "int xPrintDims (char * dst, int ndim, const int * sizes)"
Serializes the dimensions to a string as a space-separated list of integers\&.
.PP
\fBParameters\fP
.RS 4
\fIdst\fP Pointer to a string buffer with at least X_MAX_STRING_DIMS bytes size\&. 
.br
\fIndim\fP Number of dimensions 
.br
\fIsizes\fP Sizes along each dimension\&.
.RE
.PP
\fBReturns\fP
.RS 4
Number of characters written into the destination buffer, not counting the string termination, or -1 if an the essential pointer arguments is NULL\&. 
.RE
.PP

.PP
References \fBx_error()\fP, and \fBX_MAX_DIMS\fP\&.
.SS "int xPrintDouble (char * str, double value)"
Prints a double precision number, restricted to legal double-precision range\&. If the native value has abolute value smaller than the smallest non-zero value, then 0 will printed instead\&. For values that exceed the legal double precision range, '-inf' or 'inf' will be used as appropriate, and NAN values will be printed as 'nan'\&.
.PP
\fBParameters\fP
.RS 4
\fIstr\fP Pointer to buffer for printed value\&. It should have at least 25 bytes of space allocated after the specidied address\&. 
.br
\fIvalue\fP Value to print\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Number of characters printed into the buffer, or -1 if there was an error\&. 
.RE
.PP

.PP
References \fBx_error()\fP\&.
.SS "int xPrintFloat (char * str, float value)"
Prints a single-precision number, restricted to the legal single-precision range\&. If the native value has abolute value smaller than the smallest non-zero value, then 0 will printed instead\&. For values that exceed the legal double precision range, '-inf' or 'inf' will be used as appropriate, and NAN values will be printed as 'nan'\&.
.PP
\fBParameters\fP
.RS 4
\fIstr\fP Pointer to buffer for printed value\&. It should have at least 16 bytes of space allocated after the specified address\&. 
.br
\fIvalue\fP Value to print\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Number of characters printed into the buffer\&. 
.RE
.PP

.PP
References \fBx_error()\fP\&.
.SS "void xSetDebug (\fBboolean\fP value)"
Enables or disables debugging output\&.
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP TRUE (non-zero) to enable verbose output, or else FALSE (0)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBxSetVerbose()\fP 
.RE
.PP

.PP
References \fBFALSE\fP, \fBTRUE\fP, and \fBxDebug\fP\&.
.SS "void xSetVerbose (\fBboolean\fP value)"
Sets verbose output for the xchange library\&.
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP TRUE (non-zero) to enable verbose output, or else FALSE (0)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBxIsVerbose()\fP 
.RE
.PP

.PP
References \fBFALSE\fP, \fBTRUE\fP, and \fBxVerbose\fP\&.
.SS "char * xStringCopyOf (const char * str)"
Returns a freshly allocated string with the same content as the argument\&.
.PP
\fBParameters\fP
.RS 4
\fIstr\fP Pointer to string we want to copy\&.
.RE
.PP
\fBReturns\fP
.RS 4
A copy of the supplied string, or NULL if the argument itself was NULL\&. 
.RE
.PP

.SS "int xStringElementSizeOf (\fBXType\fP type)"
Returns the number of characters, including a '\\0' termination that a single element of the might be expected to fill\&.
.PP
\fBParameters\fP
.RS 4
\fItype\fP X-Change type to check\&.
.RE
.PP
\fBReturns\fP
.RS 4
Number of characters (including termination) required for the string representation of an element of the given variable, or 0 if the variable is of unknown type\&. 
.RE
.PP

.PP
References \fBX_BOOLEAN\fP, \fBX_BYTE\fP, \fBX_DOUBLE\fP, \fBx_error()\fP, \fBX_FLOAT\fP, \fBX_INT16\fP, \fBX_INT32\fP, and \fBX_INT64\fP\&.
.SS "char xTypeChar (\fBXType\fP type)"
Returns the character of the field type\&. For X_CHAR types it returns 'C' (without the length specification), and for all other types it returns the constant XType value itself\&.
.PP
\fBParameters\fP
.RS 4
\fItype\fP The single-character IF of the field type\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A character that represented the type\&. 
.RE
.PP

.PP
References \fBx_error()\fP\&.
.SS "void xZero (void * buf, \fBXType\fP type, int count)"
Zeroes out the contents of an SMA-X buffer\&.
.PP
\fBParameters\fP
.RS 4
\fIbuf\fP Pointer to the buffer to fill with zeroes\&. 
.br
\fItype\fP SMA-X type 
.br
\fIcount\fP number of elements\&. 
.RE
.PP

.PP
References \fBxElementSizeOf()\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for xchange from the source code\&.
